{
    "sourceFile": "js/jquery-2.1.0.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1674934780481,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1674934808409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,3090 +1,10993 @@\n-/*! jQuery v2.1.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */ ! function(a, b) {\n-    \"object\" == typeof module && \"object\" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {\n-        if (!a.document) throw new Error(\"jQuery requires a window with a document\");\n-        return b(a)\n-    } : b(a)\n-}(\"undefined\" != typeof window ? window : this, function(a, b) {\n-    var c = [],\n-        d = c.slice,\n-        e = c.concat,\n-        f = c.push,\n-        g = c.indexOf,\n-        h = {},\n-        i = h.toString,\n-        j = h.hasOwnProperty,\n-        k = \"\".trim,\n-        l = {},\n-        m = a.document,\n-        n = \"2.1.0\",\n-        o = function(a, b) {\n-            return new o.fn.init(a, b)\n-        },\n-        p = /^-ms-/,\n-        q = /-([\\da-z])/gi,\n-        r = function(a, b) {\n-            return b.toUpperCase()\n-        };\n-    o.fn = o.prototype = {\n-        jquery: n,\n-        constructor: o,\n-        selector: \"\",\n-        length: 0,\n-        toArray: function() {\n-            return d.call(this)\n-        },\n-        get: function(a) {\n-            return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this)\n-        },\n-        pushStack: function(a) {\n-            var b = o.merge(this.constructor(), a);\n-            return b.prevObject = this, b.context = this.context, b\n-        },\n-        each: function(a, b) {\n-            return o.each(this, a, b)\n-        },\n-        map: function(a) {\n-            return this.pushStack(o.map(this, function(b, c) {\n-                return a.call(b, c, b)\n-            }))\n-        },\n-        slice: function() {\n-            return this.pushStack(d.apply(this, arguments))\n-        },\n-        first: function() {\n-            return this.eq(0)\n-        },\n-        last: function() {\n-            return this.eq(-1)\n-        },\n-        eq: function(a) {\n-            var b = this.length,\n-                c = +a + (0 > a ? b : 0);\n-            return this.pushStack(c >= 0 && b > c ? [this[c]] : [])\n-        },\n-        end: function() {\n-            return this.prevObject || this.constructor(null)\n-        },\n-        push: f,\n-        sort: c.sort,\n-        splice: c.splice\n-    }, o.extend = o.fn.extend = function() {\n-        var a, b, c, d, e, f, g = arguments[0] || {},\n-            h = 1,\n-            i = arguments.length,\n-            j = !1;\n-        for (\"boolean\" == typeof g && (j = g, g = arguments[h] || {}, h++), \"object\" == typeof g || o.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)\n-            if (null != (a = arguments[h]))\n-                for (b in a) c = g[b], d = a[b], g !== d && (j && d && (o.isPlainObject(d) || (e = o.isArray(d))) ? (e ? (e = !1, f = c && o.isArray(c) ? c : []) : f = c && o.isPlainObject(c) ? c : {}, g[b] = o.extend(j, f, d)) : void 0 !== d && (g[b] = d));\n-        return g\n-    }, o.extend({\n-        expando: \"jQuery\" + (n + Math.random()).replace(/\\D/g, \"\"),\n-        isReady: !0,\n-        error: function(a) {\n-            throw new Error(a)\n-        },\n-        noop: function() {},\n-        isFunction: function(a) {\n-            return \"function\" === o.type(a)\n-        },\n-        isArray: Array.isArray,\n-        isWindow: function(a) {\n-            return null != a && a === a.window\n-        },\n-        isNumeric: function(a) {\n-            return a - parseFloat(a) >= 0\n-        },\n-        isPlainObject: function(a) {\n-            if (\"object\" !== o.type(a) || a.nodeType || o.isWindow(a)) return !1;\n-            try {\n-                if (a.constructor && !j.call(a.constructor.prototype, \"isPrototypeOf\")) return !1\n-            } catch (b) {\n-                return !1\n-            }\n-            return !0\n-        },\n-        isEmptyObject: function(a) {\n-            var b;\n-            for (b in a) return !1;\n-            return !0\n-        },\n-        type: function(a) {\n-            return null == a ? a + \"\" : \"object\" == typeof a || \"function\" == typeof a ? h[i.call(a)] || \"object\" : typeof a\n-        },\n-        globalEval: function(a) {\n-            var b, c = eval;\n-            a = o.trim(a), a && (1 === a.indexOf(\"use strict\") ? (b = m.createElement(\"script\"), b.text = a, m.head.appendChild(b).parentNode.removeChild(b)) : c(a))\n-        },\n-        camelCase: function(a) {\n-            return a.replace(p, \"ms-\").replace(q, r)\n-        },\n-        nodeName: function(a, b) {\n-            return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()\n-        },\n-        each: function(a, b, c) {\n-            var d, e = 0,\n-                f = a.length,\n-                g = s(a);\n-            if (c) {\n-                if (g) {\n-                    for (; f > e; e++)\n-                        if (d = b.apply(a[e], c), d === !1) break\n-                } else\n-                    for (e in a)\n-                        if (d = b.apply(a[e], c), d === !1) break\n-            } else if (g) {\n-                for (; f > e; e++)\n-                    if (d = b.call(a[e], e, a[e]), d === !1) break\n-            } else\n-                for (e in a)\n-                    if (d = b.call(a[e], e, a[e]), d === !1) break;\n-            return a\n-        },\n-        trim: function(a) {\n-            return null == a ? \"\" : k.call(a)\n-        },\n-        makeArray: function(a, b) {\n-            var c = b || [];\n-            return null != a && (s(Object(a)) ? o.merge(c, \"string\" == typeof a ? [a] : a) : f.call(c, a)), c\n-        },\n-        inArray: function(a, b, c) {\n-            return null == b ? -1 : g.call(b, a, c)\n-        },\n-        merge: function(a, b) {\n-            for (var c = +b.length, d = 0, e = a.length; c > d; d++) a[e++] = b[d];\n-            return a.length = e, a\n-        },\n-        grep: function(a, b, c) {\n-            for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);\n-            return e\n-        },\n-        map: function(a, b, c) {\n-            var d, f = 0,\n-                g = a.length,\n-                h = s(a),\n-                i = [];\n-            if (h)\n-                for (; g > f; f++) d = b(a[f], f, c), null != d && i.push(d);\n-            else\n-                for (f in a) d = b(a[f], f, c), null != d && i.push(d);\n-            return e.apply([], i)\n-        },\n-        guid: 1,\n-        proxy: function(a, b) {\n-            var c, e, f;\n-            return \"string\" == typeof b && (c = a[b], b = a, a = c), o.isFunction(a) ? (e = d.call(arguments, 2), f = function() {\n-                return a.apply(b || this, e.concat(d.call(arguments)))\n-            }, f.guid = a.guid = a.guid || o.guid++, f) : void 0\n-        },\n-        now: Date.now,\n-        support: l\n-    }), o.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(a, b) {\n-        h[\"[object \" + b + \"]\"] = b.toLowerCase()\n-    });\n+/*!\n+ * jQuery JavaScript Library v3.6.3\n+ * https://jquery.com/\n+ *\n+ * Includes Sizzle.js\n+ * https://sizzlejs.com/\n+ *\n+ * Copyright OpenJS Foundation and other contributors\n+ * Released under the MIT license\n+ * https://jquery.org/license\n+ *\n+ * Date: 2022-12-20T21:28Z\n+ */\n+( function( global, factory ) {\n \n-    function s(a) {\n-        var b = a.length,\n-            c = o.type(a);\n-        return \"function\" === c || o.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : \"array\" === c || 0 === b || \"number\" == typeof b && b > 0 && b - 1 in a\n-    }\n-    var t = function(a) {\n-        var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s = \"sizzle\" + -new Date,\n-            t = a.document,\n-            u = 0,\n-            v = 0,\n-            w = eb(),\n-            x = eb(),\n-            y = eb(),\n-            z = function(a, b) {\n-                return a === b && (j = !0), 0\n-            },\n-            A = \"undefined\",\n-            B = 1 << 31,\n-            C = {}.hasOwnProperty,\n-            D = [],\n-            E = D.pop,\n-            F = D.push,\n-            G = D.push,\n-            H = D.slice,\n-            I = D.indexOf || function(a) {\n-                for (var b = 0, c = this.length; c > b; b++)\n-                    if (this[b] === a) return b;\n-                return -1\n-            },\n-            J = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n-            K = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n-            L = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n-            M = L.replace(\"w\", \"w#\"),\n-            N = \"\\\\[\" + K + \"*(\" + L + \")\" + K + \"*(?:([*^$|!~]?=)\" + K + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + M + \")|)|)\" + K + \"*\\\\]\",\n-            O = \":(\" + L + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + N.replace(3, 8) + \")*)|.*)\\\\)|)\",\n-            P = new RegExp(\"^\" + K + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + K + \"+$\", \"g\"),\n-            Q = new RegExp(\"^\" + K + \"*,\" + K + \"*\"),\n-            R = new RegExp(\"^\" + K + \"*([>+~]|\" + K + \")\" + K + \"*\"),\n-            S = new RegExp(\"=\" + K + \"*([^\\\\]'\\\"]*?)\" + K + \"*\\\\]\", \"g\"),\n-            T = new RegExp(O),\n-            U = new RegExp(\"^\" + M + \"$\"),\n-            V = {\n-                ID: new RegExp(\"^#(\" + L + \")\"),\n-                CLASS: new RegExp(\"^\\\\.(\" + L + \")\"),\n-                TAG: new RegExp(\"^(\" + L.replace(\"w\", \"w*\") + \")\"),\n-                ATTR: new RegExp(\"^\" + N),\n-                PSEUDO: new RegExp(\"^\" + O),\n-                CHILD: new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + K + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + K + \"*(?:([+-]|)\" + K + \"*(\\\\d+)|))\" + K + \"*\\\\)|)\", \"i\"),\n-                bool: new RegExp(\"^(?:\" + J + \")$\", \"i\"),\n-                needsContext: new RegExp(\"^\" + K + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + K + \"*((?:-\\\\d)?\\\\d*)\" + K + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n-            },\n-            W = /^(?:input|select|textarea|button)$/i,\n-            X = /^h\\d$/i,\n-            Y = /^[^{]+\\{\\s*\\[native \\w/,\n-            Z = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n-            $ = /[+~]/,\n-            _ = /'|\\\\/g,\n-            ab = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + K + \"?|(\" + K + \")|.)\", \"ig\"),\n-            bb = function(a, b, c) {\n-                var d = \"0x\" + b - 65536;\n-                return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)\n-            };\n-        try {\n-            G.apply(D = H.call(t.childNodes), t.childNodes), D[t.childNodes.length].nodeType\n-        } catch (cb) {\n-            G = {\n-                apply: D.length ? function(a, b) {\n-                    F.apply(a, H.call(b))\n-                } : function(a, b) {\n-                    var c = a.length,\n-                        d = 0;\n-                    while (a[c++] = b[d++]);\n-                    a.length = c - 1\n-                }\n-            }\n-        }\n+\t\"use strict\";\n \n-        function db(a, b, d, e) {\n-            var f, g, h, i, j, m, p, q, u, v;\n-            if ((b ? b.ownerDocument || b : t) !== l && k(b), b = b || l, d = d || [], !a || \"string\" != typeof a) return d;\n-            if (1 !== (i = b.nodeType) && 9 !== i) return [];\n-            if (n && !e) {\n-                if (f = Z.exec(a))\n-                    if (h = f[1]) {\n-                        if (9 === i) {\n-                            if (g = b.getElementById(h), !g || !g.parentNode) return d;\n-                            if (g.id === h) return d.push(g), d\n-                        } else if (b.ownerDocument && (g = b.ownerDocument.getElementById(h)) && r(b, g) && g.id === h) return d.push(g), d\n-                    } else {\n-                        if (f[2]) return G.apply(d, b.getElementsByTagName(a)), d;\n-                        if ((h = f[3]) && c.getElementsByClassName && b.getElementsByClassName) return G.apply(d, b.getElementsByClassName(h)), d\n-                    }\n-                if (c.qsa && (!o || !o.test(a))) {\n-                    if (q = p = s, u = b, v = 9 === i && a, 1 === i && \"object\" !== b.nodeName.toLowerCase()) {\n-                        m = ob(a), (p = b.getAttribute(\"id\")) ? q = p.replace(_, \"\\\\$&\") : b.setAttribute(\"id\", q), q = \"[id='\" + q + \"'] \", j = m.length;\n-                        while (j--) m[j] = q + pb(m[j]);\n-                        u = $.test(a) && mb(b.parentNode) || b, v = m.join(\",\")\n-                    }\n-                    if (v) try {\n-                        return G.apply(d, u.querySelectorAll(v)), d\n-                    } catch (w) {} finally {\n-                        p || b.removeAttribute(\"id\")\n-                    }\n-                }\n-            }\n-            return xb(a.replace(P, \"$1\"), b, d, e)\n-        }\n+\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n \n-        function eb() {\n-            var a = [];\n+\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n+\t\t// is present, execute the factory and get jQuery.\n+\t\t// For environments that do not have a `window` with a `document`\n+\t\t// (such as Node.js), expose a factory as module.exports.\n+\t\t// This accentuates the need for the creation of a real `window`.\n+\t\t// e.g. var jQuery = require(\"jquery\")(window);\n+\t\t// See ticket trac-14549 for more info.\n+\t\tmodule.exports = global.document ?\n+\t\t\tfactory( global, true ) :\n+\t\t\tfunction( w ) {\n+\t\t\t\tif ( !w.document ) {\n+\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n+\t\t\t\t}\n+\t\t\t\treturn factory( w );\n+\t\t\t};\n+\t} else {\n+\t\tfactory( global );\n+\t}\n \n-            function b(c, e) {\n-                return a.push(c + \" \") > d.cacheLength && delete b[a.shift()], b[c + \" \"] = e\n-            }\n-            return b\n-        }\n+// Pass this if window is not defined yet\n+} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n \n-        function fb(a) {\n-            return a[s] = !0, a\n-        }\n+// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n+// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n+// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n+// enough that all such attempts are guarded in a try block.\n+\"use strict\";\n \n-        function gb(a) {\n-            var b = l.createElement(\"div\");\n-            try {\n-                return !!a(b)\n-            } catch (c) {\n-                return !1\n-            } finally {\n-                b.parentNode && b.parentNode.removeChild(b), b = null\n-            }\n-        }\n+var arr = [];\n \n-        function hb(a, b) {\n-            var c = a.split(\"|\"),\n-                e = a.length;\n-            while (e--) d.attrHandle[c[e]] = b\n-        }\n+var getProto = Object.getPrototypeOf;\n \n-        function ib(a, b) {\n-            var c = b && a,\n-                d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || B) - (~a.sourceIndex || B);\n-            if (d) return d;\n-            if (c)\n-                while (c = c.nextSibling)\n-                    if (c === b) return -1;\n-            return a ? 1 : -1\n-        }\n+var slice = arr.slice;\n \n-        function jb(a) {\n-            return function(b) {\n-                var c = b.nodeName.toLowerCase();\n-                return \"input\" === c && b.type === a\n-            }\n-        }\n+var flat = arr.flat ? function( array ) {\n+\treturn arr.flat.call( array );\n+} : function( array ) {\n+\treturn arr.concat.apply( [], array );\n+};\n \n-        function kb(a) {\n-            return function(b) {\n-                var c = b.nodeName.toLowerCase();\n-                return (\"input\" === c || \"button\" === c) && b.type === a\n-            }\n-        }\n \n-        function lb(a) {\n-            return fb(function(b) {\n-                return b = +b, fb(function(c, d) {\n-                    var e, f = a([], c.length, b),\n-                        g = f.length;\n-                    while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e]))\n-                })\n-            })\n-        }\n+var push = arr.push;\n \n-        function mb(a) {\n-            return a && typeof a.getElementsByTagName !== A && a\n-        }\n-        c = db.support = {}, f = db.isXML = function(a) {\n-            var b = a && (a.ownerDocument || a).documentElement;\n-            return b ? \"HTML\" !== b.nodeName : !1\n-        }, k = db.setDocument = function(a) {\n-            var b, e = a ? a.ownerDocument || a : t,\n-                g = e.defaultView;\n-            return e !== l && 9 === e.nodeType && e.documentElement ? (l = e, m = e.documentElement, n = !f(e), g && g !== g.top && (g.addEventListener ? g.addEventListener(\"unload\", function() {\n-                k()\n-            }, !1) : g.attachEvent && g.attachEvent(\"onunload\", function() {\n-                k()\n-            })), c.attributes = gb(function(a) {\n-                return a.className = \"i\", !a.getAttribute(\"className\")\n-            }), c.getElementsByTagName = gb(function(a) {\n-                return a.appendChild(e.createComment(\"\")), !a.getElementsByTagName(\"*\").length\n-            }), c.getElementsByClassName = Y.test(e.getElementsByClassName) && gb(function(a) {\n-                return a.innerHTML = \"<div class='a'></div><div class='a i'></div>\", a.firstChild.className = \"i\", 2 === a.getElementsByClassName(\"i\").length\n-            }), c.getById = gb(function(a) {\n-                return m.appendChild(a).id = s, !e.getElementsByName || !e.getElementsByName(s).length\n-            }), c.getById ? (d.find.ID = function(a, b) {\n-                if (typeof b.getElementById !== A && n) {\n-                    var c = b.getElementById(a);\n-                    return c && c.parentNode ? [c] : []\n-                }\n-            }, d.filter.ID = function(a) {\n-                var b = a.replace(ab, bb);\n-                return function(a) {\n-                    return a.getAttribute(\"id\") === b\n-                }\n-            }) : (delete d.find.ID, d.filter.ID = function(a) {\n-                var b = a.replace(ab, bb);\n-                return function(a) {\n-                    var c = typeof a.getAttributeNode !== A && a.getAttributeNode(\"id\");\n-                    return c && c.value === b\n-                }\n-            }), d.find.TAG = c.getElementsByTagName ? function(a, b) {\n-                return typeof b.getElementsByTagName !== A ? b.getElementsByTagName(a) : void 0\n-            } : function(a, b) {\n-                var c, d = [],\n-                    e = 0,\n-                    f = b.getElementsByTagName(a);\n-                if (\"*\" === a) {\n-                    while (c = f[e++]) 1 === c.nodeType && d.push(c);\n-                    return d\n-                }\n-                return f\n-            }, d.find.CLASS = c.getElementsByClassName && function(a, b) {\n-                return typeof b.getElementsByClassName !== A && n ? b.getElementsByClassName(a) : void 0\n-            }, p = [], o = [], (c.qsa = Y.test(e.querySelectorAll)) && (gb(function(a) {\n-                a.innerHTML = \"<select t=''><option selected=''></option></select>\", a.querySelectorAll(\"[t^='']\").length && o.push(\"[*^$]=\" + K + \"*(?:''|\\\"\\\")\"), a.querySelectorAll(\"[selected]\").length || o.push(\"\\\\[\" + K + \"*(?:value|\" + J + \")\"), a.querySelectorAll(\":checked\").length || o.push(\":checked\")\n-            }), gb(function(a) {\n-                var b = e.createElement(\"input\");\n-                b.setAttribute(\"type\", \"hidden\"), a.appendChild(b).setAttribute(\"name\", \"D\"), a.querySelectorAll(\"[name=d]\").length && o.push(\"name\" + K + \"*[*^$|!~]?=\"), a.querySelectorAll(\":enabled\").length || o.push(\":enabled\", \":disabled\"), a.querySelectorAll(\"*,:x\"), o.push(\",.*:\")\n-            })), (c.matchesSelector = Y.test(q = m.webkitMatchesSelector || m.mozMatchesSelector || m.oMatchesSelector || m.msMatchesSelector)) && gb(function(a) {\n-                c.disconnectedMatch = q.call(a, \"div\"), q.call(a, \"[s!='']:x\"), p.push(\"!=\", O)\n-            }), o = o.length && new RegExp(o.join(\"|\")), p = p.length && new RegExp(p.join(\"|\")), b = Y.test(m.compareDocumentPosition), r = b || Y.test(m.contains) ? function(a, b) {\n-                var c = 9 === a.nodeType ? a.documentElement : a,\n-                    d = b && b.parentNode;\n-                return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))\n-            } : function(a, b) {\n-                if (b)\n-                    while (b = b.parentNode)\n-                        if (b === a) return !0;\n-                return !1\n-            }, z = b ? function(a, b) {\n-                if (a === b) return j = !0, 0;\n-                var d = !a.compareDocumentPosition - !b.compareDocumentPosition;\n-                return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === e || a.ownerDocument === t && r(t, a) ? -1 : b === e || b.ownerDocument === t && r(t, b) ? 1 : i ? I.call(i, a) - I.call(i, b) : 0 : 4 & d ? -1 : 1)\n-            } : function(a, b) {\n-                if (a === b) return j = !0, 0;\n-                var c, d = 0,\n-                    f = a.parentNode,\n-                    g = b.parentNode,\n-                    h = [a],\n-                    k = [b];\n-                if (!f || !g) return a === e ? -1 : b === e ? 1 : f ? -1 : g ? 1 : i ? I.call(i, a) - I.call(i, b) : 0;\n-                if (f === g) return ib(a, b);\n-                c = a;\n-                while (c = c.parentNode) h.unshift(c);\n-                c = b;\n-                while (c = c.parentNode) k.unshift(c);\n-                while (h[d] === k[d]) d++;\n-                return d ? ib(h[d], k[d]) : h[d] === t ? -1 : k[d] === t ? 1 : 0\n-            }, e) : l\n-        }, db.matches = function(a, b) {\n-            return db(a, null, null, b)\n-        }, db.matchesSelector = function(a, b) {\n-            if ((a.ownerDocument || a) !== l && k(a), b = b.replace(S, \"='$1']\"), !(!c.matchesSelector || !n || p && p.test(b) || o && o.test(b))) try {\n-                var d = q.call(a, b);\n-                if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d\n-            } catch (e) {}\n-            return db(b, l, null, [a]).length > 0\n-        }, db.contains = function(a, b) {\n-            return (a.ownerDocument || a) !== l && k(a), r(a, b)\n-        }, db.attr = function(a, b) {\n-            (a.ownerDocument || a) !== l && k(a);\n-            var e = d.attrHandle[b.toLowerCase()],\n-                f = e && C.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !n) : void 0;\n-            return void 0 !== f ? f : c.attributes || !n ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null\n-        }, db.error = function(a) {\n-            throw new Error(\"Syntax error, unrecognized expression: \" + a)\n-        }, db.uniqueSort = function(a) {\n-            var b, d = [],\n-                e = 0,\n-                f = 0;\n-            if (j = !c.detectDuplicates, i = !c.sortStable && a.slice(0), a.sort(z), j) {\n-                while (b = a[f++]) b === a[f] && (e = d.push(f));\n-                while (e--) a.splice(d[e], 1)\n-            }\n-            return i = null, a\n-        }, e = db.getText = function(a) {\n-            var b, c = \"\",\n-                d = 0,\n-                f = a.nodeType;\n-            if (f) {\n-                if (1 === f || 9 === f || 11 === f) {\n-                    if (\"string\" == typeof a.textContent) return a.textContent;\n-                    for (a = a.firstChild; a; a = a.nextSibling) c += e(a)\n-                } else if (3 === f || 4 === f) return a.nodeValue\n-            } else\n-                while (b = a[d++]) c += e(b);\n-            return c\n-        }, d = db.selectors = {\n-            cacheLength: 50,\n-            createPseudo: fb,\n-            match: V,\n-            attrHandle: {},\n-            find: {},\n-            relative: {\n-                \">\": {\n-                    dir: \"parentNode\",\n-                    first: !0\n-                },\n-                \" \": {\n-                    dir: \"parentNode\"\n-                },\n-                \"+\": {\n-                    dir: \"previousSibling\",\n-                    first: !0\n-                },\n-                \"~\": {\n-                    dir: \"previousSibling\"\n-                }\n-            },\n-            preFilter: {\n-                ATTR: function(a) {\n-                    return a[1] = a[1].replace(ab, bb), a[3] = (a[4] || a[5] || \"\").replace(ab, bb), \"~=\" === a[2] && (a[3] = \" \" + a[3] + \" \"), a.slice(0, 4)\n-                },\n-                CHILD: function(a) {\n-                    return a[1] = a[1].toLowerCase(), \"nth\" === a[1].slice(0, 3) ? (a[3] || db.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * (\"even\" === a[3] || \"odd\" === a[3])), a[5] = +(a[7] + a[8] || \"odd\" === a[3])) : a[3] && db.error(a[0]), a\n-                },\n-                PSEUDO: function(a) {\n-                    var b, c = !a[5] && a[2];\n-                    return V.CHILD.test(a[0]) ? null : (a[3] && void 0 !== a[4] ? a[2] = a[4] : c && T.test(c) && (b = ob(c, !0)) && (b = c.indexOf(\")\", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))\n-                }\n-            },\n-            filter: {\n-                TAG: function(a) {\n-                    var b = a.replace(ab, bb).toLowerCase();\n-                    return \"*\" === a ? function() {\n-                        return !0\n-                    } : function(a) {\n-                        return a.nodeName && a.nodeName.toLowerCase() === b\n-                    }\n-                },\n-                CLASS: function(a) {\n-                    var b = w[a + \" \"];\n-                    return b || (b = new RegExp(\"(^|\" + K + \")\" + a + \"(\" + K + \"|$)\")) && w(a, function(a) {\n-                        return b.test(\"string\" == typeof a.className && a.className || typeof a.getAttribute !== A && a.getAttribute(\"class\") || \"\")\n-                    })\n-                },\n-                ATTR: function(a, b, c) {\n-                    return function(d) {\n-                        var e = db.attr(d, a);\n-                        return null == e ? \"!=\" === b : b ? (e += \"\", \"=\" === b ? e === c : \"!=\" === b ? e !== c : \"^=\" === b ? c && 0 === e.indexOf(c) : \"*=\" === b ? c && e.indexOf(c) > -1 : \"$=\" === b ? c && e.slice(-c.length) === c : \"~=\" === b ? (\" \" + e + \" \").indexOf(c) > -1 : \"|=\" === b ? e === c || e.slice(0, c.length + 1) === c + \"-\" : !1) : !0\n-                    }\n-                },\n-                CHILD: function(a, b, c, d, e) {\n-                    var f = \"nth\" !== a.slice(0, 3),\n-                        g = \"last\" !== a.slice(-4),\n-                        h = \"of-type\" === b;\n-                    return 1 === d && 0 === e ? function(a) {\n-                        return !!a.parentNode\n-                    } : function(b, c, i) {\n-                        var j, k, l, m, n, o, p = f !== g ? \"nextSibling\" : \"previousSibling\",\n-                            q = b.parentNode,\n-                            r = h && b.nodeName.toLowerCase(),\n-                            t = !i && !h;\n-                        if (q) {\n-                            if (f) {\n-                                while (p) {\n-                                    l = b;\n-                                    while (l = l[p])\n-                                        if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;\n-                                    o = p = \"only\" === a && !o && \"nextSibling\"\n-                                }\n-                                return !0\n-                            }\n-                            if (o = [g ? q.firstChild : q.lastChild], g && t) {\n-                                k = q[s] || (q[s] = {}), j = k[a] || [], n = j[0] === u && j[1], m = j[0] === u && j[2], l = n && q.childNodes[n];\n-                                while (l = ++n && l && l[p] || (m = n = 0) || o.pop())\n-                                    if (1 === l.nodeType && ++m && l === b) {\n-                                        k[a] = [u, n, m];\n-                                        break\n-                                    }\n-                            } else if (t && (j = (b[s] || (b[s] = {}))[a]) && j[0] === u) m = j[1];\n-                            else\n-                                while (l = ++n && l && l[p] || (m = n = 0) || o.pop())\n-                                    if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) && ++m && (t && ((l[s] || (l[s] = {}))[a] = [u, m]), l === b)) break;\n-                            return m -= e, m === d || m % d === 0 && m / d >= 0\n-                        }\n-                    }\n-                },\n-                PSEUDO: function(a, b) {\n-                    var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || db.error(\"unsupported pseudo: \" + a);\n-                    return e[s] ? e(b) : e.length > 1 ? (c = [a, a, \"\", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? fb(function(a, c) {\n-                        var d, f = e(a, b),\n-                            g = f.length;\n-                        while (g--) d = I.call(a, f[g]), a[d] = !(c[d] = f[g])\n-                    }) : function(a) {\n-                        return e(a, 0, c)\n-                    }) : e\n-                }\n-            },\n-            pseudos: {\n-                not: fb(function(a) {\n-                    var b = [],\n-                        c = [],\n-                        d = g(a.replace(P, \"$1\"));\n-                    return d[s] ? fb(function(a, b, c, e) {\n-                        var f, g = d(a, null, e, []),\n-                            h = a.length;\n-                        while (h--)(f = g[h]) && (a[h] = !(b[h] = f))\n-                    }) : function(a, e, f) {\n-                        return b[0] = a, d(b, null, f, c), !c.pop()\n-                    }\n-                }),\n-                has: fb(function(a) {\n-                    return function(b) {\n-                        return db(a, b).length > 0\n-                    }\n-                }),\n-                contains: fb(function(a) {\n-                    return function(b) {\n-                        return (b.textContent || b.innerText || e(b)).indexOf(a) > -1\n-                    }\n-                }),\n-                lang: fb(function(a) {\n-                    return U.test(a || \"\") || db.error(\"unsupported lang: \" + a), a = a.replace(ab, bb).toLowerCase(),\n-                        function(b) {\n-                            var c;\n-                            do\n-                                if (c = n ? b.lang : b.getAttribute(\"xml:lang\") || b.getAttribute(\"lang\")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + \"-\"); while ((b = b.parentNode) && 1 === b.nodeType);\n-                            return !1\n-                        }\n-                }),\n-                target: function(b) {\n-                    var c = a.location && a.location.hash;\n-                    return c && c.slice(1) === b.id\n-                },\n-                root: function(a) {\n-                    return a === m\n-                },\n-                focus: function(a) {\n-                    return a === l.activeElement && (!l.hasFocus || l.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)\n-                },\n-                enabled: function(a) {\n-                    return a.disabled === !1\n-                },\n-                disabled: function(a) {\n-                    return a.disabled === !0\n-                },\n-                checked: function(a) {\n-                    var b = a.nodeName.toLowerCase();\n-                    return \"input\" === b && !!a.checked || \"option\" === b && !!a.selected\n-                },\n-                selected: function(a) {\n-                    return a.parentNode && a.parentNode.selectedIndex, a.selected === !0\n-                },\n-                empty: function(a) {\n-                    for (a = a.firstChild; a; a = a.nextSibling)\n-                        if (a.nodeType < 6) return !1;\n-                    return !0\n-                },\n-                parent: function(a) {\n-                    return !d.pseudos.empty(a)\n-                },\n-                header: function(a) {\n-                    return X.test(a.nodeName)\n-                },\n-                input: function(a) {\n-                    return W.test(a.nodeName)\n-                },\n-                button: function(a) {\n-                    var b = a.nodeName.toLowerCase();\n-                    return \"input\" === b && \"button\" === a.type || \"button\" === b\n-                },\n-                text: function(a) {\n-                    var b;\n-                    return \"input\" === a.nodeName.toLowerCase() && \"text\" === a.type && (null == (b = a.getAttribute(\"type\")) || \"text\" === b.toLowerCase())\n-                },\n-                first: lb(function() {\n-                    return [0]\n-                }),\n-                last: lb(function(a, b) {\n-                    return [b - 1]\n-                }),\n-                eq: lb(function(a, b, c) {\n-                    return [0 > c ? c + b : c]\n-                }),\n-                even: lb(function(a, b) {\n-                    for (var c = 0; b > c; c += 2) a.push(c);\n-                    return a\n-                }),\n-                odd: lb(function(a, b) {\n-                    for (var c = 1; b > c; c += 2) a.push(c);\n-                    return a\n-                }),\n-                lt: lb(function(a, b, c) {\n-                    for (var d = 0 > c ? c + b : c; --d >= 0;) a.push(d);\n-                    return a\n-                }),\n-                gt: lb(function(a, b, c) {\n-                    for (var d = 0 > c ? c + b : c; ++d < b;) a.push(d);\n-                    return a\n-                })\n-            }\n-        }, d.pseudos.nth = d.pseudos.eq;\n-        for (b in {\n-                radio: !0,\n-                checkbox: !0,\n-                file: !0,\n-                password: !0,\n-                image: !0\n-            }) d.pseudos[b] = jb(b);\n-        for (b in {\n-                submit: !0,\n-                reset: !0\n-            }) d.pseudos[b] = kb(b);\n+var indexOf = arr.indexOf;\n \n-        function nb() {}\n-        nb.prototype = d.filters = d.pseudos, d.setFilters = new nb;\n+var class2type = {};\n \n-        function ob(a, b) {\n-            var c, e, f, g, h, i, j, k = x[a + \" \"];\n-            if (k) return b ? 0 : k.slice(0);\n-            h = a, i = [], j = d.preFilter;\n-            while (h) {\n-                (!c || (e = Q.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = R.exec(h)) && (c = e.shift(), f.push({\n-                    value: c,\n-                    type: e[0].replace(P, \" \")\n-                }), h = h.slice(c.length));\n-                for (g in d.filter) !(e = V[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({\n-                    value: c,\n-                    type: g,\n-                    matches: e\n-                }), h = h.slice(c.length));\n-                if (!c) break\n-            }\n-            return b ? h.length : h ? db.error(a) : x(a, i).slice(0)\n-        }\n+var toString = class2type.toString;\n \n-        function pb(a) {\n-            for (var b = 0, c = a.length, d = \"\"; c > b; b++) d += a[b].value;\n-            return d\n-        }\n+var hasOwn = class2type.hasOwnProperty;\n \n-        function qb(a, b, c) {\n-            var d = b.dir,\n-                e = c && \"parentNode\" === d,\n-                f = v++;\n-            return b.first ? function(b, c, f) {\n-                while (b = b[d])\n-                    if (1 === b.nodeType || e) return a(b, c, f)\n-            } : function(b, c, g) {\n-                var h, i, j = [u, f];\n-                if (g) {\n-                    while (b = b[d])\n-                        if ((1 === b.nodeType || e) && a(b, c, g)) return !0\n-                } else\n-                    while (b = b[d])\n-                        if (1 === b.nodeType || e) {\n-                            if (i = b[s] || (b[s] = {}), (h = i[d]) && h[0] === u && h[1] === f) return j[2] = h[2];\n-                            if (i[d] = j, j[2] = a(b, c, g)) return !0\n-                        }\n-            }\n-        }\n+var fnToString = hasOwn.toString;\n \n-        function rb(a) {\n-            return a.length > 1 ? function(b, c, d) {\n-                var e = a.length;\n-                while (e--)\n-                    if (!a[e](b, c, d)) return !1;\n-                return !0\n-            } : a[0]\n-        }\n+var ObjectFunctionString = fnToString.call( Object );\n \n-        function sb(a, b, c, d, e) {\n-            for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)(f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h));\n-            return g\n-        }\n+var support = {};\n \n-        function tb(a, b, c, d, e, f) {\n-            return d && !d[s] && (d = tb(d)), e && !e[s] && (e = tb(e, f)), fb(function(f, g, h, i) {\n-                var j, k, l, m = [],\n-                    n = [],\n-                    o = g.length,\n-                    p = f || wb(b || \"*\", h.nodeType ? [h] : h, []),\n-                    q = !a || !f && b ? p : sb(p, m, a, h, i),\n-                    r = c ? e || (f ? a : o || d) ? [] : g : q;\n-                if (c && c(q, r, h, i), d) {\n-                    j = sb(r, n), d(j, [], h, i), k = j.length;\n-                    while (k--)(l = j[k]) && (r[n[k]] = !(q[n[k]] = l))\n-                }\n-                if (f) {\n-                    if (e || a) {\n-                        if (e) {\n-                            j = [], k = r.length;\n-                            while (k--)(l = r[k]) && j.push(q[k] = l);\n-                            e(null, r = [], j, i)\n-                        }\n-                        k = r.length;\n-                        while (k--)(l = r[k]) && (j = e ? I.call(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l))\n-                    }\n-                } else r = sb(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : G.apply(g, r)\n-            })\n-        }\n+var isFunction = function isFunction( obj ) {\n \n-        function ub(a) {\n-            for (var b, c, e, f = a.length, g = d.relative[a[0].type], i = g || d.relative[\" \"], j = g ? 1 : 0, k = qb(function(a) {\n-                    return a === b\n-                }, i, !0), l = qb(function(a) {\n-                    return I.call(b, a) > -1\n-                }, i, !0), m = [function(a, c, d) {\n-                    return !g && (d || c !== h) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d))\n-                }]; f > j; j++)\n-                if (c = d.relative[a[j].type]) m = [qb(rb(m), c)];\n-                else {\n-                    if (c = d.filter[a[j].type].apply(null, a[j].matches), c[s]) {\n-                        for (e = ++j; f > e; e++)\n-                            if (d.relative[a[e].type]) break;\n-                        return tb(j > 1 && rb(m), j > 1 && pb(a.slice(0, j - 1).concat({\n-                            value: \" \" === a[j - 2].type ? \"*\" : \"\"\n-                        })).replace(P, \"$1\"), c, e > j && ub(a.slice(j, e)), f > e && ub(a = a.slice(e)), f > e && pb(a))\n-                    }\n-                    m.push(c)\n-                }\n-            return rb(m)\n-        }\n+\t\t// Support: Chrome <=57, Firefox <=52\n+\t\t// In some browsers, typeof returns \"function\" for HTML <object> elements\n+\t\t// (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n+\t\t// We don't want to classify *any* DOM node as a function.\n+\t\t// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n+\t\t// Plus for old WebKit, typeof returns \"function\" for HTML collections\n+\t\t// (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\n+\t\treturn typeof obj === \"function\" && typeof obj.nodeType !== \"number\" &&\n+\t\t\ttypeof obj.item !== \"function\";\n+\t};\n \n-        function vb(a, b) {\n-            var c = b.length > 0,\n-                e = a.length > 0,\n-                f = function(f, g, i, j, k) {\n-                    var m, n, o, p = 0,\n-                        q = \"0\",\n-                        r = f && [],\n-                        s = [],\n-                        t = h,\n-                        v = f || e && d.find.TAG(\"*\", k),\n-                        w = u += null == t ? 1 : Math.random() || .1,\n-                        x = v.length;\n-                    for (k && (h = g !== l && g); q !== x && null != (m = v[q]); q++) {\n-                        if (e && m) {\n-                            n = 0;\n-                            while (o = a[n++])\n-                                if (o(m, g, i)) {\n-                                    j.push(m);\n-                                    break\n-                                }\n-                            k && (u = w)\n-                        }\n-                        c && ((m = !o && m) && p--, f && r.push(m))\n-                    }\n-                    if (p += q, c && q !== p) {\n-                        n = 0;\n-                        while (o = b[n++]) o(r, s, g, i);\n-                        if (f) {\n-                            if (p > 0)\n-                                while (q--) r[q] || s[q] || (s[q] = E.call(j));\n-                            s = sb(s)\n-                        }\n-                        G.apply(j, s), k && !f && s.length > 0 && p + b.length > 1 && db.uniqueSort(j)\n-                    }\n-                    return k && (u = w, h = t), r\n-                };\n-            return c ? fb(f) : f\n-        }\n-        g = db.compile = function(a, b) {\n-            var c, d = [],\n-                e = [],\n-                f = y[a + \" \"];\n-            if (!f) {\n-                b || (b = ob(a)), c = b.length;\n-                while (c--) f = ub(b[c]), f[s] ? d.push(f) : e.push(f);\n-                f = y(a, vb(e, d))\n-            }\n-            return f\n-        };\n \n-        function wb(a, b, c) {\n-            for (var d = 0, e = b.length; e > d; d++) db(a, b[d], c);\n-            return c\n-        }\n+var isWindow = function isWindow( obj ) {\n+\t\treturn obj != null && obj === obj.window;\n+\t};\n \n-        function xb(a, b, e, f) {\n-            var h, i, j, k, l, m = ob(a);\n-            if (!f && 1 === m.length) {\n-                if (i = m[0] = m[0].slice(0), i.length > 2 && \"ID\" === (j = i[0]).type && c.getById && 9 === b.nodeType && n && d.relative[i[1].type]) {\n-                    if (b = (d.find.ID(j.matches[0].replace(ab, bb), b) || [])[0], !b) return e;\n-                    a = a.slice(i.shift().value.length)\n-                }\n-                h = V.needsContext.test(a) ? 0 : i.length;\n-                while (h--) {\n-                    if (j = i[h], d.relative[k = j.type]) break;\n-                    if ((l = d.find[k]) && (f = l(j.matches[0].replace(ab, bb), $.test(i[0].type) && mb(b.parentNode) || b))) {\n-                        if (i.splice(h, 1), a = f.length && pb(i), !a) return G.apply(e, f), e;\n-                        break\n-                    }\n-                }\n-            }\n-            return g(a, m)(f, b, !n, e, $.test(a) && mb(b.parentNode) || b), e\n-        }\n-        return c.sortStable = s.split(\"\").sort(z).join(\"\") === s, c.detectDuplicates = !!j, k(), c.sortDetached = gb(function(a) {\n-            return 1 & a.compareDocumentPosition(l.createElement(\"div\"))\n-        }), gb(function(a) {\n-            return a.innerHTML = \"<a href='#'></a>\", \"#\" === a.firstChild.getAttribute(\"href\")\n-        }) || hb(\"type|href|height|width\", function(a, b, c) {\n-            return c ? void 0 : a.getAttribute(b, \"type\" === b.toLowerCase() ? 1 : 2)\n-        }), c.attributes && gb(function(a) {\n-            return a.innerHTML = \"<input/>\", a.firstChild.setAttribute(\"value\", \"\"), \"\" === a.firstChild.getAttribute(\"value\")\n-        }) || hb(\"value\", function(a, b, c) {\n-            return c || \"input\" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue\n-        }), gb(function(a) {\n-            return null == a.getAttribute(\"disabled\")\n-        }) || hb(J, function(a, b, c) {\n-            var d;\n-            return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null\n-        }), db\n-    }(a);\n-    o.find = t, o.expr = t.selectors, o.expr[\":\"] = o.expr.pseudos, o.unique = t.uniqueSort, o.text = t.getText, o.isXMLDoc = t.isXML, o.contains = t.contains;\n-    var u = o.expr.match.needsContext,\n-        v = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n-        w = /^.[^:#\\[\\.,]*$/;\n \n-    function x(a, b, c) {\n-        if (o.isFunction(b)) return o.grep(a, function(a, d) {\n-            return !!b.call(a, d, a) !== c\n-        });\n-        if (b.nodeType) return o.grep(a, function(a) {\n-            return a === b !== c\n-        });\n-        if (\"string\" == typeof b) {\n-            if (w.test(b)) return o.filter(b, a, c);\n-            b = o.filter(b, a)\n-        }\n-        return o.grep(a, function(a) {\n-            return g.call(b, a) >= 0 !== c\n-        })\n-    }\n-    o.filter = function(a, b, c) {\n-        var d = b[0];\n-        return c && (a = \":not(\" + a + \")\"), 1 === b.length && 1 === d.nodeType ? o.find.matchesSelector(d, a) ? [d] : [] : o.find.matches(a, o.grep(b, function(a) {\n-            return 1 === a.nodeType\n-        }))\n-    }, o.fn.extend({\n-        find: function(a) {\n-            var b, c = this.length,\n-                d = [],\n-                e = this;\n-            if (\"string\" != typeof a) return this.pushStack(o(a).filter(function() {\n-                for (b = 0; c > b; b++)\n-                    if (o.contains(e[b], this)) return !0\n-            }));\n-            for (b = 0; c > b; b++) o.find(a, e[b], d);\n-            return d = this.pushStack(c > 1 ? o.unique(d) : d), d.selector = this.selector ? this.selector + \" \" + a : a, d\n-        },\n-        filter: function(a) {\n-            return this.pushStack(x(this, a || [], !1))\n-        },\n-        not: function(a) {\n-            return this.pushStack(x(this, a || [], !0))\n-        },\n-        is: function(a) {\n-            return !!x(this, \"string\" == typeof a && u.test(a) ? o(a) : a || [], !1).length\n-        }\n-    });\n-    var y, z = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n-        A = o.fn.init = function(a, b) {\n-            var c, d;\n-            if (!a) return this;\n-            if (\"string\" == typeof a) {\n-                if (c = \"<\" === a[0] && \">\" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : z.exec(a), !c || !c[1] && b) return !b || b.jquery ? (b || y).find(a) : this.constructor(b).find(a);\n-                if (c[1]) {\n-                    if (b = b instanceof o ? b[0] : b, o.merge(this, o.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : m, !0)), v.test(c[1]) && o.isPlainObject(b))\n-                        for (c in b) o.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);\n-                    return this\n-                }\n-                return d = m.getElementById(c[2]), d && d.parentNode && (this.length = 1, this[0] = d), this.context = m, this.selector = a, this\n-            }\n-            return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : o.isFunction(a) ? \"undefined\" != typeof y.ready ? y.ready(a) : a(o) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), o.makeArray(a, this))\n-        };\n-    A.prototype = o.fn, y = o(m);\n-    var B = /^(?:parents|prev(?:Until|All))/,\n-        C = {\n-            children: !0,\n-            contents: !0,\n-            next: !0,\n-            prev: !0\n-        };\n-    o.extend({\n-        dir: function(a, b, c) {\n-            var d = [],\n-                e = void 0 !== c;\n-            while ((a = a[b]) && 9 !== a.nodeType)\n-                if (1 === a.nodeType) {\n-                    if (e && o(a).is(c)) break;\n-                    d.push(a)\n-                }\n-            return d\n-        },\n-        sibling: function(a, b) {\n-            for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);\n-            return c\n-        }\n-    }), o.fn.extend({\n-        has: function(a) {\n-            var b = o(a, this),\n-                c = b.length;\n-            return this.filter(function() {\n-                for (var a = 0; c > a; a++)\n-                    if (o.contains(this, b[a])) return !0\n-            })\n-        },\n-        closest: function(a, b) {\n-            for (var c, d = 0, e = this.length, f = [], g = u.test(a) || \"string\" != typeof a ? o(a, b || this.context) : 0; e > d; d++)\n-                for (c = this[d]; c && c !== b; c = c.parentNode)\n-                    if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && o.find.matchesSelector(c, a))) {\n-                        f.push(c);\n-                        break\n-                    }\n-            return this.pushStack(f.length > 1 ? o.unique(f) : f)\n-        },\n-        index: function(a) {\n-            return a ? \"string\" == typeof a ? g.call(o(a), this[0]) : g.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1\n-        },\n-        add: function(a, b) {\n-            return this.pushStack(o.unique(o.merge(this.get(), o(a, b))))\n-        },\n-        addBack: function(a) {\n-            return this.add(null == a ? this.prevObject : this.prevObject.filter(a))\n-        }\n-    });\n+var document = window.document;\n \n-    function D(a, b) {\n-        while ((a = a[b]) && 1 !== a.nodeType);\n-        return a\n-    }\n-    o.each({\n-        parent: function(a) {\n-            var b = a.parentNode;\n-            return b && 11 !== b.nodeType ? b : null\n-        },\n-        parents: function(a) {\n-            return o.dir(a, \"parentNode\")\n-        },\n-        parentsUntil: function(a, b, c) {\n-            return o.dir(a, \"parentNode\", c)\n-        },\n-        next: function(a) {\n-            return D(a, \"nextSibling\")\n-        },\n-        prev: function(a) {\n-            return D(a, \"previousSibling\")\n-        },\n-        nextAll: function(a) {\n-            return o.dir(a, \"nextSibling\")\n-        },\n-        prevAll: function(a) {\n-            return o.dir(a, \"previousSibling\")\n-        },\n-        nextUntil: function(a, b, c) {\n-            return o.dir(a, \"nextSibling\", c)\n-        },\n-        prevUntil: function(a, b, c) {\n-            return o.dir(a, \"previousSibling\", c)\n-        },\n-        siblings: function(a) {\n-            return o.sibling((a.parentNode || {}).firstChild, a)\n-        },\n-        children: function(a) {\n-            return o.sibling(a.firstChild)\n-        },\n-        contents: function(a) {\n-            return a.contentDocument || o.merge([], a.childNodes)\n-        }\n-    }, function(a, b) {\n-        o.fn[a] = function(c, d) {\n-            var e = o.map(this, b, c);\n-            return \"Until\" !== a.slice(-5) && (d = c), d && \"string\" == typeof d && (e = o.filter(d, e)), this.length > 1 && (C[a] || o.unique(e), B.test(a) && e.reverse()), this.pushStack(e)\n-        }\n-    });\n-    var E = /\\S+/g,\n-        F = {};\n \n-    function G(a) {\n-        var b = F[a] = {};\n-        return o.each(a.match(E) || [], function(a, c) {\n-            b[c] = !0\n-        }), b\n-    }\n-    o.Callbacks = function(a) {\n-        a = \"string\" == typeof a ? F[a] || G(a) : o.extend({}, a);\n-        var b, c, d, e, f, g, h = [],\n-            i = !a.once && [],\n-            j = function(l) {\n-                for (b = a.memory && l, c = !0, g = e || 0, e = 0, f = h.length, d = !0; h && f > g; g++)\n-                    if (h[g].apply(l[0], l[1]) === !1 && a.stopOnFalse) {\n-                        b = !1;\n-                        break\n-                    }\n-                d = !1, h && (i ? i.length && j(i.shift()) : b ? h = [] : k.disable())\n-            },\n-            k = {\n-                add: function() {\n-                    if (h) {\n-                        var c = h.length;\n-                        ! function g(b) {\n-                            o.each(b, function(b, c) {\n-                                var d = o.type(c);\n-                                \"function\" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && \"string\" !== d && g(c)\n-                            })\n-                        }(arguments), d ? f = h.length : b && (e = c, j(b))\n-                    }\n-                    return this\n-                },\n-                remove: function() {\n-                    return h && o.each(arguments, function(a, b) {\n-                        var c;\n-                        while ((c = o.inArray(b, h, c)) > -1) h.splice(c, 1), d && (f >= c && f--, g >= c && g--)\n-                    }), this\n-                },\n-                has: function(a) {\n-                    return a ? o.inArray(a, h) > -1 : !(!h || !h.length)\n-                },\n-                empty: function() {\n-                    return h = [], f = 0, this\n-                },\n-                disable: function() {\n-                    return h = i = b = void 0, this\n-                },\n-                disabled: function() {\n-                    return !h\n-                },\n-                lock: function() {\n-                    return i = void 0, b || k.disable(), this\n-                },\n-                locked: function() {\n-                    return !i\n-                },\n-                fireWith: function(a, b) {\n-                    return !h || c && !i || (b = b || [], b = [a, b.slice ? b.slice() : b], d ? i.push(b) : j(b)), this\n-                },\n-                fire: function() {\n-                    return k.fireWith(this, arguments), this\n-                },\n-                fired: function() {\n-                    return !!c\n-                }\n-            };\n-        return k\n-    }, o.extend({\n-        Deferred: function(a) {\n-            var b = [\n-                    [\"resolve\", \"done\", o.Callbacks(\"once memory\"), \"resolved\"],\n-                    [\"reject\", \"fail\", o.Callbacks(\"once memory\"), \"rejected\"],\n-                    [\"notify\", \"progress\", o.Callbacks(\"memory\")]\n-                ],\n-                c = \"pending\",\n-                d = {\n-                    state: function() {\n-                        return c\n-                    },\n-                    always: function() {\n-                        return e.done(arguments).fail(arguments), this\n-                    },\n-                    then: function() {\n-                        var a = arguments;\n-                        return o.Deferred(function(c) {\n-                            o.each(b, function(b, f) {\n-                                var g = o.isFunction(a[b]) && a[b];\n-                                e[f[1]](function() {\n-                                    var a = g && g.apply(this, arguments);\n-                                    a && o.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + \"With\"](this === d ? c.promise() : this, g ? [a] : arguments)\n-                                })\n-                            }), a = null\n-                        }).promise()\n-                    },\n-                    promise: function(a) {\n-                        return null != a ? o.extend(a, d) : d\n-                    }\n-                },\n-                e = {};\n-            return d.pipe = d.then, o.each(b, function(a, f) {\n-                var g = f[2],\n-                    h = f[3];\n-                d[f[1]] = g.add, h && g.add(function() {\n-                    c = h\n-                }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {\n-                    return e[f[0] + \"With\"](this === e ? d : this, arguments), this\n-                }, e[f[0] + \"With\"] = g.fireWith\n-            }), d.promise(e), a && a.call(e, e), e\n-        },\n-        when: function(a) {\n-            var b = 0,\n-                c = d.call(arguments),\n-                e = c.length,\n-                f = 1 !== e || a && o.isFunction(a.promise) ? e : 0,\n-                g = 1 === f ? a : o.Deferred(),\n-                h = function(a, b, c) {\n-                    return function(e) {\n-                        b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c)\n-                    }\n-                },\n-                i, j, k;\n-            if (e > 1)\n-                for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++) c[b] && o.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;\n-            return f || g.resolveWith(k, c), g.promise()\n-        }\n-    });\n-    var H;\n-    o.fn.ready = function(a) {\n-        return o.ready.promise().done(a), this\n-    }, o.extend({\n-        isReady: !1,\n-        readyWait: 1,\n-        holdReady: function(a) {\n-            a ? o.readyWait++ : o.ready(!0)\n-        },\n-        ready: function(a) {\n-            (a === !0 ? --o.readyWait : o.isReady) || (o.isReady = !0, a !== !0 && --o.readyWait > 0 || (H.resolveWith(m, [o]), o.fn.trigger && o(m).trigger(\"ready\").off(\"ready\")))\n-        }\n-    });\n \n-    function I() {\n-        m.removeEventListener(\"DOMContentLoaded\", I, !1), a.removeEventListener(\"load\", I, !1), o.ready()\n-    }\n-    o.ready.promise = function(b) {\n-        return H || (H = o.Deferred(), \"complete\" === m.readyState ? setTimeout(o.ready) : (m.addEventListener(\"DOMContentLoaded\", I, !1), a.addEventListener(\"load\", I, !1))), H.promise(b)\n-    }, o.ready.promise();\n-    var J = o.access = function(a, b, c, d, e, f, g) {\n-        var h = 0,\n-            i = a.length,\n-            j = null == c;\n-        if (\"object\" === o.type(c)) {\n-            e = !0;\n-            for (h in c) o.access(a, b, h, c[h], !0, f, g)\n-        } else if (void 0 !== d && (e = !0, o.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {\n-                return j.call(o(a), c)\n-            })), b))\n-            for (; i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));\n-        return e ? a : j ? b.call(a) : i ? b(a[0], c) : f\n-    };\n-    o.acceptData = function(a) {\n-        return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType\n-    };\n+\tvar preservedScriptAttributes = {\n+\t\ttype: true,\n+\t\tsrc: true,\n+\t\tnonce: true,\n+\t\tnoModule: true\n+\t};\n \n-    function K() {\n-        Object.defineProperty(this.cache = {}, 0, {\n-            get: function() {\n-                return {}\n-            }\n-        }), this.expando = o.expando + Math.random()\n-    }\n-    K.uid = 1, K.accepts = o.acceptData, K.prototype = {\n-        key: function(a) {\n-            if (!K.accepts(a)) return 0;\n-            var b = {},\n-                c = a[this.expando];\n-            if (!c) {\n-                c = K.uid++;\n-                try {\n-                    b[this.expando] = {\n-                        value: c\n-                    }, Object.defineProperties(a, b)\n-                } catch (d) {\n-                    b[this.expando] = c, o.extend(a, b)\n-                }\n-            }\n-            return this.cache[c] || (this.cache[c] = {}), c\n-        },\n-        set: function(a, b, c) {\n-            var d, e = this.key(a),\n-                f = this.cache[e];\n-            if (\"string\" == typeof b) f[b] = c;\n-            else if (o.isEmptyObject(f)) o.extend(this.cache[e], b);\n-            else\n-                for (d in b) f[d] = b[d];\n-            return f\n-        },\n-        get: function(a, b) {\n-            var c = this.cache[this.key(a)];\n-            return void 0 === b ? c : c[b]\n-        },\n-        access: function(a, b, c) {\n-            var d;\n-            return void 0 === b || b && \"string\" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, o.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b)\n-        },\n-        remove: function(a, b) {\n-            var c, d, e, f = this.key(a),\n-                g = this.cache[f];\n-            if (void 0 === b) this.cache[f] = {};\n-            else {\n-                o.isArray(b) ? d = b.concat(b.map(o.camelCase)) : (e = o.camelCase(b), b in g ? d = [b, e] : (d = e, d = d in g ? [d] : d.match(E) || [])), c = d.length;\n-                while (c--) delete g[d[c]]\n-            }\n-        },\n-        hasData: function(a) {\n-            return !o.isEmptyObject(this.cache[a[this.expando]] || {})\n-        },\n-        discard: function(a) {\n-            a[this.expando] && delete this.cache[a[this.expando]]\n-        }\n-    };\n-    var L = new K,\n-        M = new K,\n-        N = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n-        O = /([A-Z])/g;\n+\tfunction DOMEval( code, node, doc ) {\n+\t\tdoc = doc || document;\n \n-    function P(a, b, c) {\n-        var d;\n-        if (void 0 === c && 1 === a.nodeType)\n-            if (d = \"data-\" + b.replace(O, \"-$1\").toLowerCase(), c = a.getAttribute(d), \"string\" == typeof c) {\n-                try {\n-                    c = \"true\" === c ? !0 : \"false\" === c ? !1 : \"null\" === c ? null : +c + \"\" === c ? +c : N.test(c) ? o.parseJSON(c) : c\n-                } catch (e) {}\n-                M.set(a, b, c)\n-            } else c = void 0;\n-        return c\n-    }\n-    o.extend({\n-        hasData: function(a) {\n-            return M.hasData(a) || L.hasData(a)\n-        },\n-        data: function(a, b, c) {\n-            return M.access(a, b, c)\n-        },\n-        removeData: function(a, b) {\n-            M.remove(a, b)\n-        },\n-        _data: function(a, b, c) {\n-            return L.access(a, b, c)\n-        },\n-        _removeData: function(a, b) {\n-            L.remove(a, b)\n-        }\n-    }), o.fn.extend({\n-        data: function(a, b) {\n-            var c, d, e, f = this[0],\n-                g = f && f.attributes;\n-            if (void 0 === a) {\n-                if (this.length && (e = M.get(f), 1 === f.nodeType && !L.get(f, \"hasDataAttrs\"))) {\n-                    c = g.length;\n-                    while (c--) d = g[c].name, 0 === d.indexOf(\"data-\") && (d = o.camelCase(d.slice(5)), P(f, d, e[d]));\n-                    L.set(f, \"hasDataAttrs\", !0)\n-                }\n-                return e\n-            }\n-            return \"object\" == typeof a ? this.each(function() {\n-                M.set(this, a)\n-            }) : J(this, function(b) {\n-                var c, d = o.camelCase(a);\n-                if (f && void 0 === b) {\n-                    if (c = M.get(f, a), void 0 !== c) return c;\n-                    if (c = M.get(f, d), void 0 !== c) return c;\n-                    if (c = P(f, d, void 0), void 0 !== c) return c\n-                } else this.each(function() {\n-                    var c = M.get(this, d);\n-                    M.set(this, d, b), -1 !== a.indexOf(\"-\") && void 0 !== c && M.set(this, a, b)\n-                })\n-            }, null, b, arguments.length > 1, null, !0)\n-        },\n-        removeData: function(a) {\n-            return this.each(function() {\n-                M.remove(this, a)\n-            })\n-        }\n-    }), o.extend({\n-        queue: function(a, b, c) {\n-            var d;\n-            return a ? (b = (b || \"fx\") + \"queue\", d = L.get(a, b), c && (!d || o.isArray(c) ? d = L.access(a, b, o.makeArray(c)) : d.push(c)), d || []) : void 0\n-        },\n-        dequeue: function(a, b) {\n-            b = b || \"fx\";\n-            var c = o.queue(a, b),\n-                d = c.length,\n-                e = c.shift(),\n-                f = o._queueHooks(a, b),\n-                g = function() {\n-                    o.dequeue(a, b)\n-                };\n-            \"inprogress\" === e && (e = c.shift(), d--), e && (\"fx\" === b && c.unshift(\"inprogress\"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()\n-        },\n-        _queueHooks: function(a, b) {\n-            var c = b + \"queueHooks\";\n-            return L.get(a, c) || L.access(a, c, {\n-                empty: o.Callbacks(\"once memory\").add(function() {\n-                    L.remove(a, [b + \"queue\", c])\n-                })\n-            })\n-        }\n-    }), o.fn.extend({\n-        queue: function(a, b) {\n-            var c = 2;\n-            return \"string\" != typeof a && (b = a, a = \"fx\", c--), arguments.length < c ? o.queue(this[0], a) : void 0 === b ? this : this.each(function() {\n-                var c = o.queue(this, a, b);\n-                o._queueHooks(this, a), \"fx\" === a && \"inprogress\" !== c[0] && o.dequeue(this, a)\n-            })\n-        },\n-        dequeue: function(a) {\n-            return this.each(function() {\n-                o.dequeue(this, a)\n-            })\n-        },\n-        clearQueue: function(a) {\n-            return this.queue(a || \"fx\", [])\n-        },\n-        promise: function(a, b) {\n-            var c, d = 1,\n-                e = o.Deferred(),\n-                f = this,\n-                g = this.length,\n-                h = function() {\n-                    --d || e.resolveWith(f, [f])\n-                };\n-            \"string\" != typeof a && (b = a, a = void 0), a = a || \"fx\";\n-            while (g--) c = L.get(f[g], a + \"queueHooks\"), c && c.empty && (d++, c.empty.add(h));\n-            return h(), e.promise(b)\n-        }\n-    });\n-    var Q = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n-        R = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n-        S = function(a, b) {\n-            return a = b || a, \"none\" === o.css(a, \"display\") || !o.contains(a.ownerDocument, a)\n-        },\n-        T = /^(?:checkbox|radio)$/i;\n-    ! function() {\n-        var a = m.createDocumentFragment(),\n-            b = a.appendChild(m.createElement(\"div\"));\n-        b.innerHTML = \"<input type='radio' checked='checked' name='t'/>\", l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = \"<textarea>x</textarea>\", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue\n-    }();\n-    var U = \"undefined\";\n-    l.focusinBubbles = \"onfocusin\" in a;\n-    var V = /^key/,\n-        W = /^(?:mouse|contextmenu)|click/,\n-        X = /^(?:focusinfocus|focusoutblur)$/,\n-        Y = /^([^.]*)(?:\\.(.+)|)$/;\n+\t\tvar i, val,\n+\t\t\tscript = doc.createElement( \"script\" );\n \n-    function Z() {\n-        return !0\n-    }\n+\t\tscript.text = code;\n+\t\tif ( node ) {\n+\t\t\tfor ( i in preservedScriptAttributes ) {\n \n-    function $() {\n-        return !1\n-    }\n+\t\t\t\t// Support: Firefox 64+, Edge 18+\n+\t\t\t\t// Some browsers don't support the \"nonce\" property on scripts.\n+\t\t\t\t// On the other hand, just using `getAttribute` is not enough as\n+\t\t\t\t// the `nonce` attribute is reset to an empty string whenever it\n+\t\t\t\t// becomes browsing-context connected.\n+\t\t\t\t// See https://github.com/whatwg/html/issues/2369\n+\t\t\t\t// See https://html.spec.whatwg.org/#nonce-attributes\n+\t\t\t\t// The `node.getAttribute` check was added for the sake of\n+\t\t\t\t// `jQuery.globalEval` so that it can fake a nonce-containing node\n+\t\t\t\t// via an object.\n+\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n+\t\t\t\tif ( val ) {\n+\t\t\t\t\tscript.setAttribute( i, val );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n+\t}\n \n-    function _() {\n-        try {\n-            return m.activeElement\n-        } catch (a) {}\n-    }\n-    o.event = {\n-        global: {},\n-        add: function(a, b, c, d, e) {\n-            var f, g, h, i, j, k, l, m, n, p, q, r = L.get(a);\n-            if (r) {\n-                c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = o.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function(b) {\n-                    return typeof o !== U && o.event.triggered !== b.type ? o.event.dispatch.apply(a, arguments) : void 0\n-                }), b = (b || \"\").match(E) || [\"\"], j = b.length;\n-                while (j--) h = Y.exec(b[j]) || [], n = q = h[1], p = (h[2] || \"\").split(\".\").sort(), n && (l = o.event.special[n] || {}, n = (e ? l.delegateType : l.bindType) || n, l = o.event.special[n] || {}, k = o.extend({\n-                    type: n,\n-                    origType: q,\n-                    data: d,\n-                    handler: c,\n-                    guid: c.guid,\n-                    selector: e,\n-                    needsContext: e && o.expr.match.needsContext.test(e),\n-                    namespace: p.join(\".\")\n-                }, f), (m = i[n]) || (m = i[n] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(n, g, !1)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), o.event.global[n] = !0)\n-            }\n-        },\n-        remove: function(a, b, c, d, e) {\n-            var f, g, h, i, j, k, l, m, n, p, q, r = L.hasData(a) && L.get(a);\n-            if (r && (i = r.events)) {\n-                b = (b || \"\").match(E) || [\"\"], j = b.length;\n-                while (j--)\n-                    if (h = Y.exec(b[j]) || [], n = q = h[1], p = (h[2] || \"\").split(\".\").sort(), n) {\n-                        l = o.event.special[n] || {}, n = (d ? l.delegateType : l.bindType) || n, m = i[n] || [], h = h[2] && new RegExp(\"(^|\\\\.)\" + p.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"), g = f = m.length;\n-                        while (f--) k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && (\"**\" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));\n-                        g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || o.removeEvent(a, n, r.handle), delete i[n])\n-                    } else\n-                        for (n in i) o.event.remove(a, n + b[j], c, d, !0);\n-                o.isEmptyObject(i) && (delete r.handle, L.remove(a, \"events\"))\n-            }\n-        },\n-        trigger: function(b, c, d, e) {\n-            var f, g, h, i, k, l, n, p = [d || m],\n-                q = j.call(b, \"type\") ? b.type : b,\n-                r = j.call(b, \"namespace\") ? b.namespace.split(\".\") : [];\n-            if (g = h = d = d || m, 3 !== d.nodeType && 8 !== d.nodeType && !X.test(q + o.event.triggered) && (q.indexOf(\".\") >= 0 && (r = q.split(\".\"), q = r.shift(), r.sort()), k = q.indexOf(\":\") < 0 && \"on\" + q, b = b[o.expando] ? b : new o.Event(q, \"object\" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = r.join(\".\"), b.namespace_re = b.namespace ? new RegExp(\"(^|\\\\.)\" + r.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : o.makeArray(c, [b]), n = o.event.special[q] || {}, e || !n.trigger || n.trigger.apply(d, c) !== !1)) {\n-                if (!e && !n.noBubble && !o.isWindow(d)) {\n-                    for (i = n.delegateType || q, X.test(i + q) || (g = g.parentNode); g; g = g.parentNode) p.push(g), h = g;\n-                    h === (d.ownerDocument || m) && p.push(h.defaultView || h.parentWindow || a)\n-                }\n-                f = 0;\n-                while ((g = p[f++]) && !b.isPropagationStopped()) b.type = f > 1 ? i : n.bindType || q, l = (L.get(g, \"events\") || {})[b.type] && L.get(g, \"handle\"), l && l.apply(g, c), l = k && g[k], l && l.apply && o.acceptData(g) && (b.result = l.apply(g, c), b.result === !1 && b.preventDefault());\n-                return b.type = q, e || b.isDefaultPrevented() || n._default && n._default.apply(p.pop(), c) !== !1 || !o.acceptData(d) || k && o.isFunction(d[q]) && !o.isWindow(d) && (h = d[k], h && (d[k] = null), o.event.triggered = q, d[q](), o.event.triggered = void 0, h && (d[k] = h)), b.result\n-            }\n-        },\n-        dispatch: function(a) {\n-            a = o.event.fix(a);\n-            var b, c, e, f, g, h = [],\n-                i = d.call(arguments),\n-                j = (L.get(this, \"events\") || {})[a.type] || [],\n-                k = o.event.special[a.type] || {};\n-            if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {\n-                h = o.event.handlers.call(this, a, j), b = 0;\n-                while ((f = h[b++]) && !a.isPropagationStopped()) {\n-                    a.currentTarget = f.elem, c = 0;\n-                    while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped())(!a.namespace_re || a.namespace_re.test(g.namespace)) && (a.handleObj = g, a.data = g.data, e = ((o.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== e && (a.result = e) === !1 && (a.preventDefault(), a.stopPropagation()))\n-                }\n-                return k.postDispatch && k.postDispatch.call(this, a), a.result\n-            }\n-        },\n-        handlers: function(a, b) {\n-            var c, d, e, f, g = [],\n-                h = b.delegateCount,\n-                i = a.target;\n-            if (h && i.nodeType && (!a.button || \"click\" !== a.type))\n-                for (; i !== this; i = i.parentNode || this)\n-                    if (i.disabled !== !0 || \"click\" !== a.type) {\n-                        for (d = [], c = 0; h > c; c++) f = b[c], e = f.selector + \" \", void 0 === d[e] && (d[e] = f.needsContext ? o(e, this).index(i) >= 0 : o.find(e, this, null, [i]).length), d[e] && d.push(f);\n-                        d.length && g.push({\n-                            elem: i,\n-                            handlers: d\n-                        })\n-                    }\n-            return h < b.length && g.push({\n-                elem: this,\n-                handlers: b.slice(h)\n-            }), g\n-        },\n-        props: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n-        fixHooks: {},\n-        keyHooks: {\n-            props: \"char charCode key keyCode\".split(\" \"),\n-            filter: function(a, b) {\n-                return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a\n-            }\n-        },\n-        mouseHooks: {\n-            props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n-            filter: function(a, b) {\n-                var c, d, e, f = b.button;\n-                return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || m, d = c.documentElement, e = c.body, a.pageX = b.clientX + (d && d.scrollLeft || e && e.scrollLeft || 0) - (d && d.clientLeft || e && e.clientLeft || 0), a.pageY = b.clientY + (d && d.scrollTop || e && e.scrollTop || 0) - (d && d.clientTop || e && e.clientTop || 0)), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a\n-            }\n-        },\n-        fix: function(a) {\n-            if (a[o.expando]) return a;\n-            var b, c, d, e = a.type,\n-                f = a,\n-                g = this.fixHooks[e];\n-            g || (this.fixHooks[e] = g = W.test(e) ? this.mouseHooks : V.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new o.Event(f), b = d.length;\n-            while (b--) c = d[b], a[c] = f[c];\n-            return a.target || (a.target = m), 3 === a.target.nodeType && (a.target = a.target.parentNode), g.filter ? g.filter(a, f) : a\n-        },\n-        special: {\n-            load: {\n-                noBubble: !0\n-            },\n-            focus: {\n-                trigger: function() {\n-                    return this !== _() && this.focus ? (this.focus(), !1) : void 0\n-                },\n-                delegateType: \"focusin\"\n-            },\n-            blur: {\n-                trigger: function() {\n-                    return this === _() && this.blur ? (this.blur(), !1) : void 0\n-                },\n-                delegateType: \"focusout\"\n-            },\n-            click: {\n-                trigger: function() {\n-                    return \"checkbox\" === this.type && this.click && o.nodeName(this, \"input\") ? (this.click(), !1) : void 0\n-                },\n-                _default: function(a) {\n-                    return o.nodeName(a.target, \"a\")\n-                }\n-            },\n-            beforeunload: {\n-                postDispatch: function(a) {\n-                    void 0 !== a.result && (a.originalEvent.returnValue = a.result)\n-                }\n-            }\n-        },\n-        simulate: function(a, b, c, d) {\n-            var e = o.extend(new o.Event, c, {\n-                type: a,\n-                isSimulated: !0,\n-                originalEvent: {}\n-            });\n-            d ? o.event.trigger(e, null, b) : o.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault()\n-        }\n-    }, o.removeEvent = function(a, b, c) {\n-        a.removeEventListener && a.removeEventListener(b, c, !1)\n-    }, o.Event = function(a, b) {\n-        return this instanceof o.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.getPreventDefault && a.getPreventDefault() ? Z : $) : this.type = a, b && o.extend(this, b), this.timeStamp = a && a.timeStamp || o.now(), void(this[o.expando] = !0)) : new o.Event(a, b)\n-    }, o.Event.prototype = {\n-        isDefaultPrevented: $,\n-        isPropagationStopped: $,\n-        isImmediatePropagationStopped: $,\n-        preventDefault: function() {\n-            var a = this.originalEvent;\n-            this.isDefaultPrevented = Z, a && a.preventDefault && a.preventDefault()\n-        },\n-        stopPropagation: function() {\n-            var a = this.originalEvent;\n-            this.isPropagationStopped = Z, a && a.stopPropagation && a.stopPropagation()\n-        },\n-        stopImmediatePropagation: function() {\n-            this.isImmediatePropagationStopped = Z, this.stopPropagation()\n-        }\n-    }, o.each({\n-        mouseenter: \"mouseover\",\n-        mouseleave: \"mouseout\"\n-    }, function(a, b) {\n-        o.event.special[a] = {\n-            delegateType: b,\n-            bindType: b,\n-            handle: function(a) {\n-                var c, d = this,\n-                    e = a.relatedTarget,\n-                    f = a.handleObj;\n-                return (!e || e !== d && !o.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c\n-            }\n-        }\n-    }), l.focusinBubbles || o.each({\n-        focus: \"focusin\",\n-        blur: \"focusout\"\n-    }, function(a, b) {\n-        var c = function(a) {\n-            o.event.simulate(b, a.target, o.event.fix(a), !0)\n-        };\n-        o.event.special[b] = {\n-            setup: function() {\n-                var d = this.ownerDocument || this,\n-                    e = L.access(d, b);\n-                e || d.addEventListener(a, c, !0), L.access(d, b, (e || 0) + 1)\n-            },\n-            teardown: function() {\n-                var d = this.ownerDocument || this,\n-                    e = L.access(d, b) - 1;\n-                e ? L.access(d, b, e) : (d.removeEventListener(a, c, !0), L.remove(d, b))\n-            }\n-        }\n-    }), o.fn.extend({\n-        on: function(a, b, c, d, e) {\n-            var f, g;\n-            if (\"object\" == typeof a) {\n-                \"string\" != typeof b && (c = c || b, b = void 0);\n-                for (g in a) this.on(g, b, c, a[g], e);\n-                return this\n-            }\n-            if (null == c && null == d ? (d = b, c = b = void 0) : null == d && (\"string\" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = $;\n-            else if (!d) return this;\n-            return 1 === e && (f = d, d = function(a) {\n-                return o().off(a), f.apply(this, arguments)\n-            }, d.guid = f.guid || (f.guid = o.guid++)), this.each(function() {\n-                o.event.add(this, a, d, c, b)\n-            })\n-        },\n-        one: function(a, b, c, d) {\n-            return this.on(a, b, c, d, 1)\n-        },\n-        off: function(a, b, c) {\n-            var d, e;\n-            if (a && a.preventDefault && a.handleObj) return d = a.handleObj, o(a.delegateTarget).off(d.namespace ? d.origType + \".\" + d.namespace : d.origType, d.selector, d.handler), this;\n-            if (\"object\" == typeof a) {\n-                for (e in a) this.off(e, b, a[e]);\n-                return this\n-            }\n-            return (b === !1 || \"function\" == typeof b) && (c = b, b = void 0), c === !1 && (c = $), this.each(function() {\n-                o.event.remove(this, a, c, b)\n-            })\n-        },\n-        trigger: function(a, b) {\n-            return this.each(function() {\n-                o.event.trigger(a, b, this)\n-            })\n-        },\n-        triggerHandler: function(a, b) {\n-            var c = this[0];\n-            return c ? o.event.trigger(a, b, c, !0) : void 0\n-        }\n-    });\n-    var ab = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n-        bb = /<([\\w:]+)/,\n-        cb = /<|&#?\\w+;/,\n-        db = /<(?:script|style|link)/i,\n-        eb = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n-        fb = /^$|\\/(?:java|ecma)script/i,\n-        gb = /^true\\/(.*)/,\n-        hb = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n-        ib = {\n-            option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n-            thead: [1, \"<table>\", \"</table>\"],\n-            col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n-            tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n-            td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n-            _default: [0, \"\", \"\"]\n-        };\n-    ib.optgroup = ib.option, ib.tbody = ib.tfoot = ib.colgroup = ib.caption = ib.thead, ib.th = ib.td;\n \n-    function jb(a, b) {\n-        return o.nodeName(a, \"table\") && o.nodeName(11 !== b.nodeType ? b : b.firstChild, \"tr\") ? a.getElementsByTagName(\"tbody\")[0] || a.appendChild(a.ownerDocument.createElement(\"tbody\")) : a\n-    }\n+function toType( obj ) {\n+\tif ( obj == null ) {\n+\t\treturn obj + \"\";\n+\t}\n \n-    function kb(a) {\n-        return a.type = (null !== a.getAttribute(\"type\")) + \"/\" + a.type, a\n-    }\n+\t// Support: Android <=2.3 only (functionish RegExp)\n+\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n+\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n+\t\ttypeof obj;\n+}\n+/* global Symbol */\n+// Defining this global in .eslintrc.json would create a danger of using the global\n+// unguarded in another place, it seems safer to define global only for this module\n \n-    function lb(a) {\n-        var b = gb.exec(a.type);\n-        return b ? a.type = b[1] : a.removeAttribute(\"type\"), a\n-    }\n \n-    function mb(a, b) {\n-        for (var c = 0, d = a.length; d > c; c++) L.set(a[c], \"globalEval\", !b || L.get(b[c], \"globalEval\"))\n-    }\n \n-    function nb(a, b) {\n-        var c, d, e, f, g, h, i, j;\n-        if (1 === b.nodeType) {\n-            if (L.hasData(a) && (f = L.access(a), g = L.set(b, f), j = f.events)) {\n-                delete g.handle, g.events = {};\n-                for (e in j)\n-                    for (c = 0, d = j[e].length; d > c; c++) o.event.add(b, e, j[e][c])\n-            }\n-            M.hasData(a) && (h = M.access(a), i = o.extend({}, h), M.set(b, i))\n-        }\n-    }\n+var\n+\tversion = \"3.6.3\",\n \n-    function ob(a, b) {\n-        var c = a.getElementsByTagName ? a.getElementsByTagName(b || \"*\") : a.querySelectorAll ? a.querySelectorAll(b || \"*\") : [];\n-        return void 0 === b || b && o.nodeName(a, b) ? o.merge([a], c) : c\n-    }\n+\t// Define a local copy of jQuery\n+\tjQuery = function( selector, context ) {\n \n-    function pb(a, b) {\n-        var c = b.nodeName.toLowerCase();\n-        \"input\" === c && T.test(a.type) ? b.checked = a.checked : (\"input\" === c || \"textarea\" === c) && (b.defaultValue = a.defaultValue)\n-    }\n-    o.extend({\n-        clone: function(a, b, c) {\n-            var d, e, f, g, h = a.cloneNode(!0),\n-                i = o.contains(a.ownerDocument, a);\n-            if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || o.isXMLDoc(a)))\n-                for (g = ob(h), f = ob(a), d = 0, e = f.length; e > d; d++) pb(f[d], g[d]);\n-            if (b)\n-                if (c)\n-                    for (f = f || ob(a), g = g || ob(h), d = 0, e = f.length; e > d; d++) nb(f[d], g[d]);\n-                else nb(a, h);\n-            return g = ob(h, \"script\"), g.length > 0 && mb(g, !i && ob(a, \"script\")), h\n-        },\n-        buildFragment: function(a, b, c, d) {\n-            for (var e, f, g, h, i, j, k = b.createDocumentFragment(), l = [], m = 0, n = a.length; n > m; m++)\n-                if (e = a[m], e || 0 === e)\n-                    if (\"object\" === o.type(e)) o.merge(l, e.nodeType ? [e] : e);\n-                    else if (cb.test(e)) {\n-                f = f || k.appendChild(b.createElement(\"div\")), g = (bb.exec(e) || [\"\", \"\"])[1].toLowerCase(), h = ib[g] || ib._default, f.innerHTML = h[1] + e.replace(ab, \"<$1></$2>\") + h[2], j = h[0];\n-                while (j--) f = f.lastChild;\n-                o.merge(l, f.childNodes), f = k.firstChild, f.textContent = \"\"\n-            } else l.push(b.createTextNode(e));\n-            k.textContent = \"\", m = 0;\n-            while (e = l[m++])\n-                if ((!d || -1 === o.inArray(e, d)) && (i = o.contains(e.ownerDocument, e), f = ob(k.appendChild(e), \"script\"), i && mb(f), c)) {\n-                    j = 0;\n-                    while (e = f[j++]) fb.test(e.type || \"\") && c.push(e)\n-                }\n-            return k\n-        },\n-        cleanData: function(a) {\n-            for (var b, c, d, e, f, g, h = o.event.special, i = 0; void 0 !== (c = a[i]); i++) {\n-                if (o.acceptData(c) && (f = c[L.expando], f && (b = L.cache[f]))) {\n-                    if (d = Object.keys(b.events || {}), d.length)\n-                        for (g = 0; void 0 !== (e = d[g]); g++) h[e] ? o.event.remove(c, e) : o.removeEvent(c, e, b.handle);\n-                    L.cache[f] && delete L.cache[f]\n-                }\n-                delete M.cache[c[M.expando]]\n-            }\n-        }\n-    }), o.fn.extend({\n-        text: function(a) {\n-            return J(this, function(a) {\n-                return void 0 === a ? o.text(this) : this.empty().each(function() {\n-                    (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = a)\n-                })\n-            }, null, a, arguments.length)\n-        },\n-        append: function() {\n-            return this.domManip(arguments, function(a) {\n-                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n-                    var b = jb(this, a);\n-                    b.appendChild(a)\n-                }\n-            })\n-        },\n-        prepend: function() {\n-            return this.domManip(arguments, function(a) {\n-                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n-                    var b = jb(this, a);\n-                    b.insertBefore(a, b.firstChild)\n-                }\n-            })\n-        },\n-        before: function() {\n-            return this.domManip(arguments, function(a) {\n-                this.parentNode && this.parentNode.insertBefore(a, this)\n-            })\n-        },\n-        after: function() {\n-            return this.domManip(arguments, function(a) {\n-                this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)\n-            })\n-        },\n-        remove: function(a, b) {\n-            for (var c, d = a ? o.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || o.cleanData(ob(c)), c.parentNode && (b && o.contains(c.ownerDocument, c) && mb(ob(c, \"script\")), c.parentNode.removeChild(c));\n-            return this\n-        },\n-        empty: function() {\n-            for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (o.cleanData(ob(a, !1)), a.textContent = \"\");\n-            return this\n-        },\n-        clone: function(a, b) {\n-            return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function() {\n-                return o.clone(this, a, b)\n-            })\n-        },\n-        html: function(a) {\n-            return J(this, function(a) {\n-                var b = this[0] || {},\n-                    c = 0,\n-                    d = this.length;\n-                if (void 0 === a && 1 === b.nodeType) return b.innerHTML;\n-                if (\"string\" == typeof a && !db.test(a) && !ib[(bb.exec(a) || [\"\", \"\"])[1].toLowerCase()]) {\n-                    a = a.replace(ab, \"<$1></$2>\");\n-                    try {\n-                        for (; d > c; c++) b = this[c] || {}, 1 === b.nodeType && (o.cleanData(ob(b, !1)), b.innerHTML = a);\n-                        b = 0\n-                    } catch (e) {}\n-                }\n-                b && this.empty().append(a)\n-            }, null, a, arguments.length)\n-        },\n-        replaceWith: function() {\n-            var a = arguments[0];\n-            return this.domManip(arguments, function(b) {\n-                a = this.parentNode, o.cleanData(ob(this)), a && a.replaceChild(b, this)\n-            }), a && (a.length || a.nodeType) ? this : this.remove()\n-        },\n-        detach: function(a) {\n-            return this.remove(a, !0)\n-        },\n-        domManip: function(a, b) {\n-            a = e.apply([], a);\n-            var c, d, f, g, h, i, j = 0,\n-                k = this.length,\n-                m = this,\n-                n = k - 1,\n-                p = a[0],\n-                q = o.isFunction(p);\n-            if (q || k > 1 && \"string\" == typeof p && !l.checkClone && eb.test(p)) return this.each(function(c) {\n-                var d = m.eq(c);\n-                q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b)\n-            });\n-            if (k && (c = o.buildFragment(a, this[0].ownerDocument, !1, this), d = c.firstChild, 1 === c.childNodes.length && (c = d), d)) {\n-                for (f = o.map(ob(c, \"script\"), kb), g = f.length; k > j; j++) h = c, j !== n && (h = o.clone(h, !0, !0), g && o.merge(f, ob(h, \"script\"))), b.call(this[j], h, j);\n-                if (g)\n-                    for (i = f[f.length - 1].ownerDocument, o.map(f, lb), j = 0; g > j; j++) h = f[j], fb.test(h.type || \"\") && !L.access(h, \"globalEval\") && o.contains(i, h) && (h.src ? o._evalUrl && o._evalUrl(h.src) : o.globalEval(h.textContent.replace(hb, \"\")))\n-            }\n-            return this\n-        }\n-    }), o.each({\n-        appendTo: \"append\",\n-        prependTo: \"prepend\",\n-        insertBefore: \"before\",\n-        insertAfter: \"after\",\n-        replaceAll: \"replaceWith\"\n-    }, function(a, b) {\n-        o.fn[a] = function(a) {\n-            for (var c, d = [], e = o(a), g = e.length - 1, h = 0; g >= h; h++) c = h === g ? this : this.clone(!0), o(e[h])[b](c), f.apply(d, c.get());\n-            return this.pushStack(d)\n-        }\n-    });\n-    var qb, rb = {};\n+\t\t// The jQuery object is actually just the init constructor 'enhanced'\n+\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n+\t\treturn new jQuery.fn.init( selector, context );\n+\t};\n \n-    function sb(b, c) {\n-        var d = o(c.createElement(b)).appendTo(c.body),\n-            e = a.getDefaultComputedStyle ? a.getDefaultComputedStyle(d[0]).display : o.css(d[0], \"display\");\n-        return d.detach(), e\n-    }\n+jQuery.fn = jQuery.prototype = {\n \n-    function tb(a) {\n-        var b = m,\n-            c = rb[a];\n-        return c || (c = sb(a, b), \"none\" !== c && c || (qb = (qb || o(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement), b = qb[0].contentDocument, b.write(), b.close(), c = sb(a, b), qb.detach()), rb[a] = c), c\n-    }\n-    var ub = /^margin/,\n-        vb = new RegExp(\"^(\" + Q + \")(?!px)[a-z%]+$\", \"i\"),\n-        wb = function(a) {\n-            return a.ownerDocument.defaultView.getComputedStyle(a, null)\n-        };\n+\t// The current version of jQuery being used\n+\tjquery: version,\n \n-    function xb(a, b, c) {\n-        var d, e, f, g, h = a.style;\n-        return c = c || wb(a), c && (g = c.getPropertyValue(b) || c[b]), c && (\"\" !== g || o.contains(a.ownerDocument, a) || (g = o.style(a, b)), vb.test(g) && ub.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + \"\" : g\n-    }\n+\tconstructor: jQuery,\n \n-    function yb(a, b) {\n-        return {\n-            get: function() {\n-                return a() ? void delete this.get : (this.get = b).apply(this, arguments)\n-            }\n-        }\n-    }! function() {\n-        var b, c, d = \"padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box\",\n-            e = m.documentElement,\n-            f = m.createElement(\"div\"),\n-            g = m.createElement(\"div\");\n-        g.style.backgroundClip = \"content-box\", g.cloneNode(!0).style.backgroundClip = \"\", l.clearCloneStyle = \"content-box\" === g.style.backgroundClip, f.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\", f.appendChild(g);\n+\t// The default length of a jQuery object is 0\n+\tlength: 0,\n \n-        function h() {\n-            g.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%\", e.appendChild(f);\n-            var d = a.getComputedStyle(g, null);\n-            b = \"1%\" !== d.top, c = \"4px\" === d.width, e.removeChild(f)\n-        }\n-        a.getComputedStyle && o.extend(l, {\n-            pixelPosition: function() {\n-                return h(), b\n-            },\n-            boxSizingReliable: function() {\n-                return null == c && h(), c\n-            },\n-            reliableMarginRight: function() {\n-                var b, c = g.appendChild(m.createElement(\"div\"));\n-                return c.style.cssText = g.style.cssText = d, c.style.marginRight = c.style.width = \"0\", g.style.width = \"1px\", e.appendChild(f), b = !parseFloat(a.getComputedStyle(c, null).marginRight), e.removeChild(f), g.innerHTML = \"\", b\n-            }\n-        })\n-    }(), o.swap = function(a, b, c, d) {\n-        var e, f, g = {};\n-        for (f in b) g[f] = a.style[f], a.style[f] = b[f];\n-        e = c.apply(a, d || []);\n-        for (f in b) a.style[f] = g[f];\n-        return e\n-    };\n-    var zb = /^(none|table(?!-c[ea]).+)/,\n-        Ab = new RegExp(\"^(\" + Q + \")(.*)$\", \"i\"),\n-        Bb = new RegExp(\"^([+-])=(\" + Q + \")\", \"i\"),\n-        Cb = {\n-            position: \"absolute\",\n-            visibility: \"hidden\",\n-            display: \"block\"\n-        },\n-        Db = {\n-            letterSpacing: 0,\n-            fontWeight: 400\n-        },\n-        Eb = [\"Webkit\", \"O\", \"Moz\", \"ms\"];\n+\ttoArray: function() {\n+\t\treturn slice.call( this );\n+\t},\n \n-    function Fb(a, b) {\n-        if (b in a) return b;\n-        var c = b[0].toUpperCase() + b.slice(1),\n-            d = b,\n-            e = Eb.length;\n-        while (e--)\n-            if (b = Eb[e] + c, b in a) return b;\n-        return d\n-    }\n+\t// Get the Nth element in the matched element set OR\n+\t// Get the whole matched element set as a clean array\n+\tget: function( num ) {\n \n-    function Gb(a, b, c) {\n-        var d = Ab.exec(b);\n-        return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || \"px\") : b\n-    }\n+\t\t// Return all the elements in a clean array\n+\t\tif ( num == null ) {\n+\t\t\treturn slice.call( this );\n+\t\t}\n \n-    function Hb(a, b, c, d, e) {\n-        for (var f = c === (d ? \"border\" : \"content\") ? 4 : \"width\" === b ? 1 : 0, g = 0; 4 > f; f += 2) \"margin\" === c && (g += o.css(a, c + R[f], !0, e)), d ? (\"content\" === c && (g -= o.css(a, \"padding\" + R[f], !0, e)), \"margin\" !== c && (g -= o.css(a, \"border\" + R[f] + \"Width\", !0, e))) : (g += o.css(a, \"padding\" + R[f], !0, e), \"padding\" !== c && (g += o.css(a, \"border\" + R[f] + \"Width\", !0, e)));\n-        return g\n-    }\n+\t\t// Return just the one element from the set\n+\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n+\t},\n \n-    function Ib(a, b, c) {\n-        var d = !0,\n-            e = \"width\" === b ? a.offsetWidth : a.offsetHeight,\n-            f = wb(a),\n-            g = \"border-box\" === o.css(a, \"boxSizing\", !1, f);\n-        if (0 >= e || null == e) {\n-            if (e = xb(a, b, f), (0 > e || null == e) && (e = a.style[b]), vb.test(e)) return e;\n-            d = g && (l.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0\n-        }\n-        return e + Hb(a, b, c || (g ? \"border\" : \"content\"), d, f) + \"px\"\n-    }\n+\t// Take an array of elements and push it onto the stack\n+\t// (returning the new matched element set)\n+\tpushStack: function( elems ) {\n \n-    function Jb(a, b) {\n-        for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = L.get(d, \"olddisplay\"), c = d.style.display, b ? (f[g] || \"none\" !== c || (d.style.display = \"\"), \"\" === d.style.display && S(d) && (f[g] = L.access(d, \"olddisplay\", tb(d.nodeName)))) : f[g] || (e = S(d), (c && \"none\" !== c || !e) && L.set(d, \"olddisplay\", e ? c : o.css(d, \"display\"))));\n-        for (g = 0; h > g; g++) d = a[g], d.style && (b && \"none\" !== d.style.display && \"\" !== d.style.display || (d.style.display = b ? f[g] || \"\" : \"none\"));\n-        return a\n-    }\n-    o.extend({\n-        cssHooks: {\n-            opacity: {\n-                get: function(a, b) {\n-                    if (b) {\n-                        var c = xb(a, \"opacity\");\n-                        return \"\" === c ? \"1\" : c\n-                    }\n-                }\n-            }\n-        },\n-        cssNumber: {\n-            columnCount: !0,\n-            fillOpacity: !0,\n-            fontWeight: !0,\n-            lineHeight: !0,\n-            opacity: !0,\n-            order: !0,\n-            orphans: !0,\n-            widows: !0,\n-            zIndex: !0,\n-            zoom: !0\n-        },\n-        cssProps: {\n-            \"float\": \"cssFloat\"\n-        },\n-        style: function(a, b, c, d) {\n-            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {\n-                var e, f, g, h = o.camelCase(b),\n-                    i = a.style;\n-                return b = o.cssProps[h] || (o.cssProps[h] = Fb(i, h)), g = o.cssHooks[b] || o.cssHooks[h], void 0 === c ? g && \"get\" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c, \"string\" === f && (e = Bb.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(o.css(a, b)), f = \"number\"), null != c && c === c && (\"number\" !== f || o.cssNumber[h] || (c += \"px\"), l.clearCloneStyle || \"\" !== c || 0 !== b.indexOf(\"background\") || (i[b] = \"inherit\"), g && \"set\" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = \"\", i[b] = c)), void 0)\n-            }\n-        },\n-        css: function(a, b, c, d) {\n-            var e, f, g, h = o.camelCase(b);\n-            return b = o.cssProps[h] || (o.cssProps[h] = Fb(a.style, h)), g = o.cssHooks[b] || o.cssHooks[h], g && \"get\" in g && (e = g.get(a, !0, c)), void 0 === e && (e = xb(a, b, d)), \"normal\" === e && b in Db && (e = Db[b]), \"\" === c || c ? (f = parseFloat(e), c === !0 || o.isNumeric(f) ? f || 0 : e) : e\n-        }\n-    }), o.each([\"height\", \"width\"], function(a, b) {\n-        o.cssHooks[b] = {\n-            get: function(a, c, d) {\n-                return c ? 0 === a.offsetWidth && zb.test(o.css(a, \"display\")) ? o.swap(a, Cb, function() {\n-                    return Ib(a, b, d)\n-                }) : Ib(a, b, d) : void 0\n-            },\n-            set: function(a, c, d) {\n-                var e = d && wb(a);\n-                return Gb(a, c, d ? Hb(a, b, d, \"border-box\" === o.css(a, \"boxSizing\", !1, e), e) : 0)\n-            }\n-        }\n-    }), o.cssHooks.marginRight = yb(l.reliableMarginRight, function(a, b) {\n-        return b ? o.swap(a, {\n-            display: \"inline-block\"\n-        }, xb, [a, \"marginRight\"]) : void 0\n-    }), o.each({\n-        margin: \"\",\n-        padding: \"\",\n-        border: \"Width\"\n-    }, function(a, b) {\n-        o.cssHooks[a + b] = {\n-            expand: function(c) {\n-                for (var d = 0, e = {}, f = \"string\" == typeof c ? c.split(\" \") : [c]; 4 > d; d++) e[a + R[d] + b] = f[d] || f[d - 2] || f[0];\n-                return e\n-            }\n-        }, ub.test(a) || (o.cssHooks[a + b].set = Gb)\n-    }), o.fn.extend({\n-        css: function(a, b) {\n-            return J(this, function(a, b, c) {\n-                var d, e, f = {},\n-                    g = 0;\n-                if (o.isArray(b)) {\n-                    for (d = wb(a), e = b.length; e > g; g++) f[b[g]] = o.css(a, b[g], !1, d);\n-                    return f\n-                }\n-                return void 0 !== c ? o.style(a, b, c) : o.css(a, b)\n-            }, a, b, arguments.length > 1)\n-        },\n-        show: function() {\n-            return Jb(this, !0)\n-        },\n-        hide: function() {\n-            return Jb(this)\n-        },\n-        toggle: function(a) {\n-            return \"boolean\" == typeof a ? a ? this.show() : this.hide() : this.each(function() {\n-                S(this) ? o(this).show() : o(this).hide()\n-            })\n-        }\n-    });\n+\t\t// Build a new jQuery matched element set\n+\t\tvar ret = jQuery.merge( this.constructor(), elems );\n \n-    function Kb(a, b, c, d, e) {\n-        return new Kb.prototype.init(a, b, c, d, e)\n-    }\n-    o.Tween = Kb, Kb.prototype = {\n-        constructor: Kb,\n-        init: function(a, b, c, d, e, f) {\n-            this.elem = a, this.prop = c, this.easing = e || \"swing\", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (o.cssNumber[c] ? \"\" : \"px\")\n-        },\n-        cur: function() {\n-            var a = Kb.propHooks[this.prop];\n-            return a && a.get ? a.get(this) : Kb.propHooks._default.get(this)\n-        },\n-        run: function(a) {\n-            var b, c = Kb.propHooks[this.prop];\n-            return this.pos = b = this.options.duration ? o.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Kb.propHooks._default.set(this), this\n-        }\n-    }, Kb.prototype.init.prototype = Kb.prototype, Kb.propHooks = {\n-        _default: {\n-            get: function(a) {\n-                var b;\n-                return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = o.css(a.elem, a.prop, \"\"), b && \"auto\" !== b ? b : 0) : a.elem[a.prop]\n-            },\n-            set: function(a) {\n-                o.fx.step[a.prop] ? o.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[o.cssProps[a.prop]] || o.cssHooks[a.prop]) ? o.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now\n-            }\n-        }\n-    }, Kb.propHooks.scrollTop = Kb.propHooks.scrollLeft = {\n-        set: function(a) {\n-            a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)\n-        }\n-    }, o.easing = {\n-        linear: function(a) {\n-            return a\n-        },\n-        swing: function(a) {\n-            return .5 - Math.cos(a * Math.PI) / 2\n-        }\n-    }, o.fx = Kb.prototype.init, o.fx.step = {};\n-    var Lb, Mb, Nb = /^(?:toggle|show|hide)$/,\n-        Ob = new RegExp(\"^(?:([+-])=|)(\" + Q + \")([a-z%]*)$\", \"i\"),\n-        Pb = /queueHooks$/,\n-        Qb = [Vb],\n-        Rb = {\n-            \"*\": [function(a, b) {\n-                var c = this.createTween(a, b),\n-                    d = c.cur(),\n-                    e = Ob.exec(b),\n-                    f = e && e[3] || (o.cssNumber[a] ? \"\" : \"px\"),\n-                    g = (o.cssNumber[a] || \"px\" !== f && +d) && Ob.exec(o.css(c.elem, a)),\n-                    h = 1,\n-                    i = 20;\n-                if (g && g[3] !== f) {\n-                    f = f || g[3], e = e || [], g = +d || 1;\n-                    do h = h || \".5\", g /= h, o.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) && 1 !== h && --i)\n-                }\n-                return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c\n-            }]\n-        };\n+\t\t// Add the old object onto the stack (as a reference)\n+\t\tret.prevObject = this;\n \n-    function Sb() {\n-        return setTimeout(function() {\n-            Lb = void 0\n-        }), Lb = o.now()\n-    }\n+\t\t// Return the newly-formed element set\n+\t\treturn ret;\n+\t},\n \n-    function Tb(a, b) {\n-        var c, d = 0,\n-            e = {\n-                height: a\n-            };\n-        for (b = b ? 1 : 0; 4 > d; d += 2 - b) c = R[d], e[\"margin\" + c] = e[\"padding\" + c] = a;\n-        return b && (e.opacity = e.width = a), e\n-    }\n+\t// Execute a callback for every element in the matched set.\n+\teach: function( callback ) {\n+\t\treturn jQuery.each( this, callback );\n+\t},\n \n-    function Ub(a, b, c) {\n-        for (var d, e = (Rb[b] || []).concat(Rb[\"*\"]), f = 0, g = e.length; g > f; f++)\n-            if (d = e[f].call(c, b, a)) return d\n-    }\n+\tmap: function( callback ) {\n+\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n+\t\t\treturn callback.call( elem, i, elem );\n+\t\t} ) );\n+\t},\n \n-    function Vb(a, b, c) {\n-        var d, e, f, g, h, i, j, k = this,\n-            l = {},\n-            m = a.style,\n-            n = a.nodeType && S(a),\n-            p = L.get(a, \"fxshow\");\n-        c.queue || (h = o._queueHooks(a, \"fx\"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function() {\n-            h.unqueued || i()\n-        }), h.unqueued++, k.always(function() {\n-            k.always(function() {\n-                h.unqueued--, o.queue(a, \"fx\").length || h.empty.fire()\n-            })\n-        })), 1 === a.nodeType && (\"height\" in b || \"width\" in b) && (c.overflow = [m.overflow, m.overflowX, m.overflowY], j = o.css(a, \"display\"), \"none\" === j && (j = tb(a.nodeName)), \"inline\" === j && \"none\" === o.css(a, \"float\") && (m.display = \"inline-block\")), c.overflow && (m.overflow = \"hidden\", k.always(function() {\n-            m.overflow = c.overflow[0], m.overflowX = c.overflow[1], m.overflowY = c.overflow[2]\n-        }));\n-        for (d in b)\n-            if (e = b[d], Nb.exec(e)) {\n-                if (delete b[d], f = f || \"toggle\" === e, e === (n ? \"hide\" : \"show\")) {\n-                    if (\"show\" !== e || !p || void 0 === p[d]) continue;\n-                    n = !0\n-                }\n-                l[d] = p && p[d] || o.style(a, d)\n-            }\n-        if (!o.isEmptyObject(l)) {\n-            p ? \"hidden\" in p && (n = p.hidden) : p = L.access(a, \"fxshow\", {}), f && (p.hidden = !n), n ? o(a).show() : k.done(function() {\n-                o(a).hide()\n-            }), k.done(function() {\n-                var b;\n-                L.remove(a, \"fxshow\");\n-                for (b in l) o.style(a, b, l[b])\n-            });\n-            for (d in l) g = Ub(n ? p[d] : 0, d, k), d in p || (p[d] = g.start, n && (g.end = g.start, g.start = \"width\" === d || \"height\" === d ? 1 : 0))\n-        }\n-    }\n+\tslice: function() {\n+\t\treturn this.pushStack( slice.apply( this, arguments ) );\n+\t},\n \n-    function Wb(a, b) {\n-        var c, d, e, f, g;\n-        for (c in a)\n-            if (d = o.camelCase(c), e = b[d], f = a[c], o.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = o.cssHooks[d], g && \"expand\" in g) {\n-                f = g.expand(f), delete a[d];\n-                for (c in f) c in a || (a[c] = f[c], b[c] = e)\n-            } else b[d] = e\n-    }\n+\tfirst: function() {\n+\t\treturn this.eq( 0 );\n+\t},\n \n-    function Xb(a, b, c) {\n-        var d, e, f = 0,\n-            g = Qb.length,\n-            h = o.Deferred().always(function() {\n-                delete i.elem\n-            }),\n-            i = function() {\n-                if (e) return !1;\n-                for (var b = Lb || Sb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);\n-                return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1)\n-            },\n-            j = h.promise({\n-                elem: a,\n-                props: o.extend({}, b),\n-                opts: o.extend(!0, {\n-                    specialEasing: {}\n-                }, c),\n-                originalProperties: b,\n-                originalOptions: c,\n-                startTime: Lb || Sb(),\n-                duration: c.duration,\n-                tweens: [],\n-                createTween: function(b, c) {\n-                    var d = o.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);\n-                    return j.tweens.push(d), d\n-                },\n-                stop: function(b) {\n-                    var c = 0,\n-                        d = b ? j.tweens.length : 0;\n-                    if (e) return this;\n-                    for (e = !0; d > c; c++) j.tweens[c].run(1);\n-                    return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this\n-                }\n-            }),\n-            k = j.props;\n-        for (Wb(k, j.opts.specialEasing); g > f; f++)\n-            if (d = Qb[f].call(j, a, k, j.opts)) return d;\n-        return o.map(k, Ub, j), o.isFunction(j.opts.start) && j.opts.start.call(a, j), o.fx.timer(o.extend(i, {\n-            elem: a,\n-            anim: j,\n-            queue: j.opts.queue\n-        })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)\n-    }\n-    o.Animation = o.extend(Xb, {\n-            tweener: function(a, b) {\n-                o.isFunction(a) ? (b = a, a = [\"*\"]) : a = a.split(\" \");\n-                for (var c, d = 0, e = a.length; e > d; d++) c = a[d], Rb[c] = Rb[c] || [], Rb[c].unshift(b)\n-            },\n-            prefilter: function(a, b) {\n-                b ? Qb.unshift(a) : Qb.push(a)\n-            }\n-        }), o.speed = function(a, b, c) {\n-            var d = a && \"object\" == typeof a ? o.extend({}, a) : {\n-                complete: c || !c && b || o.isFunction(a) && a,\n-                duration: a,\n-                easing: c && b || b && !o.isFunction(b) && b\n-            };\n-            return d.duration = o.fx.off ? 0 : \"number\" == typeof d.duration ? d.duration : d.duration in o.fx.speeds ? o.fx.speeds[d.duration] : o.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = \"fx\"), d.old = d.complete, d.complete = function() {\n-                o.isFunction(d.old) && d.old.call(this), d.queue && o.dequeue(this, d.queue)\n-            }, d\n-        }, o.fn.extend({\n-            fadeTo: function(a, b, c, d) {\n-                return this.filter(S).css(\"opacity\", 0).show().end().animate({\n-                    opacity: b\n-                }, a, c, d)\n-            },\n-            animate: function(a, b, c, d) {\n-                var e = o.isEmptyObject(a),\n-                    f = o.speed(b, c, d),\n-                    g = function() {\n-                        var b = Xb(this, o.extend({}, a), f);\n-                        (e || L.get(this, \"finish\")) && b.stop(!0)\n-                    };\n-                return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)\n-            },\n-            stop: function(a, b, c) {\n-                var d = function(a) {\n-                    var b = a.stop;\n-                    delete a.stop, b(c)\n-                };\n-                return \"string\" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || \"fx\", []), this.each(function() {\n-                    var b = !0,\n-                        e = null != a && a + \"queueHooks\",\n-                        f = o.timers,\n-                        g = L.get(this);\n-                    if (e) g[e] && g[e].stop && d(g[e]);\n-                    else\n-                        for (e in g) g[e] && g[e].stop && Pb.test(e) && d(g[e]);\n-                    for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));\n-                    (b || !c) && o.dequeue(this, a)\n-                })\n-            },\n-            finish: function(a) {\n-                return a !== !1 && (a = a || \"fx\"), this.each(function() {\n-                    var b, c = L.get(this),\n-                        d = c[a + \"queue\"],\n-                        e = c[a + \"queueHooks\"],\n-                        f = o.timers,\n-                        g = d ? d.length : 0;\n-                    for (c.finish = !0, o.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));\n-                    for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);\n-                    delete c.finish\n-                })\n-            }\n-        }), o.each([\"toggle\", \"show\", \"hide\"], function(a, b) {\n-            var c = o.fn[b];\n-            o.fn[b] = function(a, d, e) {\n-                return null == a || \"boolean\" == typeof a ? c.apply(this, arguments) : this.animate(Tb(b, !0), a, d, e)\n-            }\n-        }), o.each({\n-            slideDown: Tb(\"show\"),\n-            slideUp: Tb(\"hide\"),\n-            slideToggle: Tb(\"toggle\"),\n-            fadeIn: {\n-                opacity: \"show\"\n-            },\n-            fadeOut: {\n-                opacity: \"hide\"\n-            },\n-            fadeToggle: {\n-                opacity: \"toggle\"\n-            }\n-        }, function(a, b) {\n-            o.fn[a] = function(a, c, d) {\n-                return this.animate(b, a, c, d)\n-            }\n-        }), o.timers = [], o.fx.tick = function() {\n-            var a, b = 0,\n-                c = o.timers;\n-            for (Lb = o.now(); b < c.length; b++) a = c[b], a() || c[b] !== a || c.splice(b--, 1);\n-            c.length || o.fx.stop(), Lb = void 0\n-        }, o.fx.timer = function(a) {\n-            o.timers.push(a), a() ? o.fx.start() : o.timers.pop()\n-        }, o.fx.interval = 13, o.fx.start = function() {\n-            Mb || (Mb = setInterval(o.fx.tick, o.fx.interval))\n-        }, o.fx.stop = function() {\n-            clearInterval(Mb), Mb = null\n-        }, o.fx.speeds = {\n-            slow: 600,\n-            fast: 200,\n-            _default: 400\n-        }, o.fn.delay = function(a, b) {\n-            return a = o.fx ? o.fx.speeds[a] || a : a, b = b || \"fx\", this.queue(b, function(b, c) {\n-                var d = setTimeout(b, a);\n-                c.stop = function() {\n-                    clearTimeout(d)\n-                }\n-            })\n-        },\n-        function() {\n-            var a = m.createElement(\"input\"),\n-                b = m.createElement(\"select\"),\n-                c = b.appendChild(m.createElement(\"option\"));\n-            a.type = \"checkbox\", l.checkOn = \"\" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = m.createElement(\"input\"), a.value = \"t\", a.type = \"radio\", l.radioValue = \"t\" === a.value\n-        }();\n-    var Yb, Zb, $b = o.expr.attrHandle;\n-    o.fn.extend({\n-        attr: function(a, b) {\n-            return J(this, o.attr, a, b, arguments.length > 1)\n-        },\n-        removeAttr: function(a) {\n-            return this.each(function() {\n-                o.removeAttr(this, a)\n-            })\n-        }\n-    }), o.extend({\n-        attr: function(a, b, c) {\n-            var d, e, f = a.nodeType;\n-            if (a && 3 !== f && 8 !== f && 2 !== f) return typeof a.getAttribute === U ? o.prop(a, b, c) : (1 === f && o.isXMLDoc(a) || (b = b.toLowerCase(), d = o.attrHooks[b] || (o.expr.match.bool.test(b) ? Zb : Yb)), void 0 === c ? d && \"get\" in d && null !== (e = d.get(a, b)) ? e : (e = o.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d && \"set\" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + \"\"), c) : void o.removeAttr(a, b))\n-        },\n-        removeAttr: function(a, b) {\n-            var c, d, e = 0,\n-                f = b && b.match(E);\n-            if (f && 1 === a.nodeType)\n-                while (c = f[e++]) d = o.propFix[c] || c, o.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c)\n-        },\n-        attrHooks: {\n-            type: {\n-                set: function(a, b) {\n-                    if (!l.radioValue && \"radio\" === b && o.nodeName(a, \"input\")) {\n-                        var c = a.value;\n-                        return a.setAttribute(\"type\", b), c && (a.value = c), b\n-                    }\n-                }\n-            }\n-        }\n-    }), Zb = {\n-        set: function(a, b, c) {\n-            return b === !1 ? o.removeAttr(a, c) : a.setAttribute(c, c), c\n-        }\n-    }, o.each(o.expr.match.bool.source.match(/\\w+/g), function(a, b) {\n-        var c = $b[b] || o.find.attr;\n-        $b[b] = function(a, b, d) {\n-            var e, f;\n-            return d || (f = $b[b], $b[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, $b[b] = f), e\n-        }\n-    });\n-    var _b = /^(?:input|select|textarea|button)$/i;\n-    o.fn.extend({\n-        prop: function(a, b) {\n-            return J(this, o.prop, a, b, arguments.length > 1)\n-        },\n-        removeProp: function(a) {\n-            return this.each(function() {\n-                delete this[o.propFix[a] || a]\n-            })\n-        }\n-    }), o.extend({\n-        propFix: {\n-            \"for\": \"htmlFor\",\n-            \"class\": \"className\"\n-        },\n-        prop: function(a, b, c) {\n-            var d, e, f, g = a.nodeType;\n-            if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !o.isXMLDoc(a), f && (b = o.propFix[b] || b, e = o.propHooks[b]), void 0 !== c ? e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : a[b]\n-        },\n-        propHooks: {\n-            tabIndex: {\n-                get: function(a) {\n-                    return a.hasAttribute(\"tabindex\") || _b.test(a.nodeName) || a.href ? a.tabIndex : -1\n-                }\n-            }\n-        }\n-    }), l.optSelected || (o.propHooks.selected = {\n-        get: function(a) {\n-            var b = a.parentNode;\n-            return b && b.parentNode && b.parentNode.selectedIndex, null\n-        }\n-    }), o.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function() {\n-        o.propFix[this.toLowerCase()] = this\n-    });\n-    var ac = /[\\t\\r\\n\\f]/g;\n-    o.fn.extend({\n-        addClass: function(a) {\n-            var b, c, d, e, f, g, h = \"string\" == typeof a && a,\n-                i = 0,\n-                j = this.length;\n-            if (o.isFunction(a)) return this.each(function(b) {\n-                o(this).addClass(a.call(this, b, this.className))\n-            });\n-            if (h)\n-                for (b = (a || \"\").match(E) || []; j > i; i++)\n-                    if (c = this[i], d = 1 === c.nodeType && (c.className ? (\" \" + c.className + \" \").replace(ac, \" \") : \" \")) {\n-                        f = 0;\n-                        while (e = b[f++]) d.indexOf(\" \" + e + \" \") < 0 && (d += e + \" \");\n-                        g = o.trim(d), c.className !== g && (c.className = g)\n-                    }\n-            return this\n-        },\n-        removeClass: function(a) {\n-            var b, c, d, e, f, g, h = 0 === arguments.length || \"string\" == typeof a && a,\n-                i = 0,\n-                j = this.length;\n-            if (o.isFunction(a)) return this.each(function(b) {\n-                o(this).removeClass(a.call(this, b, this.className))\n-            });\n-            if (h)\n-                for (b = (a || \"\").match(E) || []; j > i; i++)\n-                    if (c = this[i], d = 1 === c.nodeType && (c.className ? (\" \" + c.className + \" \").replace(ac, \" \") : \"\")) {\n-                        f = 0;\n-                        while (e = b[f++])\n-                            while (d.indexOf(\" \" + e + \" \") >= 0) d = d.replace(\" \" + e + \" \", \" \");\n-                        g = a ? o.trim(d) : \"\", c.className !== g && (c.className = g)\n-                    }\n-            return this\n-        },\n-        toggleClass: function(a, b) {\n-            var c = typeof a;\n-            return \"boolean\" == typeof b && \"string\" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(o.isFunction(a) ? function(c) {\n-                o(this).toggleClass(a.call(this, c, this.className, b), b)\n-            } : function() {\n-                if (\"string\" === c) {\n-                    var b, d = 0,\n-                        e = o(this),\n-                        f = a.match(E) || [];\n-                    while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b)\n-                } else(c === U || \"boolean\" === c) && (this.className && L.set(this, \"__className__\", this.className), this.className = this.className || a === !1 ? \"\" : L.get(this, \"__className__\") || \"\")\n-            })\n-        },\n-        hasClass: function(a) {\n-            for (var b = \" \" + a + \" \", c = 0, d = this.length; d > c; c++)\n-                if (1 === this[c].nodeType && (\" \" + this[c].className + \" \").replace(ac, \" \").indexOf(b) >= 0) return !0;\n-            return !1\n-        }\n-    });\n-    var bc = /\\r/g;\n-    o.fn.extend({\n-        val: function(a) {\n-            var b, c, d, e = this[0]; {\n-                if (arguments.length) return d = o.isFunction(a), this.each(function(c) {\n-                    var e;\n-                    1 === this.nodeType && (e = d ? a.call(this, c, o(this).val()) : a, null == e ? e = \"\" : \"number\" == typeof e ? e += \"\" : o.isArray(e) && (e = o.map(e, function(a) {\n-                        return null == a ? \"\" : a + \"\"\n-                    })), b = o.valHooks[this.type] || o.valHooks[this.nodeName.toLowerCase()], b && \"set\" in b && void 0 !== b.set(this, e, \"value\") || (this.value = e))\n-                });\n-                if (e) return b = o.valHooks[e.type] || o.valHooks[e.nodeName.toLowerCase()], b && \"get\" in b && void 0 !== (c = b.get(e, \"value\")) ? c : (c = e.value, \"string\" == typeof c ? c.replace(bc, \"\") : null == c ? \"\" : c)\n-            }\n-        }\n-    }), o.extend({\n-        valHooks: {\n-            select: {\n-                get: function(a) {\n-                    for (var b, c, d = a.options, e = a.selectedIndex, f = \"select-one\" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)\n-                        if (c = d[i], !(!c.selected && i !== e || (l.optDisabled ? c.disabled : null !== c.getAttribute(\"disabled\")) || c.parentNode.disabled && o.nodeName(c.parentNode, \"optgroup\"))) {\n-                            if (b = o(c).val(), f) return b;\n-                            g.push(b)\n-                        }\n-                    return g\n-                },\n-                set: function(a, b) {\n-                    var c, d, e = a.options,\n-                        f = o.makeArray(b),\n-                        g = e.length;\n-                    while (g--) d = e[g], (d.selected = o.inArray(o(d).val(), f) >= 0) && (c = !0);\n-                    return c || (a.selectedIndex = -1), f\n-                }\n-            }\n-        }\n-    }), o.each([\"radio\", \"checkbox\"], function() {\n-        o.valHooks[this] = {\n-            set: function(a, b) {\n-                return o.isArray(b) ? a.checked = o.inArray(o(a).val(), b) >= 0 : void 0\n-            }\n-        }, l.checkOn || (o.valHooks[this].get = function(a) {\n-            return null === a.getAttribute(\"value\") ? \"on\" : a.value\n-        })\n-    }), o.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function(a, b) {\n-        o.fn[b] = function(a, c) {\n-            return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)\n-        }\n-    }), o.fn.extend({\n-        hover: function(a, b) {\n-            return this.mouseenter(a).mouseleave(b || a)\n-        },\n-        bind: function(a, b, c) {\n-            return this.on(a, null, b, c)\n-        },\n-        unbind: function(a, b) {\n-            return this.off(a, null, b)\n-        },\n-        delegate: function(a, b, c, d) {\n-            return this.on(b, a, c, d)\n-        },\n-        undelegate: function(a, b, c) {\n-            return 1 === arguments.length ? this.off(a, \"**\") : this.off(b, a || \"**\", c)\n-        }\n-    });\n-    var cc = o.now(),\n-        dc = /\\?/;\n-    o.parseJSON = function(a) {\n-        return JSON.parse(a + \"\")\n-    }, o.parseXML = function(a) {\n-        var b, c;\n-        if (!a || \"string\" != typeof a) return null;\n-        try {\n-            c = new DOMParser, b = c.parseFromString(a, \"text/xml\")\n-        } catch (d) {\n-            b = void 0\n-        }\n-        return (!b || b.getElementsByTagName(\"parsererror\").length) && o.error(\"Invalid XML: \" + a), b\n-    };\n-    var ec, fc, gc = /#.*$/,\n-        hc = /([?&])_=[^&]*/,\n-        ic = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n-        jc = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n-        kc = /^(?:GET|HEAD)$/,\n-        lc = /^\\/\\//,\n-        mc = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n-        nc = {},\n-        oc = {},\n-        pc = \"*/\".concat(\"*\");\n-    try {\n-        fc = location.href\n-    } catch (qc) {\n-        fc = m.createElement(\"a\"), fc.href = \"\", fc = fc.href\n-    }\n-    ec = mc.exec(fc.toLowerCase()) || [];\n+\tlast: function() {\n+\t\treturn this.eq( -1 );\n+\t},\n \n-    function rc(a) {\n-        return function(b, c) {\n-            \"string\" != typeof b && (c = b, b = \"*\");\n-            var d, e = 0,\n-                f = b.toLowerCase().match(E) || [];\n-            if (o.isFunction(c))\n-                while (d = f[e++]) \"+\" === d[0] ? (d = d.slice(1) || \"*\", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)\n-        }\n-    }\n+\teven: function() {\n+\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n+\t\t\treturn ( i + 1 ) % 2;\n+\t\t} ) );\n+\t},\n \n-    function sc(a, b, c, d) {\n-        var e = {},\n-            f = a === oc;\n+\todd: function() {\n+\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n+\t\t\treturn i % 2;\n+\t\t} ) );\n+\t},\n \n-        function g(h) {\n-            var i;\n-            return e[h] = !0, o.each(a[h] || [], function(a, h) {\n-                var j = h(b, c, d);\n-                return \"string\" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)\n-            }), i\n-        }\n-        return g(b.dataTypes[0]) || !e[\"*\"] && g(\"*\")\n-    }\n+\teq: function( i ) {\n+\t\tvar len = this.length,\n+\t\t\tj = +i + ( i < 0 ? len : 0 );\n+\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n+\t},\n \n-    function tc(a, b) {\n-        var c, d, e = o.ajaxSettings.flatOptions || {};\n-        for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);\n-        return d && o.extend(!0, a, d), a\n-    }\n+\tend: function() {\n+\t\treturn this.prevObject || this.constructor();\n+\t},\n \n-    function uc(a, b, c) {\n-        var d, e, f, g, h = a.contents,\n-            i = a.dataTypes;\n-        while (\"*\" === i[0]) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader(\"Content-Type\"));\n-        if (d)\n-            for (e in h)\n-                if (h[e] && h[e].test(d)) {\n-                    i.unshift(e);\n-                    break\n-                }\n-        if (i[0] in c) f = i[0];\n-        else {\n-            for (e in c) {\n-                if (!i[0] || a.converters[e + \" \" + i[0]]) {\n-                    f = e;\n-                    break\n-                }\n-                g || (g = e)\n-            }\n-            f = f || g\n-        }\n-        return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0\n-    }\n+\t// For internal use only.\n+\t// Behaves like an Array's method, not like a jQuery method.\n+\tpush: push,\n+\tsort: arr.sort,\n+\tsplice: arr.splice\n+};\n \n-    function vc(a, b, c, d) {\n-        var e, f, g, h, i, j = {},\n-            k = a.dataTypes.slice();\n-        if (k[1])\n-            for (g in a.converters) j[g.toLowerCase()] = a.converters[g];\n-        f = k.shift();\n-        while (f)\n-            if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())\n-                if (\"*\" === f) f = i;\n-                else if (\"*\" !== i && i !== f) {\n-            if (g = j[i + \" \" + f] || j[\"* \" + f], !g)\n-                for (e in j)\n-                    if (h = e.split(\" \"), h[1] === f && (g = j[i + \" \" + h[0]] || j[\"* \" + h[0]])) {\n-                        g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));\n-                        break\n-                    }\n-            if (g !== !0)\n-                if (g && a[\"throws\"]) b = g(b);\n-                else try {\n-                    b = g(b)\n-                } catch (l) {\n-                    return {\n-                        state: \"parsererror\",\n-                        error: g ? l : \"No conversion from \" + i + \" to \" + f\n-                    }\n-                }\n-        }\n-        return {\n-            state: \"success\",\n-            data: b\n-        }\n-    }\n-    o.extend({\n-        active: 0,\n-        lastModified: {},\n-        etag: {},\n-        ajaxSettings: {\n-            url: fc,\n-            type: \"GET\",\n-            isLocal: jc.test(ec[1]),\n-            global: !0,\n-            processData: !0,\n-            async: !0,\n-            contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n-            accepts: {\n-                \"*\": pc,\n-                text: \"text/plain\",\n-                html: \"text/html\",\n-                xml: \"application/xml, text/xml\",\n-                json: \"application/json, text/javascript\"\n-            },\n-            contents: {\n-                xml: /xml/,\n-                html: /html/,\n-                json: /json/\n-            },\n-            responseFields: {\n-                xml: \"responseXML\",\n-                text: \"responseText\",\n-                json: \"responseJSON\"\n-            },\n-            converters: {\n-                \"* text\": String,\n-                \"text html\": !0,\n-                \"text json\": o.parseJSON,\n-                \"text xml\": o.parseXML\n-            },\n-            flatOptions: {\n-                url: !0,\n-                context: !0\n-            }\n-        },\n-        ajaxSetup: function(a, b) {\n-            return b ? tc(tc(a, o.ajaxSettings), b) : tc(o.ajaxSettings, a)\n-        },\n-        ajaxPrefilter: rc(nc),\n-        ajaxTransport: rc(oc),\n-        ajax: function(a, b) {\n-            \"object\" == typeof a && (b = a, a = void 0), b = b || {};\n-            var c, d, e, f, g, h, i, j, k = o.ajaxSetup({}, b),\n-                l = k.context || k,\n-                m = k.context && (l.nodeType || l.jquery) ? o(l) : o.event,\n-                n = o.Deferred(),\n-                p = o.Callbacks(\"once memory\"),\n-                q = k.statusCode || {},\n-                r = {},\n-                s = {},\n-                t = 0,\n-                u = \"canceled\",\n-                v = {\n-                    readyState: 0,\n-                    getResponseHeader: function(a) {\n-                        var b;\n-                        if (2 === t) {\n-                            if (!f) {\n-                                f = {};\n-                                while (b = ic.exec(e)) f[b[1].toLowerCase()] = b[2]\n-                            }\n-                            b = f[a.toLowerCase()]\n-                        }\n-                        return null == b ? null : b\n-                    },\n-                    getAllResponseHeaders: function() {\n-                        return 2 === t ? e : null\n-                    },\n-                    setRequestHeader: function(a, b) {\n-                        var c = a.toLowerCase();\n-                        return t || (a = s[c] = s[c] || a, r[a] = b), this\n-                    },\n-                    overrideMimeType: function(a) {\n-                        return t || (k.mimeType = a), this\n-                    },\n-                    statusCode: function(a) {\n-                        var b;\n-                        if (a)\n-                            if (2 > t)\n-                                for (b in a) q[b] = [q[b], a[b]];\n-                            else v.always(a[v.status]);\n-                        return this\n-                    },\n-                    abort: function(a) {\n-                        var b = a || u;\n-                        return c && c.abort(b), x(0, b), this\n-                    }\n-                };\n-            if (n.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || fc) + \"\").replace(gc, \"\").replace(lc, ec[1] + \"//\"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = o.trim(k.dataType || \"*\").toLowerCase().match(E) || [\"\"], null == k.crossDomain && (h = mc.exec(k.url.toLowerCase()), k.crossDomain = !(!h || h[1] === ec[1] && h[2] === ec[2] && (h[3] || (\"http:\" === h[1] ? \"80\" : \"443\")) === (ec[3] || (\"http:\" === ec[1] ? \"80\" : \"443\")))), k.data && k.processData && \"string\" != typeof k.data && (k.data = o.param(k.data, k.traditional)), sc(nc, k, b, v), 2 === t) return v;\n-            i = k.global, i && 0 === o.active++ && o.event.trigger(\"ajaxStart\"), k.type = k.type.toUpperCase(), k.hasContent = !kc.test(k.type), d = k.url, k.hasContent || (k.data && (d = k.url += (dc.test(d) ? \"&\" : \"?\") + k.data, delete k.data), k.cache === !1 && (k.url = hc.test(d) ? d.replace(hc, \"$1_=\" + cc++) : d + (dc.test(d) ? \"&\" : \"?\") + \"_=\" + cc++)), k.ifModified && (o.lastModified[d] && v.setRequestHeader(\"If-Modified-Since\", o.lastModified[d]), o.etag[d] && v.setRequestHeader(\"If-None-Match\", o.etag[d])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader(\"Content-Type\", k.contentType), v.setRequestHeader(\"Accept\", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + (\"*\" !== k.dataTypes[0] ? \", \" + pc + \"; q=0.01\" : \"\") : k.accepts[\"*\"]);\n-            for (j in k.headers) v.setRequestHeader(j, k.headers[j]);\n-            if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();\n-            u = \"abort\";\n-            for (j in {\n-                    success: 1,\n-                    error: 1,\n-                    complete: 1\n-                }) v[j](k[j]);\n-            if (c = sc(oc, k, b, v)) {\n-                v.readyState = 1, i && m.trigger(\"ajaxSend\", [v, k]), k.async && k.timeout > 0 && (g = setTimeout(function() {\n-                    v.abort(\"timeout\")\n-                }, k.timeout));\n-                try {\n-                    t = 1, c.send(r, x)\n-                } catch (w) {\n-                    if (!(2 > t)) throw w;\n-                    x(-1, w)\n-                }\n-            } else x(-1, \"No Transport\");\n+jQuery.extend = jQuery.fn.extend = function() {\n+\tvar options, name, src, copy, copyIsArray, clone,\n+\t\ttarget = arguments[ 0 ] || {},\n+\t\ti = 1,\n+\t\tlength = arguments.length,\n+\t\tdeep = false;\n \n-            function x(a, b, f, h) {\n-                var j, r, s, u, w, x = b;\n-                2 !== t && (t = 2, g && clearTimeout(g), c = void 0, e = h || \"\", v.readyState = a > 0 ? 4 : 0, j = a >= 200 && 300 > a || 304 === a, f && (u = uc(k, v, f)), u = vc(k, u, v, j), j ? (k.ifModified && (w = v.getResponseHeader(\"Last-Modified\"), w && (o.lastModified[d] = w), w = v.getResponseHeader(\"etag\"), w && (o.etag[d] = w)), 204 === a || \"HEAD\" === k.type ? x = \"nocontent\" : 304 === a ? x = \"notmodified\" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = \"error\", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + \"\", j ? n.resolveWith(l, [r, x, v]) : n.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, i && m.trigger(j ? \"ajaxSuccess\" : \"ajaxError\", [v, k, j ? r : s]), p.fireWith(l, [v, x]), i && (m.trigger(\"ajaxComplete\", [v, k]), --o.active || o.event.trigger(\"ajaxStop\")))\n-            }\n-            return v\n-        },\n-        getJSON: function(a, b, c) {\n-            return o.get(a, b, c, \"json\")\n-        },\n-        getScript: function(a, b) {\n-            return o.get(a, void 0, b, \"script\")\n-        }\n-    }), o.each([\"get\", \"post\"], function(a, b) {\n-        o[b] = function(a, c, d, e) {\n-            return o.isFunction(c) && (e = e || d, d = c, c = void 0), o.ajax({\n-                url: a,\n-                type: b,\n-                dataType: e,\n-                data: c,\n-                success: d\n-            })\n-        }\n-    }), o.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function(a, b) {\n-        o.fn[b] = function(a) {\n-            return this.on(b, a)\n-        }\n-    }), o._evalUrl = function(a) {\n-        return o.ajax({\n-            url: a,\n-            type: \"GET\",\n-            dataType: \"script\",\n-            async: !1,\n-            global: !1,\n-            \"throws\": !0\n-        })\n-    }, o.fn.extend({\n-        wrapAll: function(a) {\n-            var b;\n-            return o.isFunction(a) ? this.each(function(b) {\n-                o(this).wrapAll(a.call(this, b))\n-            }) : (this[0] && (b = o(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function() {\n-                var a = this;\n-                while (a.firstElementChild) a = a.firstElementChild;\n-                return a\n-            }).append(this)), this)\n-        },\n-        wrapInner: function(a) {\n-            return this.each(o.isFunction(a) ? function(b) {\n-                o(this).wrapInner(a.call(this, b))\n-            } : function() {\n-                var b = o(this),\n-                    c = b.contents();\n-                c.length ? c.wrapAll(a) : b.append(a)\n-            })\n-        },\n-        wrap: function(a) {\n-            var b = o.isFunction(a);\n-            return this.each(function(c) {\n-                o(this).wrapAll(b ? a.call(this, c) : a)\n-            })\n-        },\n-        unwrap: function() {\n-            return this.parent().each(function() {\n-                o.nodeName(this, \"body\") || o(this).replaceWith(this.childNodes)\n-            }).end()\n-        }\n-    }), o.expr.filters.hidden = function(a) {\n-        return a.offsetWidth <= 0 && a.offsetHeight <= 0\n-    }, o.expr.filters.visible = function(a) {\n-        return !o.expr.filters.hidden(a)\n-    };\n-    var wc = /%20/g,\n-        xc = /\\[\\]$/,\n-        yc = /\\r?\\n/g,\n-        zc = /^(?:submit|button|image|reset|file)$/i,\n-        Ac = /^(?:input|select|textarea|keygen)/i;\n+\t// Handle a deep copy situation\n+\tif ( typeof target === \"boolean\" ) {\n+\t\tdeep = target;\n \n-    function Bc(a, b, c, d) {\n-        var e;\n-        if (o.isArray(b)) o.each(b, function(b, e) {\n-            c || xc.test(a) ? d(a, e) : Bc(a + \"[\" + (\"object\" == typeof e ? b : \"\") + \"]\", e, c, d)\n-        });\n-        else if (c || \"object\" !== o.type(b)) d(a, b);\n-        else\n-            for (e in b) Bc(a + \"[\" + e + \"]\", b[e], c, d)\n-    }\n-    o.param = function(a, b) {\n-        var c, d = [],\n-            e = function(a, b) {\n-                b = o.isFunction(b) ? b() : null == b ? \"\" : b, d[d.length] = encodeURIComponent(a) + \"=\" + encodeURIComponent(b)\n-            };\n-        if (void 0 === b && (b = o.ajaxSettings && o.ajaxSettings.traditional), o.isArray(a) || a.jquery && !o.isPlainObject(a)) o.each(a, function() {\n-            e(this.name, this.value)\n-        });\n-        else\n-            for (c in a) Bc(c, a[c], b, e);\n-        return d.join(\"&\").replace(wc, \"+\")\n-    }, o.fn.extend({\n-        serialize: function() {\n-            return o.param(this.serializeArray())\n-        },\n-        serializeArray: function() {\n-            return this.map(function() {\n-                var a = o.prop(this, \"elements\");\n-                return a ? o.makeArray(a) : this\n-            }).filter(function() {\n-                var a = this.type;\n-                return this.name && !o(this).is(\":disabled\") && Ac.test(this.nodeName) && !zc.test(a) && (this.checked || !T.test(a))\n-            }).map(function(a, b) {\n-                var c = o(this).val();\n-                return null == c ? null : o.isArray(c) ? o.map(c, function(a) {\n-                    return {\n-                        name: b.name,\n-                        value: a.replace(yc, \"\\r\\n\")\n-                    }\n-                }) : {\n-                    name: b.name,\n-                    value: c.replace(yc, \"\\r\\n\")\n-                }\n-            }).get()\n-        }\n-    }), o.ajaxSettings.xhr = function() {\n-        try {\n\\ No newline at end of file\n-            return new XMLHttpRequest\n-        } catch (a) {}\n-    };\n-    var Cc = 0,\n-        Dc = {},\n-        Ec = {\n-            0: 200,\n-            1223: 204\n-        },\n-        Fc = o.ajaxSettings.xhr();\n-    a.ActiveXObject && o(a).on(\"unload\", function() {\n-        for (var a in Dc) Dc[a]()\n-    }), l.cors = !!Fc && \"withCredentials\" in Fc, l.ajax = Fc = !!Fc, o.ajaxTransport(function(a) {\n-        var b;\n-        return l.cors || Fc && !a.crossDomain ? {\n-            send: function(c, d) {\n-                var e, f = a.xhr(),\n-                    g = ++Cc;\n-                if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields)\n-                    for (e in a.xhrFields) f[e] = a.xhrFields[e];\n-                a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c[\"X-Requested-With\"] || (c[\"X-Requested-With\"] = \"XMLHttpRequest\");\n-                for (e in c) f.setRequestHeader(e, c[e]);\n-                b = function(a) {\n-                    return function() {\n-                        b && (delete Dc[g], b = f.onload = f.onerror = null, \"abort\" === a ? f.abort() : \"error\" === a ? d(f.status, f.statusText) : d(Ec[f.status] || f.status, f.statusText, \"string\" == typeof f.responseText ? {\n-                            text: f.responseText\n-                        } : void 0, f.getAllResponseHeaders()))\n-                    }\n-                }, f.onload = b(), f.onerror = b(\"error\"), b = Dc[g] = b(\"abort\"), f.send(a.hasContent && a.data || null)\n-            },\n-            abort: function() {\n-                b && b()\n-            }\n-        } : void 0\n-    }), o.ajaxSetup({\n-        accepts: {\n-            script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n-        },\n-        contents: {\n-            script: /(?:java|ecma)script/\n-        },\n-        converters: {\n-            \"text script\": function(a) {\n-                return o.globalEval(a), a\n-            }\n-        }\n-    }), o.ajaxPrefilter(\"script\", function(a) {\n-        void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = \"GET\")\n-    }), o.ajaxTransport(\"script\", function(a) {\n-        if (a.crossDomain) {\n-            var b, c;\n-            return {\n-                send: function(d, e) {\n-                    b = o(\"<script>\").prop({\n-                        async: !0,\n-                        charset: a.scriptCharset,\n-                        src: a.url\n-                    }).on(\"load error\", c = function(a) {\n-                        b.remove(), c = null, a && e(\"error\" === a.type ? 404 : 200, a.type)\n-                    }), m.head.appendChild(b[0])\n-                },\n-                abort: function() {\n-                    c && c()\n-                }\n-            }\n-        }\n-    });\n-    var Gc = [],\n-        Hc = /(=)\\?(?=&|$)|\\?\\?/;\n-    o.ajaxSetup({\n-        jsonp: \"callback\",\n-        jsonpCallback: function() {\n-            var a = Gc.pop() || o.expando + \"_\" + cc++;\n-            return this[a] = !0, a\n-        }\n-    }), o.ajaxPrefilter(\"json jsonp\", function(b, c, d) {\n-        var e, f, g, h = b.jsonp !== !1 && (Hc.test(b.url) ? \"url\" : \"string\" == typeof b.data && !(b.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && Hc.test(b.data) && \"data\");\n-        return h || \"jsonp\" === b.dataTypes[0] ? (e = b.jsonpCallback = o.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Hc, \"$1\" + e) : b.jsonp !== !1 && (b.url += (dc.test(b.url) ? \"&\" : \"?\") + b.jsonp + \"=\" + e), b.converters[\"script json\"] = function() {\n-            return g || o.error(e + \" was not called\"), g[0]\n-        }, b.dataTypes[0] = \"json\", f = a[e], a[e] = function() {\n-            g = arguments\n-        }, d.always(function() {\n-            a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Gc.push(e)), g && o.isFunction(f) && f(g[0]), g = f = void 0\n-        }), \"script\") : void 0\n-    }), o.parseHTML = function(a, b, c) {\n-        if (!a || \"string\" != typeof a) return null;\n-        \"boolean\" == typeof b && (c = b, b = !1), b = b || m;\n-        var d = v.exec(a),\n-            e = !c && [];\n-        return d ? [b.createElement(d[1])] : (d = o.buildFragment([a], b, e), e && e.length && o(e).remove(), o.merge([], d.childNodes))\n-    };\n-    var Ic = o.fn.load;\n-    o.fn.load = function(a, b, c) {\n-        if (\"string\" != typeof a && Ic) return Ic.apply(this, arguments);\n-        var d, e, f, g = this,\n-            h = a.indexOf(\" \");\n-        return h >= 0 && (d = a.slice(h), a = a.slice(0, h)), o.isFunction(b) ? (c = b, b = void 0) : b && \"object\" == typeof b && (e = \"POST\"), g.length > 0 && o.ajax({\n-            url: a,\n-            type: e,\n-            dataType: \"html\",\n-            data: b\n-        }).done(function(a) {\n-            f = arguments, g.html(d ? o(\"<div>\").append(o.parseHTML(a)).find(d) : a)\n-        }).complete(c && function(a, b) {\n-            g.each(c, f || [a.responseText, b, a])\n-        }), this\n-    }, o.expr.filters.animated = function(a) {\n-        return o.grep(o.timers, function(b) {\n-            return a === b.elem\n-        }).length\n-    };\n-    var Jc = a.document.documentElement;\n+\t\t// Skip the boolean and the target\n+\t\ttarget = arguments[ i ] || {};\n+\t\ti++;\n+\t}\n \n-    function Kc(a) {\n-        return o.isWindow(a) ? a : 9 === a.nodeType && a.defaultView\n-    }\n-    o.offset = {\n-        setOffset: function(a, b, c) {\n-            var d, e, f, g, h, i, j, k = o.css(a, \"position\"),\n-                l = o(a),\n-                m = {};\n-            \"static\" === k && (a.style.position = \"relative\"), h = l.offset(), f = o.css(a, \"top\"), i = o.css(a, \"left\"), j = (\"absolute\" === k || \"fixed\" === k) && (f + i).indexOf(\"auto\") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), o.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), \"using\" in b ? b.using.call(a, m) : l.css(m)\n-        }\n-    }, o.fn.extend({\n-        offset: function(a) {\n-            if (arguments.length) return void 0 === a ? this : this.each(function(b) {\n-                o.offset.setOffset(this, a, b)\n-            });\n-            var b, c, d = this[0],\n-                e = {\n-                    top: 0,\n-                    left: 0\n-                },\n-                f = d && d.ownerDocument;\n-            if (f) return b = f.documentElement, o.contains(b, d) ? (typeof d.getBoundingClientRect !== U && (e = d.getBoundingClientRect()), c = Kc(f), {\n-                top: e.top + c.pageYOffset - b.clientTop,\n-                left: e.left + c.pageXOffset - b.clientLeft\n-            }) : e\n-        },\n-        position: function() {\n-            if (this[0]) {\n-                var a, b, c = this[0],\n-                    d = {\n-                        top: 0,\n-                        left: 0\n-                    };\n-                return \"fixed\" === o.css(c, \"position\") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), o.nodeName(a[0], \"html\") || (d = a.offset()), d.top += o.css(a[0], \"borderTopWidth\", !0), d.left += o.css(a[0], \"borderLeftWidth\", !0)), {\n-                    top: b.top - d.top - o.css(c, \"marginTop\", !0),\n-                    left: b.left - d.left - o.css(c, \"marginLeft\", !0)\n-                }\n-            }\n-        },\n-        offsetParent: function() {\n-            return this.map(function() {\n-                var a = this.offsetParent || Jc;\n-                while (a && !o.nodeName(a, \"html\") && \"static\" === o.css(a, \"position\")) a = a.offsetParent;\n-                return a || Jc\n-            })\n-        }\n-    }), o.each({\n-        scrollLeft: \"pageXOffset\",\n-        scrollTop: \"pageYOffset\"\n-    }, function(b, c) {\n-        var d = \"pageYOffset\" === c;\n-        o.fn[b] = function(e) {\n-            return J(this, function(b, e, f) {\n-                var g = Kc(b);\n-                return void 0 === f ? g ? g[c] : b[e] : void(g ? g.scrollTo(d ? a.pageXOffset : f, d ? f : a.pageYOffset) : b[e] = f)\n-            }, b, e, arguments.length, null)\n-        }\n-    }), o.each([\"top\", \"left\"], function(a, b) {\n-        o.cssHooks[b] = yb(l.pixelPosition, function(a, c) {\n-            return c ? (c = xb(a, b), vb.test(c) ? o(a).position()[b] + \"px\" : c) : void 0\n-        })\n-    }), o.each({\n-        Height: \"height\",\n-        Width: \"width\"\n-    }, function(a, b) {\n-        o.each({\n-            padding: \"inner\" + a,\n-            content: b,\n-            \"\": \"outer\" + a\n-        }, function(c, d) {\n-            o.fn[d] = function(d, e) {\n-                var f = arguments.length && (c || \"boolean\" != typeof d),\n-                    g = c || (d === !0 || e === !0 ? \"margin\" : \"border\");\n-                return J(this, function(b, c, d) {\n-                    var e;\n-                    return o.isWindow(b) ? b.document.documentElement[\"client\" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body[\"scroll\" + a], e[\"scroll\" + a], b.body[\"offset\" + a], e[\"offset\" + a], e[\"client\" + a])) : void 0 === d ? o.css(b, c, g) : o.style(b, c, d, g)\n-                }, b, f ? d : void 0, f, null)\n-            }\n-        })\n-    }), o.fn.size = function() {\n-        return this.length\n-    }, o.fn.andSelf = o.fn.addBack, \"function\" == typeof define && define.amd && define(\"jquery\", [], function() {\n-        return o\n-    });\n-    var Lc = a.jQuery,\n-        Mc = a.$;\n-    return o.noConflict = function(b) {\n-        return a.$ === o && (a.$ = Mc), b && a.jQuery === o && (a.jQuery = Lc), o\n-    }, typeof b === U && (a.jQuery = a.$ = o), o\n-});\n+\t// Handle case when target is a string or something (possible in deep copy)\n+\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n+\t\ttarget = {};\n+\t}\n+\n+\t// Extend jQuery itself if only one argument is passed\n+\tif ( i === length ) {\n+\t\ttarget = this;\n+\t\ti--;\n+\t}\n+\n+\tfor ( ; i < length; i++ ) {\n+\n+\t\t// Only deal with non-null/undefined values\n+\t\tif ( ( options = arguments[ i ] ) != null ) {\n+\n+\t\t\t// Extend the base object\n+\t\t\tfor ( name in options ) {\n+\t\t\t\tcopy = options[ name ];\n+\n+\t\t\t\t// Prevent Object.prototype pollution\n+\t\t\t\t// Prevent never-ending loop\n+\t\t\t\tif ( name === \"__proto__\" || target === copy ) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\t// Recurse if we're merging plain objects or arrays\n+\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n+\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n+\t\t\t\t\tsrc = target[ name ];\n+\n+\t\t\t\t\t// Ensure proper type for the source value\n+\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n+\t\t\t\t\t\tclone = [];\n+\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n+\t\t\t\t\t\tclone = {};\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tclone = src;\n+\t\t\t\t\t}\n+\t\t\t\t\tcopyIsArray = false;\n+\n+\t\t\t\t\t// Never move original objects, clone them\n+\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n+\n+\t\t\t\t// Don't bring in undefined values\n+\t\t\t\t} else if ( copy !== undefined ) {\n+\t\t\t\t\ttarget[ name ] = copy;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Return the modified object\n+\treturn target;\n+};\n+\n+jQuery.extend( {\n+\n+\t// Unique for each copy of jQuery on the page\n+\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n+\n+\t// Assume jQuery is ready without the ready module\n+\tisReady: true,\n+\n+\terror: function( msg ) {\n+\t\tthrow new Error( msg );\n+\t},\n+\n+\tnoop: function() {},\n+\n+\tisPlainObject: function( obj ) {\n+\t\tvar proto, Ctor;\n+\n+\t\t// Detect obvious negatives\n+\t\t// Use toString instead of jQuery.type to catch host objects\n+\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tproto = getProto( obj );\n+\n+\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n+\t\tif ( !proto ) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n+\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n+\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n+\t},\n+\n+\tisEmptyObject: function( obj ) {\n+\t\tvar name;\n+\n+\t\tfor ( name in obj ) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t},\n+\n+\t// Evaluates a script in a provided context; falls back to the global one\n+\t// if not specified.\n+\tglobalEval: function( code, options, doc ) {\n+\t\tDOMEval( code, { nonce: options && options.nonce }, doc );\n+\t},\n+\n+\teach: function( obj, callback ) {\n+\t\tvar length, i = 0;\n+\n+\t\tif ( isArrayLike( obj ) ) {\n+\t\t\tlength = obj.length;\n+\t\t\tfor ( ; i < length; i++ ) {\n+\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor ( i in obj ) {\n+\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn obj;\n+\t},\n+\n+\t// results is for internal usage only\n+\tmakeArray: function( arr, results ) {\n+\t\tvar ret = results || [];\n+\n+\t\tif ( arr != null ) {\n+\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n+\t\t\t\tjQuery.merge( ret,\n+\t\t\t\t\ttypeof arr === \"string\" ?\n+\t\t\t\t\t\t[ arr ] : arr\n+\t\t\t\t);\n+\t\t\t} else {\n+\t\t\t\tpush.call( ret, arr );\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn ret;\n+\t},\n+\n+\tinArray: function( elem, arr, i ) {\n+\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n+\t},\n+\n+\t// Support: Android <=4.0 only, PhantomJS 1 only\n+\t// push.apply(_, arraylike) throws on ancient WebKit\n+\tmerge: function( first, second ) {\n+\t\tvar len = +second.length,\n+\t\t\tj = 0,\n+\t\t\ti = first.length;\n+\n+\t\tfor ( ; j < len; j++ ) {\n+\t\t\tfirst[ i++ ] = second[ j ];\n+\t\t}\n+\n+\t\tfirst.length = i;\n+\n+\t\treturn first;\n+\t},\n+\n+\tgrep: function( elems, callback, invert ) {\n+\t\tvar callbackInverse,\n+\t\t\tmatches = [],\n+\t\t\ti = 0,\n+\t\t\tlength = elems.length,\n+\t\t\tcallbackExpect = !invert;\n+\n+\t\t// Go through the array, only saving the items\n+\t\t// that pass the validator function\n+\t\tfor ( ; i < length; i++ ) {\n+\t\t\tcallbackInverse = !callback( elems[ i ], i );\n+\t\t\tif ( callbackInverse !== callbackExpect ) {\n+\t\t\t\tmatches.push( elems[ i ] );\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn matches;\n+\t},\n+\n+\t// arg is for internal usage only\n+\tmap: function( elems, callback, arg ) {\n+\t\tvar length, value,\n+\t\t\ti = 0,\n+\t\t\tret = [];\n+\n+\t\t// Go through the array, translating each of the items to their new values\n+\t\tif ( isArrayLike( elems ) ) {\n+\t\t\tlength = elems.length;\n+\t\t\tfor ( ; i < length; i++ ) {\n+\t\t\t\tvalue = callback( elems[ i ], i, arg );\n+\n+\t\t\t\tif ( value != null ) {\n+\t\t\t\t\tret.push( value );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t// Go through every key on the object,\n+\t\t} else {\n+\t\t\tfor ( i in elems ) {\n+\t\t\t\tvalue = callback( elems[ i ], i, arg );\n+\n+\t\t\t\tif ( value != null ) {\n+\t\t\t\t\tret.push( value );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Flatten any nested arrays\n+\t\treturn flat( ret );\n+\t},\n+\n+\t// A global GUID counter for objects\n+\tguid: 1,\n+\n+\t// jQuery.support is not used in Core but other projects attach their\n+\t// properties to it so it needs to exist.\n+\tsupport: support\n+} );\n+\n+if ( typeof Symbol === \"function\" ) {\n+\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n+}\n+\n+// Populate the class2type map\n+jQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\n+\tfunction( _i, name ) {\n+\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n+\t} );\n+\n+function isArrayLike( obj ) {\n+\n+\t// Support: real iOS 8.2 only (not reproducible in simulator)\n+\t// `in` check used to prevent JIT error (gh-2145)\n+\t// hasOwn isn't used here due to false negatives\n+\t// regarding Nodelist length in IE\n+\tvar length = !!obj && \"length\" in obj && obj.length,\n+\t\ttype = toType( obj );\n+\n+\tif ( isFunction( obj ) || isWindow( obj ) ) {\n+\t\treturn false;\n+\t}\n+\n+\treturn type === \"array\" || length === 0 ||\n+\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n+}\n+var Sizzle =\n+/*!\n+ * Sizzle CSS Selector Engine v2.3.9\n+ * https://sizzlejs.com/\n+ *\n+ * Copyright JS Foundation and other contributors\n+ * Released under the MIT license\n+ * https://js.foundation/\n+ *\n+ * Date: 2022-12-19\n+ */\n+( function( window ) {\n+var i,\n+\tsupport,\n+\tExpr,\n+\tgetText,\n+\tisXML,\n+\ttokenize,\n+\tcompile,\n+\tselect,\n+\toutermostContext,\n+\tsortInput,\n+\thasDuplicate,\n+\n+\t// Local document vars\n+\tsetDocument,\n+\tdocument,\n+\tdocElem,\n+\tdocumentIsHTML,\n+\trbuggyQSA,\n+\trbuggyMatches,\n+\tmatches,\n+\tcontains,\n+\n+\t// Instance-specific data\n+\texpando = \"sizzle\" + 1 * new Date(),\n+\tpreferredDoc = window.document,\n+\tdirruns = 0,\n+\tdone = 0,\n+\tclassCache = createCache(),\n+\ttokenCache = createCache(),\n+\tcompilerCache = createCache(),\n+\tnonnativeSelectorCache = createCache(),\n+\tsortOrder = function( a, b ) {\n+\t\tif ( a === b ) {\n+\t\t\thasDuplicate = true;\n+\t\t}\n+\t\treturn 0;\n+\t},\n+\n+\t// Instance methods\n+\thasOwn = ( {} ).hasOwnProperty,\n+\tarr = [],\n+\tpop = arr.pop,\n+\tpushNative = arr.push,\n+\tpush = arr.push,\n+\tslice = arr.slice,\n+\n+\t// Use a stripped-down indexOf as it's faster than native\n+\t// https://jsperf.com/thor-indexof-vs-for/5\n+\tindexOf = function( list, elem ) {\n+\t\tvar i = 0,\n+\t\t\tlen = list.length;\n+\t\tfor ( ; i < len; i++ ) {\n+\t\t\tif ( list[ i ] === elem ) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t}\n+\t\treturn -1;\n+\t},\n+\n+\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" +\n+\t\t\"ismap|loop|multiple|open|readonly|required|scoped\",\n+\n+\t// Regular expressions\n+\n+\t// http://www.w3.org/TR/css3-selectors/#whitespace\n+\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n+\n+\t// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n+\tidentifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace +\n+\t\t\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n+\n+\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n+\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n+\n+\t\t// Operator (capture 2)\n+\t\t\"*([*^$|!~]?=)\" + whitespace +\n+\n+\t\t// \"Attribute values must be CSS identifiers [capture 5]\n+\t\t// or strings [capture 3 or capture 4]\"\n+\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" +\n+\t\twhitespace + \"*\\\\]\",\n+\n+\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n+\n+\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n+\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n+\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n+\n+\t\t// 2. simple (capture 6)\n+\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n+\n+\t\t// 3. anything else (capture 2)\n+\t\t\".*\" +\n+\t\t\")\\\\)|)\",\n+\n+\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n+\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n+\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" +\n+\t\twhitespace + \"+$\", \"g\" ),\n+\n+\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n+\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace +\n+\t\t\"*\" ),\n+\trdescend = new RegExp( whitespace + \"|>\" ),\n+\n+\trpseudo = new RegExp( pseudos ),\n+\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n+\n+\tmatchExpr = {\n+\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n+\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n+\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n+\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n+\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n+\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" +\n+\t\t\twhitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" +\n+\t\t\twhitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n+\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n+\n+\t\t// For use in libraries implementing .is()\n+\t\t// We use this for POS matching in `select`\n+\t\t\"needsContext\": new RegExp( \"^\" + whitespace +\n+\t\t\t\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace +\n+\t\t\t\"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n+\t},\n+\n+\trhtml = /HTML$/i,\n+\trinputs = /^(?:input|select|textarea|button)$/i,\n+\trheader = /^h\\d$/i,\n+\n+\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n+\n+\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n+\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n+\n+\trsibling = /[+~]/,\n+\n+\t// CSS escapes\n+\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n+\trunescape = new RegExp( \"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\" ),\n+\tfunescape = function( escape, nonHex ) {\n+\t\tvar high = \"0x\" + escape.slice( 1 ) - 0x10000;\n+\n+\t\treturn nonHex ?\n+\n+\t\t\t// Strip the backslash prefix from a non-hex escape sequence\n+\t\t\tnonHex :\n+\n+\t\t\t// Replace a hexadecimal escape sequence with the encoded Unicode code point\n+\t\t\t// Support: IE <=11+\n+\t\t\t// For values outside the Basic Multilingual Plane (BMP), manually construct a\n+\t\t\t// surrogate pair\n+\t\t\thigh < 0 ?\n+\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n+\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n+\t},\n+\n+\t// CSS string/identifier serialization\n+\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n+\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n+\tfcssescape = function( ch, asCodePoint ) {\n+\t\tif ( asCodePoint ) {\n+\n+\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n+\t\t\tif ( ch === \"\\0\" ) {\n+\t\t\t\treturn \"\\uFFFD\";\n+\t\t\t}\n+\n+\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n+\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" +\n+\t\t\t\tch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n+\t\t}\n+\n+\t\t// Other potentially-special ASCII characters get backslash-escaped\n+\t\treturn \"\\\\\" + ch;\n+\t},\n+\n+\t// Used for iframes\n+\t// See setDocument()\n+\t// Removing the function wrapper causes a \"Permission Denied\"\n+\t// error in IE\n+\tunloadHandler = function() {\n+\t\tsetDocument();\n+\t},\n+\n+\tinDisabledFieldset = addCombinator(\n+\t\tfunction( elem ) {\n+\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n+\t\t},\n+\t\t{ dir: \"parentNode\", next: \"legend\" }\n+\t);\n+\n+// Optimize for push.apply( _, NodeList )\n+try {\n+\tpush.apply(\n+\t\t( arr = slice.call( preferredDoc.childNodes ) ),\n+\t\tpreferredDoc.childNodes\n+\t);\n+\n+\t// Support: Android<4.0\n+\t// Detect silently failing push.apply\n+\t// eslint-disable-next-line no-unused-expressions\n+\tarr[ preferredDoc.childNodes.length ].nodeType;\n+} catch ( e ) {\n+\tpush = { apply: arr.length ?\n+\n+\t\t// Leverage slice if possible\n+\t\tfunction( target, els ) {\n+\t\t\tpushNative.apply( target, slice.call( els ) );\n+\t\t} :\n+\n+\t\t// Support: IE<9\n+\t\t// Otherwise append directly\n+\t\tfunction( target, els ) {\n+\t\t\tvar j = target.length,\n+\t\t\t\ti = 0;\n+\n+\t\t\t// Can't trust NodeList.length\n+\t\t\twhile ( ( target[ j++ ] = els[ i++ ] ) ) {}\n+\t\t\ttarget.length = j - 1;\n+\t\t}\n+\t};\n+}\n+\n+function Sizzle( selector, context, results, seed ) {\n+\tvar m, i, elem, nid, match, groups, newSelector,\n+\t\tnewContext = context && context.ownerDocument,\n+\n+\t\t// nodeType defaults to 9, since context defaults to document\n+\t\tnodeType = context ? context.nodeType : 9;\n+\n+\tresults = results || [];\n+\n+\t// Return early from calls with invalid selector or context\n+\tif ( typeof selector !== \"string\" || !selector ||\n+\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n+\n+\t\treturn results;\n+\t}\n+\n+\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n+\tif ( !seed ) {\n+\t\tsetDocument( context );\n+\t\tcontext = context || document;\n+\n+\t\tif ( documentIsHTML ) {\n+\n+\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n+\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n+\t\t\tif ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {\n+\n+\t\t\t\t// ID selector\n+\t\t\t\tif ( ( m = match[ 1 ] ) ) {\n+\n+\t\t\t\t\t// Document context\n+\t\t\t\t\tif ( nodeType === 9 ) {\n+\t\t\t\t\t\tif ( ( elem = context.getElementById( m ) ) ) {\n+\n+\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n+\t\t\t\t\t\t\t// TODO: identify versions\n+\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n+\t\t\t\t\t\t\tif ( elem.id === m ) {\n+\t\t\t\t\t\t\t\tresults.push( elem );\n+\t\t\t\t\t\t\t\treturn results;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\treturn results;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t// Element context\n+\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t// Support: IE, Opera, Webkit\n+\t\t\t\t\t\t// TODO: identify versions\n+\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n+\t\t\t\t\t\tif ( newContext && ( elem = newContext.getElementById( m ) ) &&\n+\t\t\t\t\t\t\tcontains( context, elem ) &&\n+\t\t\t\t\t\t\telem.id === m ) {\n+\n+\t\t\t\t\t\t\tresults.push( elem );\n+\t\t\t\t\t\t\treturn results;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t// Type selector\n+\t\t\t\t} else if ( match[ 2 ] ) {\n+\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n+\t\t\t\t\treturn results;\n+\n+\t\t\t\t// Class selector\n+\t\t\t\t} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&\n+\t\t\t\t\tcontext.getElementsByClassName ) {\n+\n+\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n+\t\t\t\t\treturn results;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Take advantage of querySelectorAll\n+\t\t\tif ( support.qsa &&\n+\t\t\t\t!nonnativeSelectorCache[ selector + \" \" ] &&\n+\t\t\t\t( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&\n+\n+\t\t\t\t// Support: IE 8 only\n+\t\t\t\t// Exclude object elements\n+\t\t\t\t( nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\" ) ) {\n+\n+\t\t\t\tnewSelector = selector;\n+\t\t\t\tnewContext = context;\n+\n+\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n+\t\t\t\t// descendant combinators, which is not what we want.\n+\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n+\t\t\t\t// list with an ID selector referencing the scope context.\n+\t\t\t\t// The technique has to be used as well when a leading combinator is used\n+\t\t\t\t// as such selectors are not recognized by querySelectorAll.\n+\t\t\t\t// Thanks to Andrew Dupont for this technique.\n+\t\t\t\tif ( nodeType === 1 &&\n+\t\t\t\t\t( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {\n+\n+\t\t\t\t\t// Expand context for sibling selectors\n+\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n+\t\t\t\t\t\tcontext;\n+\n+\t\t\t\t\t// We can use :scope instead of the ID hack if the browser\n+\t\t\t\t\t// supports it & if we're not changing the context.\n+\t\t\t\t\tif ( newContext !== context || !support.scope ) {\n+\n+\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n+\t\t\t\t\t\tif ( ( nid = context.getAttribute( \"id\" ) ) ) {\n+\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcontext.setAttribute( \"id\", ( nid = expando ) );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Prefix every selector in the list\n+\t\t\t\t\tgroups = tokenize( selector );\n+\t\t\t\t\ti = groups.length;\n+\t\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\t\tgroups[ i ] = ( nid ? \"#\" + nid : \":scope\" ) + \" \" +\n+\t\t\t\t\t\t\ttoSelector( groups[ i ] );\n+\t\t\t\t\t}\n+\t\t\t\t\tnewSelector = groups.join( \",\" );\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\n+\t\t\t\t\t// `qSA` may not throw for unrecognized parts using forgiving parsing:\n+\t\t\t\t\t// https://drafts.csswg.org/selectors/#forgiving-selector\n+\t\t\t\t\t// like the `:has()` pseudo-class:\n+\t\t\t\t\t// https://drafts.csswg.org/selectors/#relational\n+\t\t\t\t\t// `CSS.supports` is still expected to return `false` then:\n+\t\t\t\t\t// https://drafts.csswg.org/css-conditional-4/#typedef-supports-selector-fn\n+\t\t\t\t\t// https://drafts.csswg.org/css-conditional-4/#dfn-support-selector\n+\t\t\t\t\tif ( support.cssSupportsSelector &&\n+\n+\t\t\t\t\t\t// eslint-disable-next-line no-undef\n+\t\t\t\t\t\t!CSS.supports( \"selector(:is(\" + newSelector + \"))\" ) ) {\n+\n+\t\t\t\t\t\t// Support: IE 11+\n+\t\t\t\t\t\t// Throw to get to the same code path as an error directly in qSA.\n+\t\t\t\t\t\t// Note: once we only support browser supporting\n+\t\t\t\t\t\t// `CSS.supports('selector(...)')`, we can most likely drop\n+\t\t\t\t\t\t// the `try-catch`. IE doesn't implement the API.\n+\t\t\t\t\t\tthrow new Error();\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tpush.apply( results,\n+\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n+\t\t\t\t\t);\n+\t\t\t\t\treturn results;\n+\t\t\t\t} catch ( qsaError ) {\n+\t\t\t\t\tnonnativeSelectorCache( selector, true );\n+\t\t\t\t} finally {\n+\t\t\t\t\tif ( nid === expando ) {\n+\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// All others\n+\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n+}\n+\n+/**\n+ * Create key-value caches of limited size\n+ * @returns {function(string, object)} Returns the Object data after storing it on itself with\n+ *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n+ *\tdeleting the oldest entry\n+ */\n+function createCache() {\n+\tvar keys = [];\n+\n+\tfunction cache( key, value ) {\n+\n+\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n+\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n+\n+\t\t\t// Only keep the most recent entries\n+\t\t\tdelete cache[ keys.shift() ];\n+\t\t}\n+\t\treturn ( cache[ key + \" \" ] = value );\n+\t}\n+\treturn cache;\n+}\n+\n+/**\n+ * Mark a function for special use by Sizzle\n+ * @param {Function} fn The function to mark\n+ */\n+function markFunction( fn ) {\n+\tfn[ expando ] = true;\n+\treturn fn;\n+}\n+\n+/**\n+ * Support testing using an element\n+ * @param {Function} fn Passed the created element and returns a boolean result\n+ */\n+function assert( fn ) {\n+\tvar el = document.createElement( \"fieldset\" );\n+\n+\ttry {\n+\t\treturn !!fn( el );\n+\t} catch ( e ) {\n+\t\treturn false;\n+\t} finally {\n+\n+\t\t// Remove from its parent by default\n+\t\tif ( el.parentNode ) {\n+\t\t\tel.parentNode.removeChild( el );\n+\t\t}\n+\n+\t\t// release memory in IE\n+\t\tel = null;\n+\t}\n+}\n+\n+/**\n+ * Adds the same handler for all of the specified attrs\n+ * @param {String} attrs Pipe-separated list of attributes\n+ * @param {Function} handler The method that will be applied\n+ */\n+function addHandle( attrs, handler ) {\n+\tvar arr = attrs.split( \"|\" ),\n+\t\ti = arr.length;\n+\n+\twhile ( i-- ) {\n+\t\tExpr.attrHandle[ arr[ i ] ] = handler;\n+\t}\n+}\n+\n+/**\n+ * Checks document order of two siblings\n+ * @param {Element} a\n+ * @param {Element} b\n+ * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n+ */\n+function siblingCheck( a, b ) {\n+\tvar cur = b && a,\n+\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n+\t\t\ta.sourceIndex - b.sourceIndex;\n+\n+\t// Use IE sourceIndex if available on both nodes\n+\tif ( diff ) {\n+\t\treturn diff;\n+\t}\n+\n+\t// Check if b follows a\n+\tif ( cur ) {\n+\t\twhile ( ( cur = cur.nextSibling ) ) {\n+\t\t\tif ( cur === b ) {\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn a ? 1 : -1;\n+}\n+\n+/**\n+ * Returns a function to use in pseudos for input types\n+ * @param {String} type\n+ */\n+function createInputPseudo( type ) {\n+\treturn function( elem ) {\n+\t\tvar name = elem.nodeName.toLowerCase();\n+\t\treturn name === \"input\" && elem.type === type;\n+\t};\n+}\n+\n+/**\n+ * Returns a function to use in pseudos for buttons\n+ * @param {String} type\n+ */\n+function createButtonPseudo( type ) {\n+\treturn function( elem ) {\n+\t\tvar name = elem.nodeName.toLowerCase();\n+\t\treturn ( name === \"input\" || name === \"button\" ) && elem.type === type;\n+\t};\n+}\n+\n+/**\n+ * Returns a function to use in pseudos for :enabled/:disabled\n+ * @param {Boolean} disabled true for :disabled; false for :enabled\n+ */\n+function createDisabledPseudo( disabled ) {\n+\n+\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n+\treturn function( elem ) {\n+\n+\t\t// Only certain elements can match :enabled or :disabled\n+\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n+\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n+\t\tif ( \"form\" in elem ) {\n+\n+\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n+\t\t\t// * listed form-associated elements in a disabled fieldset\n+\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n+\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n+\t\t\t// * option elements in a disabled optgroup\n+\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n+\t\t\t// All such elements have a \"form\" property.\n+\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n+\n+\t\t\t\t// Option elements defer to a parent optgroup if present\n+\t\t\t\tif ( \"label\" in elem ) {\n+\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n+\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn elem.disabled === disabled;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// Support: IE 6 - 11\n+\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n+\t\t\t\treturn elem.isDisabled === disabled ||\n+\n+\t\t\t\t\t// Where there is no isDisabled, check manually\n+\t\t\t\t\t/* jshint -W018 */\n+\t\t\t\t\telem.isDisabled !== !disabled &&\n+\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n+\t\t\t}\n+\n+\t\t\treturn elem.disabled === disabled;\n+\n+\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n+\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n+\t\t// even exist on them, let alone have a boolean value.\n+\t\t} else if ( \"label\" in elem ) {\n+\t\t\treturn elem.disabled === disabled;\n+\t\t}\n+\n+\t\t// Remaining elements are neither :enabled nor :disabled\n+\t\treturn false;\n+\t};\n+}\n+\n+/**\n+ * Returns a function to use in pseudos for positionals\n+ * @param {Function} fn\n+ */\n+function createPositionalPseudo( fn ) {\n+\treturn markFunction( function( argument ) {\n+\t\targument = +argument;\n+\t\treturn markFunction( function( seed, matches ) {\n+\t\t\tvar j,\n+\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n+\t\t\t\ti = matchIndexes.length;\n+\n+\t\t\t// Match elements found at the specified indexes\n+\t\t\twhile ( i-- ) {\n+\t\t\t\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\n+\t\t\t\t\tseed[ j ] = !( matches[ j ] = seed[ j ] );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} );\n+\t} );\n+}\n+\n+/**\n+ * Checks a node for validity as a Sizzle context\n+ * @param {Element|Object=} context\n+ * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n+ */\n+function testContext( context ) {\n+\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n+}\n+\n+// Expose support vars for convenience\n+support = Sizzle.support = {};\n+\n+/**\n+ * Detects XML nodes\n+ * @param {Element|Object} elem An element or a document\n+ * @returns {Boolean} True iff elem is a non-HTML XML node\n+ */\n+isXML = Sizzle.isXML = function( elem ) {\n+\tvar namespace = elem && elem.namespaceURI,\n+\t\tdocElem = elem && ( elem.ownerDocument || elem ).documentElement;\n+\n+\t// Support: IE <=8\n+\t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n+\t// https://bugs.jquery.com/ticket/4833\n+\treturn !rhtml.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n+};\n+\n+/**\n+ * Sets document-related variables once based on the current document\n+ * @param {Element|Object} [doc] An element or document object to use to set the document\n+ * @returns {Object} Returns the current document\n+ */\n+setDocument = Sizzle.setDocument = function( node ) {\n+\tvar hasCompare, subWindow,\n+\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n+\n+\t// Return early if doc is invalid or already selected\n+\t// Support: IE 11+, Edge 17 - 18+\n+\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t// two documents; shallow comparisons work.\n+\t// eslint-disable-next-line eqeqeq\n+\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\n+\t\treturn document;\n+\t}\n+\n+\t// Update global variables\n+\tdocument = doc;\n+\tdocElem = document.documentElement;\n+\tdocumentIsHTML = !isXML( document );\n+\n+\t// Support: IE 9 - 11+, Edge 12 - 18+\n+\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n+\t// Support: IE 11+, Edge 17 - 18+\n+\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t// two documents; shallow comparisons work.\n+\t// eslint-disable-next-line eqeqeq\n+\tif ( preferredDoc != document &&\n+\t\t( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {\n+\n+\t\t// Support: IE 11, Edge\n+\t\tif ( subWindow.addEventListener ) {\n+\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n+\n+\t\t// Support: IE 9 - 10 only\n+\t\t} else if ( subWindow.attachEvent ) {\n+\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n+\t\t}\n+\t}\n+\n+\t// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n+\t// Safari 4 - 5 only, Opera <=11.6 - 12.x only\n+\t// IE/Edge & older browsers don't support the :scope pseudo-class.\n+\t// Support: Safari 6.0 only\n+\t// Safari 6.0 supports :scope but it's an alias of :root there.\n+\tsupport.scope = assert( function( el ) {\n+\t\tdocElem.appendChild( el ).appendChild( document.createElement( \"div\" ) );\n+\t\treturn typeof el.querySelectorAll !== \"undefined\" &&\n+\t\t\t!el.querySelectorAll( \":scope fieldset div\" ).length;\n+\t} );\n+\n+\t// Support: Chrome 105+, Firefox 104+, Safari 15.4+\n+\t// Make sure forgiving mode is not used in `CSS.supports( \"selector(...)\" )`.\n+\t//\n+\t// `:is()` uses a forgiving selector list as an argument and is widely\n+\t// implemented, so it's a good one to test against.\n+\tsupport.cssSupportsSelector = assert( function() {\n+\t\t/* eslint-disable no-undef */\n+\n+\t\treturn CSS.supports( \"selector(*)\" ) &&\n+\n+\t\t\t// Support: Firefox 78-81 only\n+\t\t\t// In old Firefox, `:is()` didn't use forgiving parsing. In that case,\n+\t\t\t// fail this test as there's no selector to test against that.\n+\t\t\t// `CSS.supports` uses unforgiving parsing\n+\t\t\tdocument.querySelectorAll( \":is(:jqfake)\" ) &&\n+\n+\t\t\t// `*` is needed as Safari & newer Chrome implemented something in between\n+\t\t\t// for `:has()` - it throws in `qSA` if it only contains an unsupported\n+\t\t\t// argument but multiple ones, one of which is supported, are fine.\n+\t\t\t// We want to play safe in case `:is()` gets the same treatment.\n+\t\t\t!CSS.supports( \"selector(:is(*,:jqfake))\" );\n+\n+\t\t/* eslint-enable */\n+\t} );\n+\n+\t/* Attributes\n+\t---------------------------------------------------------------------- */\n+\n+\t// Support: IE<8\n+\t// Verify that getAttribute really returns attributes and not properties\n+\t// (excepting IE8 booleans)\n+\tsupport.attributes = assert( function( el ) {\n+\t\tel.className = \"i\";\n+\t\treturn !el.getAttribute( \"className\" );\n+\t} );\n+\n+\t/* getElement(s)By*\n+\t---------------------------------------------------------------------- */\n+\n+\t// Check if getElementsByTagName(\"*\") returns only elements\n+\tsupport.getElementsByTagName = assert( function( el ) {\n+\t\tel.appendChild( document.createComment( \"\" ) );\n+\t\treturn !el.getElementsByTagName( \"*\" ).length;\n+\t} );\n+\n+\t// Support: IE<9\n+\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n+\n+\t// Support: IE<10\n+\t// Check if getElementById returns elements by name\n+\t// The broken getElementById methods don't pick up programmatically-set names,\n+\t// so use a roundabout getElementsByName test\n+\tsupport.getById = assert( function( el ) {\n+\t\tdocElem.appendChild( el ).id = expando;\n+\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n+\t} );\n+\n+\t// ID filter and find\n+\tif ( support.getById ) {\n+\t\tExpr.filter[ \"ID\" ] = function( id ) {\n+\t\t\tvar attrId = id.replace( runescape, funescape );\n+\t\t\treturn function( elem ) {\n+\t\t\t\treturn elem.getAttribute( \"id\" ) === attrId;\n+\t\t\t};\n+\t\t};\n+\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n+\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n+\t\t\t\tvar elem = context.getElementById( id );\n+\t\t\t\treturn elem ? [ elem ] : [];\n+\t\t\t}\n+\t\t};\n+\t} else {\n+\t\tExpr.filter[ \"ID\" ] =  function( id ) {\n+\t\t\tvar attrId = id.replace( runescape, funescape );\n+\t\t\treturn function( elem ) {\n+\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n+\t\t\t\t\telem.getAttributeNode( \"id\" );\n+\t\t\t\treturn node && node.value === attrId;\n+\t\t\t};\n+\t\t};\n+\n+\t\t// Support: IE 6 - 7 only\n+\t\t// getElementById is not reliable as a find shortcut\n+\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n+\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n+\t\t\t\tvar node, i, elems,\n+\t\t\t\t\telem = context.getElementById( id );\n+\n+\t\t\t\tif ( elem ) {\n+\n+\t\t\t\t\t// Verify the id attribute\n+\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n+\t\t\t\t\tif ( node && node.value === id ) {\n+\t\t\t\t\t\treturn [ elem ];\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Fall back on getElementsByName\n+\t\t\t\t\telems = context.getElementsByName( id );\n+\t\t\t\t\ti = 0;\n+\t\t\t\t\twhile ( ( elem = elems[ i++ ] ) ) {\n+\t\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n+\t\t\t\t\t\tif ( node && node.value === id ) {\n+\t\t\t\t\t\t\treturn [ elem ];\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn [];\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t// Tag\n+\tExpr.find[ \"TAG\" ] = support.getElementsByTagName ?\n+\t\tfunction( tag, context ) {\n+\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n+\t\t\t\treturn context.getElementsByTagName( tag );\n+\n+\t\t\t// DocumentFragment nodes don't have gEBTN\n+\t\t\t} else if ( support.qsa ) {\n+\t\t\t\treturn context.querySelectorAll( tag );\n+\t\t\t}\n+\t\t} :\n+\n+\t\tfunction( tag, context ) {\n+\t\t\tvar elem,\n+\t\t\t\ttmp = [],\n+\t\t\t\ti = 0,\n+\n+\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n+\t\t\t\tresults = context.getElementsByTagName( tag );\n+\n+\t\t\t// Filter out possible comments\n+\t\t\tif ( tag === \"*\" ) {\n+\t\t\t\twhile ( ( elem = results[ i++ ] ) ) {\n+\t\t\t\t\tif ( elem.nodeType === 1 ) {\n+\t\t\t\t\t\ttmp.push( elem );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn tmp;\n+\t\t\t}\n+\t\t\treturn results;\n+\t\t};\n+\n+\t// Class\n+\tExpr.find[ \"CLASS\" ] = support.getElementsByClassName && function( className, context ) {\n+\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n+\t\t\treturn context.getElementsByClassName( className );\n+\t\t}\n+\t};\n+\n+\t/* QSA/matchesSelector\n+\t---------------------------------------------------------------------- */\n+\n+\t// QSA and matchesSelector support\n+\n+\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n+\trbuggyMatches = [];\n+\n+\t// qSa(:focus) reports false when true (Chrome 21)\n+\t// We allow this because of a bug in IE8/9 that throws an error\n+\t// whenever `document.activeElement` is accessed on an iframe\n+\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n+\t// See https://bugs.jquery.com/ticket/13378\n+\trbuggyQSA = [];\n+\n+\tif ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {\n+\n+\t\t// Build QSA regex\n+\t\t// Regex strategy adopted from Diego Perini\n+\t\tassert( function( el ) {\n+\n+\t\t\tvar input;\n+\n+\t\t\t// Select is set to empty string on purpose\n+\t\t\t// This is to test IE's treatment of not explicitly\n+\t\t\t// setting a boolean content attribute,\n+\t\t\t// since its presence should be enough\n+\t\t\t// https://bugs.jquery.com/ticket/12359\n+\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n+\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n+\t\t\t\t\"<option selected=''></option></select>\";\n+\n+\t\t\t// Support: IE8, Opera 11-12.16\n+\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n+\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n+\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n+\t\t\tif ( el.querySelectorAll( \"[msallowcapture^='']\" ).length ) {\n+\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n+\t\t\t}\n+\n+\t\t\t// Support: IE8\n+\t\t\t// Boolean attributes and \"value\" are not treated correctly\n+\t\t\tif ( !el.querySelectorAll( \"[selected]\" ).length ) {\n+\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n+\t\t\t}\n+\n+\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n+\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n+\t\t\t\trbuggyQSA.push( \"~=\" );\n+\t\t\t}\n+\n+\t\t\t// Support: IE 11+, Edge 15 - 18+\n+\t\t\t// IE 11/Edge don't find elements on a `[name='']` query in some cases.\n+\t\t\t// Adding a temporary attribute to the document before the selection works\n+\t\t\t// around the issue.\n+\t\t\t// Interestingly, IE 10 & older don't seem to have the issue.\n+\t\t\tinput = document.createElement( \"input\" );\n+\t\t\tinput.setAttribute( \"name\", \"\" );\n+\t\t\tel.appendChild( input );\n+\t\t\tif ( !el.querySelectorAll( \"[name='']\" ).length ) {\n+\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" +\n+\t\t\t\t\twhitespace + \"*(?:''|\\\"\\\")\" );\n+\t\t\t}\n+\n+\t\t\t// Webkit/Opera - :checked should return selected option elements\n+\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n+\t\t\t// IE8 throws error here and will not see later tests\n+\t\t\tif ( !el.querySelectorAll( \":checked\" ).length ) {\n+\t\t\t\trbuggyQSA.push( \":checked\" );\n+\t\t\t}\n+\n+\t\t\t// Support: Safari 8+, iOS 8+\n+\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n+\t\t\t// In-page `selector#id sibling-combinator selector` fails\n+\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n+\t\t\t\trbuggyQSA.push( \".#.+[+~]\" );\n+\t\t\t}\n+\n+\t\t\t// Support: Firefox <=3.6 - 5 only\n+\t\t\t// Old Firefox doesn't throw on a badly-escaped identifier.\n+\t\t\tel.querySelectorAll( \"\\\\\\f\" );\n+\t\t\trbuggyQSA.push( \"[\\\\r\\\\n\\\\f]\" );\n+\t\t} );\n+\n+\t\tassert( function( el ) {\n+\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n+\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n+\n+\t\t\t// Support: Windows 8 Native Apps\n+\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n+\t\t\tvar input = document.createElement( \"input\" );\n+\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n+\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n+\n+\t\t\t// Support: IE8\n+\t\t\t// Enforce case-sensitivity of name attribute\n+\t\t\tif ( el.querySelectorAll( \"[name=d]\" ).length ) {\n+\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n+\t\t\t}\n+\n+\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n+\t\t\t// IE8 throws error here and will not see later tests\n+\t\t\tif ( el.querySelectorAll( \":enabled\" ).length !== 2 ) {\n+\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n+\t\t\t}\n+\n+\t\t\t// Support: IE9-11+\n+\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n+\t\t\tdocElem.appendChild( el ).disabled = true;\n+\t\t\tif ( el.querySelectorAll( \":disabled\" ).length !== 2 ) {\n+\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n+\t\t\t}\n+\n+\t\t\t// Support: Opera 10 - 11 only\n+\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n+\t\t\tel.querySelectorAll( \"*,:x\" );\n+\t\t\trbuggyQSA.push( \",.*:\" );\n+\t\t} );\n+\t}\n+\n+\tif ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||\n+\t\tdocElem.webkitMatchesSelector ||\n+\t\tdocElem.mozMatchesSelector ||\n+\t\tdocElem.oMatchesSelector ||\n+\t\tdocElem.msMatchesSelector ) ) ) ) {\n+\n+\t\tassert( function( el ) {\n+\n+\t\t\t// Check to see if it's possible to do matchesSelector\n+\t\t\t// on a disconnected node (IE 9)\n+\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n+\n+\t\t\t// This should fail with an exception\n+\t\t\t// Gecko does not error, returns false instead\n+\t\t\tmatches.call( el, \"[s!='']:x\" );\n+\t\t\trbuggyMatches.push( \"!=\", pseudos );\n+\t\t} );\n+\t}\n+\n+\tif ( !support.cssSupportsSelector ) {\n+\n+\t\t// Support: Chrome 105+, Safari 15.4+\n+\t\t// `:has()` uses a forgiving selector list as an argument so our regular\n+\t\t// `try-catch` mechanism fails to catch `:has()` with arguments not supported\n+\t\t// natively like `:has(:contains(\"Foo\"))`. Where supported & spec-compliant,\n+\t\t// we now use `CSS.supports(\"selector(:is(SELECTOR_TO_BE_TESTED))\")`, but\n+\t\t// outside that we mark `:has` as buggy.\n+\t\trbuggyQSA.push( \":has\" );\n+\t}\n+\n+\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( \"|\" ) );\n+\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( \"|\" ) );\n+\n+\t/* Contains\n+\t---------------------------------------------------------------------- */\n+\thasCompare = rnative.test( docElem.compareDocumentPosition );\n+\n+\t// Element contains another\n+\t// Purposefully self-exclusive\n+\t// As in, an element does not contain itself\n+\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n+\t\tfunction( a, b ) {\n+\n+\t\t\t// Support: IE <9 only\n+\t\t\t// IE doesn't have `contains` on `document` so we need to check for\n+\t\t\t// `documentElement` presence.\n+\t\t\t// We need to fall back to `a` when `documentElement` is missing\n+\t\t\t// as `ownerDocument` of elements within `<template/>` may have\n+\t\t\t// a null one - a default behavior of all modern browsers.\n+\t\t\tvar adown = a.nodeType === 9 && a.documentElement || a,\n+\t\t\t\tbup = b && b.parentNode;\n+\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n+\t\t\t\tadown.contains ?\n+\t\t\t\t\tadown.contains( bup ) :\n+\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n+\t\t\t) );\n+\t\t} :\n+\t\tfunction( a, b ) {\n+\t\t\tif ( b ) {\n+\t\t\t\twhile ( ( b = b.parentNode ) ) {\n+\t\t\t\t\tif ( b === a ) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t};\n+\n+\t/* Sorting\n+\t---------------------------------------------------------------------- */\n+\n+\t// Document order sorting\n+\tsortOrder = hasCompare ?\n+\tfunction( a, b ) {\n+\n+\t\t// Flag for duplicate removal\n+\t\tif ( a === b ) {\n+\t\t\thasDuplicate = true;\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\t// Sort on method existence if only one input has compareDocumentPosition\n+\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n+\t\tif ( compare ) {\n+\t\t\treturn compare;\n+\t\t}\n+\n+\t\t// Calculate position if both inputs belong to the same document\n+\t\t// Support: IE 11+, Edge 17 - 18+\n+\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t// two documents; shallow comparisons work.\n+\t\t// eslint-disable-next-line eqeqeq\n+\t\tcompare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?\n+\t\t\ta.compareDocumentPosition( b ) :\n+\n+\t\t\t// Otherwise we know they are disconnected\n+\t\t\t1;\n+\n+\t\t// Disconnected nodes\n+\t\tif ( compare & 1 ||\n+\t\t\t( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {\n+\n+\t\t\t// Choose the first element that is related to our preferred document\n+\t\t\t// Support: IE 11+, Edge 17 - 18+\n+\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\t// two documents; shallow comparisons work.\n+\t\t\t// eslint-disable-next-line eqeqeq\n+\t\t\tif ( a == document || a.ownerDocument == preferredDoc &&\n+\t\t\t\tcontains( preferredDoc, a ) ) {\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\n+\t\t\t// Support: IE 11+, Edge 17 - 18+\n+\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\t// two documents; shallow comparisons work.\n+\t\t\t// eslint-disable-next-line eqeqeq\n+\t\t\tif ( b == document || b.ownerDocument == preferredDoc &&\n+\t\t\t\tcontains( preferredDoc, b ) ) {\n+\t\t\t\treturn 1;\n+\t\t\t}\n+\n+\t\t\t// Maintain original order\n+\t\t\treturn sortInput ?\n+\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n+\t\t\t\t0;\n+\t\t}\n+\n+\t\treturn compare & 4 ? -1 : 1;\n+\t} :\n+\tfunction( a, b ) {\n+\n+\t\t// Exit early if the nodes are identical\n+\t\tif ( a === b ) {\n+\t\t\thasDuplicate = true;\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tvar cur,\n+\t\t\ti = 0,\n+\t\t\taup = a.parentNode,\n+\t\t\tbup = b.parentNode,\n+\t\t\tap = [ a ],\n+\t\t\tbp = [ b ];\n+\n+\t\t// Parentless nodes are either documents or disconnected\n+\t\tif ( !aup || !bup ) {\n+\n+\t\t\t// Support: IE 11+, Edge 17 - 18+\n+\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\t// two documents; shallow comparisons work.\n+\t\t\t/* eslint-disable eqeqeq */\n+\t\t\treturn a == document ? -1 :\n+\t\t\t\tb == document ? 1 :\n+\t\t\t\t/* eslint-enable eqeqeq */\n+\t\t\t\taup ? -1 :\n+\t\t\t\tbup ? 1 :\n+\t\t\t\tsortInput ?\n+\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n+\t\t\t\t0;\n+\n+\t\t// If the nodes are siblings, we can do a quick check\n+\t\t} else if ( aup === bup ) {\n+\t\t\treturn siblingCheck( a, b );\n+\t\t}\n+\n+\t\t// Otherwise we need full lists of their ancestors for comparison\n+\t\tcur = a;\n+\t\twhile ( ( cur = cur.parentNode ) ) {\n+\t\t\tap.unshift( cur );\n+\t\t}\n+\t\tcur = b;\n+\t\twhile ( ( cur = cur.parentNode ) ) {\n+\t\t\tbp.unshift( cur );\n+\t\t}\n+\n+\t\t// Walk down the tree looking for a discrepancy\n+\t\twhile ( ap[ i ] === bp[ i ] ) {\n+\t\t\ti++;\n+\t\t}\n+\n+\t\treturn i ?\n+\n+\t\t\t// Do a sibling check if the nodes have a common ancestor\n+\t\t\tsiblingCheck( ap[ i ], bp[ i ] ) :\n+\n+\t\t\t// Otherwise nodes in our document sort first\n+\t\t\t// Support: IE 11+, Edge 17 - 18+\n+\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\t// two documents; shallow comparisons work.\n+\t\t\t/* eslint-disable eqeqeq */\n+\t\t\tap[ i ] == preferredDoc ? -1 :\n+\t\t\tbp[ i ] == preferredDoc ? 1 :\n+\t\t\t/* eslint-enable eqeqeq */\n+\t\t\t0;\n+\t};\n+\n+\treturn document;\n+};\n+\n+Sizzle.matches = function( expr, elements ) {\n+\treturn Sizzle( expr, null, null, elements );\n+};\n+\n+Sizzle.matchesSelector = function( elem, expr ) {\n+\tsetDocument( elem );\n+\n+\tif ( support.matchesSelector && documentIsHTML &&\n+\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n+\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n+\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n+\n+\t\ttry {\n+\t\t\tvar ret = matches.call( elem, expr );\n+\n+\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n+\t\t\tif ( ret || support.disconnectedMatch ||\n+\n+\t\t\t\t// As well, disconnected nodes are said to be in a document\n+\t\t\t\t// fragment in IE 9\n+\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\t\t} catch ( e ) {\n+\t\t\tnonnativeSelectorCache( expr, true );\n+\t\t}\n+\t}\n+\n+\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n+};\n+\n+Sizzle.contains = function( context, elem ) {\n+\n+\t// Set document vars if needed\n+\t// Support: IE 11+, Edge 17 - 18+\n+\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t// two documents; shallow comparisons work.\n+\t// eslint-disable-next-line eqeqeq\n+\tif ( ( context.ownerDocument || context ) != document ) {\n+\t\tsetDocument( context );\n+\t}\n+\treturn contains( context, elem );\n+};\n+\n+Sizzle.attr = function( elem, name ) {\n+\n+\t// Set document vars if needed\n+\t// Support: IE 11+, Edge 17 - 18+\n+\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t// two documents; shallow comparisons work.\n+\t// eslint-disable-next-line eqeqeq\n+\tif ( ( elem.ownerDocument || elem ) != document ) {\n+\t\tsetDocument( elem );\n+\t}\n+\n+\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n+\n+\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n+\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n+\t\t\tfn( elem, name, !documentIsHTML ) :\n+\t\t\tundefined;\n+\n+\treturn val !== undefined ?\n+\t\tval :\n+\t\tsupport.attributes || !documentIsHTML ?\n+\t\t\telem.getAttribute( name ) :\n+\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n+\t\t\t\tval.value :\n+\t\t\t\tnull;\n+};\n+\n+Sizzle.escape = function( sel ) {\n+\treturn ( sel + \"\" ).replace( rcssescape, fcssescape );\n+};\n+\n+Sizzle.error = function( msg ) {\n+\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n+};\n+\n+/**\n+ * Document sorting and removing duplicates\n+ * @param {ArrayLike} results\n+ */\n+Sizzle.uniqueSort = function( results ) {\n+\tvar elem,\n+\t\tduplicates = [],\n+\t\tj = 0,\n+\t\ti = 0;\n+\n+\t// Unless we *know* we can detect duplicates, assume their presence\n+\thasDuplicate = !support.detectDuplicates;\n+\tsortInput = !support.sortStable && results.slice( 0 );\n+\tresults.sort( sortOrder );\n+\n+\tif ( hasDuplicate ) {\n+\t\twhile ( ( elem = results[ i++ ] ) ) {\n+\t\t\tif ( elem === results[ i ] ) {\n+\t\t\t\tj = duplicates.push( i );\n+\t\t\t}\n+\t\t}\n+\t\twhile ( j-- ) {\n+\t\t\tresults.splice( duplicates[ j ], 1 );\n+\t\t}\n+\t}\n+\n+\t// Clear input after sorting to release objects\n+\t// See https://github.com/jquery/sizzle/pull/225\n+\tsortInput = null;\n+\n+\treturn results;\n+};\n+\n+/**\n+ * Utility function for retrieving the text value of an array of DOM nodes\n+ * @param {Array|Element} elem\n+ */\n+getText = Sizzle.getText = function( elem ) {\n+\tvar node,\n+\t\tret = \"\",\n+\t\ti = 0,\n+\t\tnodeType = elem.nodeType;\n+\n+\tif ( !nodeType ) {\n+\n+\t\t// If no nodeType, this is expected to be an array\n+\t\twhile ( ( node = elem[ i++ ] ) ) {\n+\n+\t\t\t// Do not traverse comment nodes\n+\t\t\tret += getText( node );\n+\t\t}\n+\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n+\n+\t\t// Use textContent for elements\n+\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n+\t\tif ( typeof elem.textContent === \"string\" ) {\n+\t\t\treturn elem.textContent;\n+\t\t} else {\n+\n+\t\t\t// Traverse its children\n+\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n+\t\t\t\tret += getText( elem );\n+\t\t\t}\n+\t\t}\n+\t} else if ( nodeType === 3 || nodeType === 4 ) {\n+\t\treturn elem.nodeValue;\n+\t}\n+\n+\t// Do not include comment or processing instruction nodes\n+\n+\treturn ret;\n+};\n+\n+Expr = Sizzle.selectors = {\n+\n+\t// Can be adjusted by the user\n+\tcacheLength: 50,\n+\n+\tcreatePseudo: markFunction,\n+\n+\tmatch: matchExpr,\n+\n+\tattrHandle: {},\n+\n+\tfind: {},\n+\n+\trelative: {\n+\t\t\">\": { dir: \"parentNode\", first: true },\n+\t\t\" \": { dir: \"parentNode\" },\n+\t\t\"+\": { dir: \"previousSibling\", first: true },\n+\t\t\"~\": { dir: \"previousSibling\" }\n+\t},\n+\n+\tpreFilter: {\n+\t\t\"ATTR\": function( match ) {\n+\t\t\tmatch[ 1 ] = match[ 1 ].replace( runescape, funescape );\n+\n+\t\t\t// Move the given value to match[3] whether quoted or unquoted\n+\t\t\tmatch[ 3 ] = ( match[ 3 ] || match[ 4 ] ||\n+\t\t\t\tmatch[ 5 ] || \"\" ).replace( runescape, funescape );\n+\n+\t\t\tif ( match[ 2 ] === \"~=\" ) {\n+\t\t\t\tmatch[ 3 ] = \" \" + match[ 3 ] + \" \";\n+\t\t\t}\n+\n+\t\t\treturn match.slice( 0, 4 );\n+\t\t},\n+\n+\t\t\"CHILD\": function( match ) {\n+\n+\t\t\t/* matches from matchExpr[\"CHILD\"]\n+\t\t\t\t1 type (only|nth|...)\n+\t\t\t\t2 what (child|of-type)\n+\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n+\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n+\t\t\t\t5 sign of xn-component\n+\t\t\t\t6 x of xn-component\n+\t\t\t\t7 sign of y-component\n+\t\t\t\t8 y of y-component\n+\t\t\t*/\n+\t\t\tmatch[ 1 ] = match[ 1 ].toLowerCase();\n+\n+\t\t\tif ( match[ 1 ].slice( 0, 3 ) === \"nth\" ) {\n+\n+\t\t\t\t// nth-* requires argument\n+\t\t\t\tif ( !match[ 3 ] ) {\n+\t\t\t\t\tSizzle.error( match[ 0 ] );\n+\t\t\t\t}\n+\n+\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n+\t\t\t\t// remember that false/true cast respectively to 0/1\n+\t\t\t\tmatch[ 4 ] = +( match[ 4 ] ?\n+\t\t\t\t\tmatch[ 5 ] + ( match[ 6 ] || 1 ) :\n+\t\t\t\t\t2 * ( match[ 3 ] === \"even\" || match[ 3 ] === \"odd\" ) );\n+\t\t\t\tmatch[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === \"odd\" );\n+\n+\t\t\t\t// other types prohibit arguments\n+\t\t\t} else if ( match[ 3 ] ) {\n+\t\t\t\tSizzle.error( match[ 0 ] );\n+\t\t\t}\n+\n+\t\t\treturn match;\n+\t\t},\n+\n+\t\t\"PSEUDO\": function( match ) {\n+\t\t\tvar excess,\n+\t\t\t\tunquoted = !match[ 6 ] && match[ 2 ];\n+\n+\t\t\tif ( matchExpr[ \"CHILD\" ].test( match[ 0 ] ) ) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\t// Accept quoted arguments as-is\n+\t\t\tif ( match[ 3 ] ) {\n+\t\t\t\tmatch[ 2 ] = match[ 4 ] || match[ 5 ] || \"\";\n+\n+\t\t\t// Strip excess characters from unquoted arguments\n+\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n+\n+\t\t\t\t// Get excess from tokenize (recursively)\n+\t\t\t\t( excess = tokenize( unquoted, true ) ) &&\n+\n+\t\t\t\t// advance to the next closing parenthesis\n+\t\t\t\t( excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length ) ) {\n+\n+\t\t\t\t// excess is a negative index\n+\t\t\t\tmatch[ 0 ] = match[ 0 ].slice( 0, excess );\n+\t\t\t\tmatch[ 2 ] = unquoted.slice( 0, excess );\n+\t\t\t}\n+\n+\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n+\t\t\treturn match.slice( 0, 3 );\n+\t\t}\n+\t},\n+\n+\tfilter: {\n+\n+\t\t\"TAG\": function( nodeNameSelector ) {\n+\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n+\t\t\treturn nodeNameSelector === \"*\" ?\n+\t\t\t\tfunction() {\n+\t\t\t\t\treturn true;\n+\t\t\t\t} :\n+\t\t\t\tfunction( elem ) {\n+\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n+\t\t\t\t};\n+\t\t},\n+\n+\t\t\"CLASS\": function( className ) {\n+\t\t\tvar pattern = classCache[ className + \" \" ];\n+\n+\t\t\treturn pattern ||\n+\t\t\t\t( pattern = new RegExp( \"(^|\" + whitespace +\n+\t\t\t\t\t\")\" + className + \"(\" + whitespace + \"|$)\" ) ) && classCache(\n+\t\t\t\t\t\tclassName, function( elem ) {\n+\t\t\t\t\t\t\treturn pattern.test(\n+\t\t\t\t\t\t\t\ttypeof elem.className === \"string\" && elem.className ||\n+\t\t\t\t\t\t\t\ttypeof elem.getAttribute !== \"undefined\" &&\n+\t\t\t\t\t\t\t\t\telem.getAttribute( \"class\" ) ||\n+\t\t\t\t\t\t\t\t\"\"\n+\t\t\t\t\t\t\t);\n+\t\t\t\t} );\n+\t\t},\n+\n+\t\t\"ATTR\": function( name, operator, check ) {\n+\t\t\treturn function( elem ) {\n+\t\t\t\tvar result = Sizzle.attr( elem, name );\n+\n+\t\t\t\tif ( result == null ) {\n+\t\t\t\t\treturn operator === \"!=\";\n+\t\t\t\t}\n+\t\t\t\tif ( !operator ) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\n+\t\t\t\tresult += \"\";\n+\n+\t\t\t\t/* eslint-disable max-len */\n+\n+\t\t\t\treturn operator === \"=\" ? result === check :\n+\t\t\t\t\toperator === \"!=\" ? result !== check :\n+\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n+\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n+\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n+\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n+\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n+\t\t\t\t\tfalse;\n+\t\t\t\t/* eslint-enable max-len */\n+\n+\t\t\t};\n+\t\t},\n+\n+\t\t\"CHILD\": function( type, what, _argument, first, last ) {\n+\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n+\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n+\t\t\t\tofType = what === \"of-type\";\n+\n+\t\t\treturn first === 1 && last === 0 ?\n+\n+\t\t\t\t// Shortcut for :nth-*(n)\n+\t\t\t\tfunction( elem ) {\n+\t\t\t\t\treturn !!elem.parentNode;\n+\t\t\t\t} :\n+\n+\t\t\t\tfunction( elem, _context, xml ) {\n+\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n+\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n+\t\t\t\t\t\tparent = elem.parentNode,\n+\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n+\t\t\t\t\t\tuseCache = !xml && !ofType,\n+\t\t\t\t\t\tdiff = false;\n+\n+\t\t\t\t\tif ( parent ) {\n+\n+\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n+\t\t\t\t\t\tif ( simple ) {\n+\t\t\t\t\t\t\twhile ( dir ) {\n+\t\t\t\t\t\t\t\tnode = elem;\n+\t\t\t\t\t\t\t\twhile ( ( node = node[ dir ] ) ) {\n+\t\t\t\t\t\t\t\t\tif ( ofType ?\n+\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n+\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n+\n+\t\t\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n+\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n+\n+\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n+\t\t\t\t\t\tif ( forward && useCache ) {\n+\n+\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n+\n+\t\t\t\t\t\t\t// ...in a gzip-friendly way\n+\t\t\t\t\t\t\tnode = parent;\n+\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n+\n+\t\t\t\t\t\t\t// Support: IE <9 only\n+\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n+\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n+\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n+\n+\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n+\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n+\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n+\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n+\n+\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n+\n+\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n+\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n+\n+\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n+\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n+\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n+\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t// Use previously-cached element index if available\n+\t\t\t\t\t\t\tif ( useCache ) {\n+\n+\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n+\t\t\t\t\t\t\t\tnode = elem;\n+\t\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n+\n+\t\t\t\t\t\t\t\t// Support: IE <9 only\n+\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n+\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n+\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n+\n+\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n+\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n+\t\t\t\t\t\t\t\tdiff = nodeIndex;\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t// xml :nth-child(...)\n+\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n+\t\t\t\t\t\t\tif ( diff === false ) {\n+\n+\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n+\t\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n+\t\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n+\n+\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n+\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n+\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n+\t\t\t\t\t\t\t\t\t\t++diff ) {\n+\n+\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n+\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n+\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] ||\n+\t\t\t\t\t\t\t\t\t\t\t\t( node[ expando ] = {} );\n+\n+\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n+\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n+\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n+\t\t\t\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n+\n+\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n+\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n+\t\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n+\t\t\t\t\t\tdiff -= last;\n+\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n+\t\t\t\t\t}\n+\t\t\t\t};\n+\t\t},\n+\n+\t\t\"PSEUDO\": function( pseudo, argument ) {\n+\n+\t\t\t// pseudo-class names are case-insensitive\n+\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n+\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n+\t\t\t// Remember that setFilters inherits from pseudos\n+\t\t\tvar args,\n+\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n+\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n+\n+\t\t\t// The user may use createPseudo to indicate that\n+\t\t\t// arguments are needed to create the filter function\n+\t\t\t// just as Sizzle does\n+\t\t\tif ( fn[ expando ] ) {\n+\t\t\t\treturn fn( argument );\n+\t\t\t}\n+\n+\t\t\t// But maintain support for old signatures\n+\t\t\tif ( fn.length > 1 ) {\n+\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n+\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n+\t\t\t\t\tmarkFunction( function( seed, matches ) {\n+\t\t\t\t\t\tvar idx,\n+\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n+\t\t\t\t\t\t\ti = matched.length;\n+\t\t\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\t\t\tidx = indexOf( seed, matched[ i ] );\n+\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[ i ] );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} ) :\n+\t\t\t\t\tfunction( elem ) {\n+\t\t\t\t\t\treturn fn( elem, 0, args );\n+\t\t\t\t\t};\n+\t\t\t}\n+\n+\t\t\treturn fn;\n+\t\t}\n+\t},\n+\n+\tpseudos: {\n+\n+\t\t// Potentially complex pseudos\n+\t\t\"not\": markFunction( function( selector ) {\n+\n+\t\t\t// Trim the selector passed to compile\n+\t\t\t// to avoid treating leading and trailing\n+\t\t\t// spaces as combinators\n+\t\t\tvar input = [],\n+\t\t\t\tresults = [],\n+\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n+\n+\t\t\treturn matcher[ expando ] ?\n+\t\t\t\tmarkFunction( function( seed, matches, _context, xml ) {\n+\t\t\t\t\tvar elem,\n+\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n+\t\t\t\t\t\ti = seed.length;\n+\n+\t\t\t\t\t// Match elements unmatched by `matcher`\n+\t\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\t\tif ( ( elem = unmatched[ i ] ) ) {\n+\t\t\t\t\t\t\tseed[ i ] = !( matches[ i ] = elem );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} ) :\n+\t\t\t\tfunction( elem, _context, xml ) {\n+\t\t\t\t\tinput[ 0 ] = elem;\n+\t\t\t\t\tmatcher( input, null, xml, results );\n+\n+\t\t\t\t\t// Don't keep the element (issue #299)\n+\t\t\t\t\tinput[ 0 ] = null;\n+\t\t\t\t\treturn !results.pop();\n+\t\t\t\t};\n+\t\t} ),\n+\n+\t\t\"has\": markFunction( function( selector ) {\n+\t\t\treturn function( elem ) {\n+\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n+\t\t\t};\n+\t\t} ),\n+\n+\t\t\"contains\": markFunction( function( text ) {\n+\t\t\ttext = text.replace( runescape, funescape );\n+\t\t\treturn function( elem ) {\n+\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n+\t\t\t};\n+\t\t} ),\n+\n+\t\t// \"Whether an element is represented by a :lang() selector\n+\t\t// is based solely on the element's language value\n+\t\t// being equal to the identifier C,\n+\t\t// or beginning with the identifier C immediately followed by \"-\".\n+\t\t// The matching of C against the element's language value is performed case-insensitively.\n+\t\t// The identifier C does not have to be a valid language name.\"\n+\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n+\t\t\"lang\": markFunction( function( lang ) {\n+\n+\t\t\t// lang value must be a valid identifier\n+\t\t\tif ( !ridentifier.test( lang || \"\" ) ) {\n+\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n+\t\t\t}\n+\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n+\t\t\treturn function( elem ) {\n+\t\t\t\tvar elemLang;\n+\t\t\t\tdo {\n+\t\t\t\t\tif ( ( elemLang = documentIsHTML ?\n+\t\t\t\t\t\telem.lang :\n+\t\t\t\t\t\telem.getAttribute( \"xml:lang\" ) || elem.getAttribute( \"lang\" ) ) ) {\n+\n+\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n+\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n+\t\t\t\t\t}\n+\t\t\t\t} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );\n+\t\t\t\treturn false;\n+\t\t\t};\n+\t\t} ),\n+\n+\t\t// Miscellaneous\n+\t\t\"target\": function( elem ) {\n+\t\t\tvar hash = window.location && window.location.hash;\n+\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n+\t\t},\n+\n+\t\t\"root\": function( elem ) {\n+\t\t\treturn elem === docElem;\n+\t\t},\n+\n+\t\t\"focus\": function( elem ) {\n+\t\t\treturn elem === document.activeElement &&\n+\t\t\t\t( !document.hasFocus || document.hasFocus() ) &&\n+\t\t\t\t!!( elem.type || elem.href || ~elem.tabIndex );\n+\t\t},\n+\n+\t\t// Boolean properties\n+\t\t\"enabled\": createDisabledPseudo( false ),\n+\t\t\"disabled\": createDisabledPseudo( true ),\n+\n+\t\t\"checked\": function( elem ) {\n+\n+\t\t\t// In CSS3, :checked should return both checked and selected elements\n+\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n+\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n+\t\t\treturn ( nodeName === \"input\" && !!elem.checked ) ||\n+\t\t\t\t( nodeName === \"option\" && !!elem.selected );\n+\t\t},\n+\n+\t\t\"selected\": function( elem ) {\n+\n+\t\t\t// Accessing this property makes selected-by-default\n+\t\t\t// options in Safari work properly\n+\t\t\tif ( elem.parentNode ) {\n+\t\t\t\t// eslint-disable-next-line no-unused-expressions\n+\t\t\t\telem.parentNode.selectedIndex;\n+\t\t\t}\n+\n+\t\t\treturn elem.selected === true;\n+\t\t},\n+\n+\t\t// Contents\n+\t\t\"empty\": function( elem ) {\n+\n+\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n+\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n+\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n+\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n+\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n+\t\t\t\tif ( elem.nodeType < 6 ) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t},\n+\n+\t\t\"parent\": function( elem ) {\n+\t\t\treturn !Expr.pseudos[ \"empty\" ]( elem );\n+\t\t},\n+\n+\t\t// Element/input types\n+\t\t\"header\": function( elem ) {\n+\t\t\treturn rheader.test( elem.nodeName );\n+\t\t},\n+\n+\t\t\"input\": function( elem ) {\n+\t\t\treturn rinputs.test( elem.nodeName );\n+\t\t},\n+\n+\t\t\"button\": function( elem ) {\n+\t\t\tvar name = elem.nodeName.toLowerCase();\n+\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n+\t\t},\n+\n+\t\t\"text\": function( elem ) {\n+\t\t\tvar attr;\n+\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n+\t\t\t\telem.type === \"text\" &&\n+\n+\t\t\t\t// Support: IE <10 only\n+\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n+\t\t\t\t( ( attr = elem.getAttribute( \"type\" ) ) == null ||\n+\t\t\t\t\tattr.toLowerCase() === \"text\" );\n+\t\t},\n+\n+\t\t// Position-in-collection\n+\t\t\"first\": createPositionalPseudo( function() {\n+\t\t\treturn [ 0 ];\n+\t\t} ),\n+\n+\t\t\"last\": createPositionalPseudo( function( _matchIndexes, length ) {\n+\t\t\treturn [ length - 1 ];\n+\t\t} ),\n+\n+\t\t\"eq\": createPositionalPseudo( function( _matchIndexes, length, argument ) {\n+\t\t\treturn [ argument < 0 ? argument + length : argument ];\n+\t\t} ),\n+\n+\t\t\"even\": createPositionalPseudo( function( matchIndexes, length ) {\n+\t\t\tvar i = 0;\n+\t\t\tfor ( ; i < length; i += 2 ) {\n+\t\t\t\tmatchIndexes.push( i );\n+\t\t\t}\n+\t\t\treturn matchIndexes;\n+\t\t} ),\n+\n+\t\t\"odd\": createPositionalPseudo( function( matchIndexes, length ) {\n+\t\t\tvar i = 1;\n+\t\t\tfor ( ; i < length; i += 2 ) {\n+\t\t\t\tmatchIndexes.push( i );\n+\t\t\t}\n+\t\t\treturn matchIndexes;\n+\t\t} ),\n+\n+\t\t\"lt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n+\t\t\tvar i = argument < 0 ?\n+\t\t\t\targument + length :\n+\t\t\t\targument > length ?\n+\t\t\t\t\tlength :\n+\t\t\t\t\targument;\n+\t\t\tfor ( ; --i >= 0; ) {\n+\t\t\t\tmatchIndexes.push( i );\n+\t\t\t}\n+\t\t\treturn matchIndexes;\n+\t\t} ),\n+\n+\t\t\"gt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n+\t\t\tvar i = argument < 0 ? argument + length : argument;\n+\t\t\tfor ( ; ++i < length; ) {\n+\t\t\t\tmatchIndexes.push( i );\n+\t\t\t}\n+\t\t\treturn matchIndexes;\n+\t\t} )\n+\t}\n+};\n+\n+Expr.pseudos[ \"nth\" ] = Expr.pseudos[ \"eq\" ];\n+\n+// Add button/input type pseudos\n+for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n+\tExpr.pseudos[ i ] = createInputPseudo( i );\n+}\n+for ( i in { submit: true, reset: true } ) {\n+\tExpr.pseudos[ i ] = createButtonPseudo( i );\n+}\n+\n+// Easy API for creating new setFilters\n+function setFilters() {}\n+setFilters.prototype = Expr.filters = Expr.pseudos;\n+Expr.setFilters = new setFilters();\n+\n+tokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n+\tvar matched, match, tokens, type,\n+\t\tsoFar, groups, preFilters,\n+\t\tcached = tokenCache[ selector + \" \" ];\n+\n+\tif ( cached ) {\n+\t\treturn parseOnly ? 0 : cached.slice( 0 );\n+\t}\n+\n+\tsoFar = selector;\n+\tgroups = [];\n+\tpreFilters = Expr.preFilter;\n+\n+\twhile ( soFar ) {\n+\n+\t\t// Comma and first run\n+\t\tif ( !matched || ( match = rcomma.exec( soFar ) ) ) {\n+\t\t\tif ( match ) {\n+\n+\t\t\t\t// Don't consume trailing commas as valid\n+\t\t\t\tsoFar = soFar.slice( match[ 0 ].length ) || soFar;\n+\t\t\t}\n+\t\t\tgroups.push( ( tokens = [] ) );\n+\t\t}\n+\n+\t\tmatched = false;\n+\n+\t\t// Combinators\n+\t\tif ( ( match = rcombinators.exec( soFar ) ) ) {\n+\t\t\tmatched = match.shift();\n+\t\t\ttokens.push( {\n+\t\t\t\tvalue: matched,\n+\n+\t\t\t\t// Cast descendant combinators to space\n+\t\t\t\ttype: match[ 0 ].replace( rtrim, \" \" )\n+\t\t\t} );\n+\t\t\tsoFar = soFar.slice( matched.length );\n+\t\t}\n+\n+\t\t// Filters\n+\t\tfor ( type in Expr.filter ) {\n+\t\t\tif ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||\n+\t\t\t\t( match = preFilters[ type ]( match ) ) ) ) {\n+\t\t\t\tmatched = match.shift();\n+\t\t\t\ttokens.push( {\n+\t\t\t\t\tvalue: matched,\n+\t\t\t\t\ttype: type,\n+\t\t\t\t\tmatches: match\n+\t\t\t\t} );\n+\t\t\t\tsoFar = soFar.slice( matched.length );\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ( !matched ) {\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\t// Return the length of the invalid excess\n+\t// if we're just parsing\n+\t// Otherwise, throw an error or return tokens\n+\treturn parseOnly ?\n+\t\tsoFar.length :\n+\t\tsoFar ?\n+\t\t\tSizzle.error( selector ) :\n+\n+\t\t\t// Cache the tokens\n+\t\t\ttokenCache( selector, groups ).slice( 0 );\n+};\n+\n+function toSelector( tokens ) {\n+\tvar i = 0,\n+\t\tlen = tokens.length,\n+\t\tselector = \"\";\n+\tfor ( ; i < len; i++ ) {\n+\t\tselector += tokens[ i ].value;\n+\t}\n+\treturn selector;\n+}\n+\n+function addCombinator( matcher, combinator, base ) {\n+\tvar dir = combinator.dir,\n+\t\tskip = combinator.next,\n+\t\tkey = skip || dir,\n+\t\tcheckNonElements = base && key === \"parentNode\",\n+\t\tdoneName = done++;\n+\n+\treturn combinator.first ?\n+\n+\t\t// Check against closest ancestor/preceding element\n+\t\tfunction( elem, context, xml ) {\n+\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n+\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n+\t\t\t\t\treturn matcher( elem, context, xml );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t} :\n+\n+\t\t// Check against all ancestor/preceding elements\n+\t\tfunction( elem, context, xml ) {\n+\t\t\tvar oldCache, uniqueCache, outerCache,\n+\t\t\t\tnewCache = [ dirruns, doneName ];\n+\n+\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n+\t\t\tif ( xml ) {\n+\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n+\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n+\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n+\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n+\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n+\n+\t\t\t\t\t\t// Support: IE <9 only\n+\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n+\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] ||\n+\t\t\t\t\t\t\t( outerCache[ elem.uniqueID ] = {} );\n+\n+\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n+\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n+\t\t\t\t\t\t} else if ( ( oldCache = uniqueCache[ key ] ) &&\n+\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n+\n+\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n+\t\t\t\t\t\t\treturn ( newCache[ 2 ] = oldCache[ 2 ] );\n+\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n+\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n+\n+\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n+\t\t\t\t\t\t\tif ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {\n+\t\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t};\n+}\n+\n+function elementMatcher( matchers ) {\n+\treturn matchers.length > 1 ?\n+\t\tfunction( elem, context, xml ) {\n+\t\t\tvar i = matchers.length;\n+\t\t\twhile ( i-- ) {\n+\t\t\t\tif ( !matchers[ i ]( elem, context, xml ) ) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t} :\n+\t\tmatchers[ 0 ];\n+}\n+\n+function multipleContexts( selector, contexts, results ) {\n+\tvar i = 0,\n+\t\tlen = contexts.length;\n+\tfor ( ; i < len; i++ ) {\n+\t\tSizzle( selector, contexts[ i ], results );\n+\t}\n+\treturn results;\n+}\n+\n+function condense( unmatched, map, filter, context, xml ) {\n+\tvar elem,\n+\t\tnewUnmatched = [],\n+\t\ti = 0,\n+\t\tlen = unmatched.length,\n+\t\tmapped = map != null;\n+\n+\tfor ( ; i < len; i++ ) {\n+\t\tif ( ( elem = unmatched[ i ] ) ) {\n+\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n+\t\t\t\tnewUnmatched.push( elem );\n+\t\t\t\tif ( mapped ) {\n+\t\t\t\t\tmap.push( i );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn newUnmatched;\n+}\n+\n+function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n+\tif ( postFilter && !postFilter[ expando ] ) {\n+\t\tpostFilter = setMatcher( postFilter );\n+\t}\n+\tif ( postFinder && !postFinder[ expando ] ) {\n+\t\tpostFinder = setMatcher( postFinder, postSelector );\n+\t}\n+\treturn markFunction( function( seed, results, context, xml ) {\n+\t\tvar temp, i, elem,\n+\t\t\tpreMap = [],\n+\t\t\tpostMap = [],\n+\t\t\tpreexisting = results.length,\n+\n+\t\t\t// Get initial elements from seed or context\n+\t\t\telems = seed || multipleContexts(\n+\t\t\t\tselector || \"*\",\n+\t\t\t\tcontext.nodeType ? [ context ] : context,\n+\t\t\t\t[]\n+\t\t\t),\n+\n+\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n+\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n+\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n+\t\t\t\telems,\n+\n+\t\t\tmatcherOut = matcher ?\n+\n+\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n+\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n+\n+\t\t\t\t\t// ...intermediate processing is necessary\n+\t\t\t\t\t[] :\n+\n+\t\t\t\t\t// ...otherwise use results directly\n+\t\t\t\t\tresults :\n+\t\t\t\tmatcherIn;\n+\n+\t\t// Find primary matches\n+\t\tif ( matcher ) {\n+\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n+\t\t}\n+\n+\t\t// Apply postFilter\n+\t\tif ( postFilter ) {\n+\t\t\ttemp = condense( matcherOut, postMap );\n+\t\t\tpostFilter( temp, [], context, xml );\n+\n+\t\t\t// Un-match failing elements by moving them back to matcherIn\n+\t\t\ti = temp.length;\n+\t\t\twhile ( i-- ) {\n+\t\t\t\tif ( ( elem = temp[ i ] ) ) {\n+\t\t\t\t\tmatcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ( seed ) {\n+\t\t\tif ( postFinder || preFilter ) {\n+\t\t\t\tif ( postFinder ) {\n+\n+\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n+\t\t\t\t\ttemp = [];\n+\t\t\t\t\ti = matcherOut.length;\n+\t\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) ) {\n+\n+\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n+\t\t\t\t\t\t\ttemp.push( ( matcherIn[ i ] = elem ) );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tpostFinder( null, ( matcherOut = [] ), temp, xml );\n+\t\t\t\t}\n+\n+\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n+\t\t\t\ti = matcherOut.length;\n+\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) &&\n+\t\t\t\t\t\t( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {\n+\n+\t\t\t\t\t\tseed[ temp ] = !( results[ temp ] = elem );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t// Add elements to results, through postFinder if defined\n+\t\t} else {\n+\t\t\tmatcherOut = condense(\n+\t\t\t\tmatcherOut === results ?\n+\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n+\t\t\t\t\tmatcherOut\n+\t\t\t);\n+\t\t\tif ( postFinder ) {\n+\t\t\t\tpostFinder( null, results, matcherOut, xml );\n+\t\t\t} else {\n+\t\t\t\tpush.apply( results, matcherOut );\n+\t\t\t}\n+\t\t}\n+\t} );\n+}\n+\n+function matcherFromTokens( tokens ) {\n+\tvar checkContext, matcher, j,\n+\t\tlen = tokens.length,\n+\t\tleadingRelative = Expr.relative[ tokens[ 0 ].type ],\n+\t\timplicitRelative = leadingRelative || Expr.relative[ \" \" ],\n+\t\ti = leadingRelative ? 1 : 0,\n+\n+\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n+\t\tmatchContext = addCombinator( function( elem ) {\n+\t\t\treturn elem === checkContext;\n+\t\t}, implicitRelative, true ),\n+\t\tmatchAnyContext = addCombinator( function( elem ) {\n+\t\t\treturn indexOf( checkContext, elem ) > -1;\n+\t\t}, implicitRelative, true ),\n+\t\tmatchers = [ function( elem, context, xml ) {\n+\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n+\t\t\t\t( checkContext = context ).nodeType ?\n+\t\t\t\t\tmatchContext( elem, context, xml ) :\n+\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n+\n+\t\t\t// Avoid hanging onto element (issue #299)\n+\t\t\tcheckContext = null;\n+\t\t\treturn ret;\n+\t\t} ];\n+\n+\tfor ( ; i < len; i++ ) {\n+\t\tif ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {\n+\t\t\tmatchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];\n+\t\t} else {\n+\t\t\tmatcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );\n+\n+\t\t\t// Return special upon seeing a positional matcher\n+\t\t\tif ( matcher[ expando ] ) {\n+\n+\t\t\t\t// Find the next relative operator (if any) for proper handling\n+\t\t\t\tj = ++i;\n+\t\t\t\tfor ( ; j < len; j++ ) {\n+\t\t\t\t\tif ( Expr.relative[ tokens[ j ].type ] ) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn setMatcher(\n+\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n+\t\t\t\t\ti > 1 && toSelector(\n+\n+\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n+\t\t\t\t\ttokens\n+\t\t\t\t\t\t.slice( 0, i - 1 )\n+\t\t\t\t\t\t.concat( { value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" } )\n+\t\t\t\t\t).replace( rtrim, \"$1\" ),\n+\t\t\t\t\tmatcher,\n+\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n+\t\t\t\t\tj < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),\n+\t\t\t\t\tj < len && toSelector( tokens )\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\tmatchers.push( matcher );\n+\t\t}\n+\t}\n+\n+\treturn elementMatcher( matchers );\n+}\n+\n+function matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n+\tvar bySet = setMatchers.length > 0,\n+\t\tbyElement = elementMatchers.length > 0,\n+\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n+\t\t\tvar elem, j, matcher,\n+\t\t\t\tmatchedCount = 0,\n+\t\t\t\ti = \"0\",\n+\t\t\t\tunmatched = seed && [],\n+\t\t\t\tsetMatched = [],\n+\t\t\t\tcontextBackup = outermostContext,\n+\n+\t\t\t\t// We must always have either seed elements or outermost context\n+\t\t\t\telems = seed || byElement && Expr.find[ \"TAG\" ]( \"*\", outermost ),\n+\n+\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n+\t\t\t\tdirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),\n+\t\t\t\tlen = elems.length;\n+\n+\t\t\tif ( outermost ) {\n+\n+\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n+\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\t\t// two documents; shallow comparisons work.\n+\t\t\t\t// eslint-disable-next-line eqeqeq\n+\t\t\t\toutermostContext = context == document || context || outermost;\n+\t\t\t}\n+\n+\t\t\t// Add elements passing elementMatchers directly to results\n+\t\t\t// Support: IE<9, Safari\n+\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n+\t\t\tfor ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {\n+\t\t\t\tif ( byElement && elem ) {\n+\t\t\t\t\tj = 0;\n+\n+\t\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n+\t\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n+\t\t\t\t\t// two documents; shallow comparisons work.\n+\t\t\t\t\t// eslint-disable-next-line eqeqeq\n+\t\t\t\t\tif ( !context && elem.ownerDocument != document ) {\n+\t\t\t\t\t\tsetDocument( elem );\n+\t\t\t\t\t\txml = !documentIsHTML;\n+\t\t\t\t\t}\n+\t\t\t\t\twhile ( ( matcher = elementMatchers[ j++ ] ) ) {\n+\t\t\t\t\t\tif ( matcher( elem, context || document, xml ) ) {\n+\t\t\t\t\t\t\tresults.push( elem );\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif ( outermost ) {\n+\t\t\t\t\t\tdirruns = dirrunsUnique;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// Track unmatched elements for set filters\n+\t\t\t\tif ( bySet ) {\n+\n+\t\t\t\t\t// They will have gone through all possible matchers\n+\t\t\t\t\tif ( ( elem = !matcher && elem ) ) {\n+\t\t\t\t\t\tmatchedCount--;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Lengthen the array for every element, matched or not\n+\t\t\t\t\tif ( seed ) {\n+\t\t\t\t\t\tunmatched.push( elem );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n+\t\t\t// makes the latter nonnegative.\n+\t\t\tmatchedCount += i;\n+\n+\t\t\t// Apply set filters to unmatched elements\n+\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n+\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n+\t\t\t// no element matchers and no seed.\n+\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n+\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n+\t\t\t// numerically zero.\n+\t\t\tif ( bySet && i !== matchedCount ) {\n+\t\t\t\tj = 0;\n+\t\t\t\twhile ( ( matcher = setMatchers[ j++ ] ) ) {\n+\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n+\t\t\t\t}\n+\n+\t\t\t\tif ( seed ) {\n+\n+\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n+\t\t\t\t\tif ( matchedCount > 0 ) {\n+\t\t\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\t\t\tif ( !( unmatched[ i ] || setMatched[ i ] ) ) {\n+\t\t\t\t\t\t\t\tsetMatched[ i ] = pop.call( results );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Discard index placeholder values to get only actual matches\n+\t\t\t\t\tsetMatched = condense( setMatched );\n+\t\t\t\t}\n+\n+\t\t\t\t// Add matches to results\n+\t\t\t\tpush.apply( results, setMatched );\n+\n+\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n+\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n+\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n+\n+\t\t\t\t\tSizzle.uniqueSort( results );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Override manipulation of globals by nested matchers\n+\t\t\tif ( outermost ) {\n+\t\t\t\tdirruns = dirrunsUnique;\n+\t\t\t\toutermostContext = contextBackup;\n+\t\t\t}\n+\n+\t\t\treturn unmatched;\n+\t\t};\n+\n+\treturn bySet ?\n+\t\tmarkFunction( superMatcher ) :\n+\t\tsuperMatcher;\n+}\n+\n+compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n+\tvar i,\n+\t\tsetMatchers = [],\n+\t\telementMatchers = [],\n+\t\tcached = compilerCache[ selector + \" \" ];\n+\n+\tif ( !cached ) {\n+\n+\t\t// Generate a function of recursive functions that can be used to check each element\n+\t\tif ( !match ) {\n+\t\t\tmatch = tokenize( selector );\n+\t\t}\n+\t\ti = match.length;\n+\t\twhile ( i-- ) {\n+\t\t\tcached = matcherFromTokens( match[ i ] );\n+\t\t\tif ( cached[ expando ] ) {\n+\t\t\t\tsetMatchers.push( cached );\n+\t\t\t} else {\n+\t\t\t\telementMatchers.push( cached );\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Cache the compiled function\n+\t\tcached = compilerCache(\n+\t\t\tselector,\n+\t\t\tmatcherFromGroupMatchers( elementMatchers, setMatchers )\n+\t\t);\n+\n+\t\t// Save selector and tokenization\n+\t\tcached.selector = selector;\n+\t}\n+\treturn cached;\n+};\n+\n+/**\n+ * A low-level selection function that works with Sizzle's compiled\n+ *  selector functions\n+ * @param {String|Function} selector A selector or a pre-compiled\n+ *  selector function built with Sizzle.compile\n+ * @param {Element} context\n+ * @param {Array} [results]\n+ * @param {Array} [seed] A set of elements to match against\n+ */\n+select = Sizzle.select = function( selector, context, results, seed ) {\n+\tvar i, tokens, token, type, find,\n+\t\tcompiled = typeof selector === \"function\" && selector,\n+\t\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\n+\n+\tresults = results || [];\n+\n+\t// Try to minimize operations if there is only one selector in the list and no seed\n+\t// (the latter of which guarantees us context)\n+\tif ( match.length === 1 ) {\n+\n+\t\t// Reduce context if the leading compound selector is an ID\n+\t\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\n+\t\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === \"ID\" &&\n+\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\n+\n+\t\t\tcontext = ( Expr.find[ \"ID\" ]( token.matches[ 0 ]\n+\t\t\t\t.replace( runescape, funescape ), context ) || [] )[ 0 ];\n+\t\t\tif ( !context ) {\n+\t\t\t\treturn results;\n+\n+\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n+\t\t\t} else if ( compiled ) {\n+\t\t\t\tcontext = context.parentNode;\n+\t\t\t}\n+\n+\t\t\tselector = selector.slice( tokens.shift().value.length );\n+\t\t}\n+\n+\t\t// Fetch a seed set for right-to-left matching\n+\t\ti = matchExpr[ \"needsContext\" ].test( selector ) ? 0 : tokens.length;\n+\t\twhile ( i-- ) {\n+\t\t\ttoken = tokens[ i ];\n+\n+\t\t\t// Abort if we hit a combinator\n+\t\t\tif ( Expr.relative[ ( type = token.type ) ] ) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif ( ( find = Expr.find[ type ] ) ) {\n+\n+\t\t\t\t// Search, expanding context for leading sibling combinators\n+\t\t\t\tif ( ( seed = find(\n+\t\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n+\t\t\t\t\trsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||\n+\t\t\t\t\t\tcontext\n+\t\t\t\t) ) ) {\n+\n+\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n+\t\t\t\t\ttokens.splice( i, 1 );\n+\t\t\t\t\tselector = seed.length && toSelector( tokens );\n+\t\t\t\t\tif ( !selector ) {\n+\t\t\t\t\t\tpush.apply( results, seed );\n+\t\t\t\t\t\treturn results;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Compile and execute a filtering function if one is not provided\n+\t// Provide `match` to avoid retokenization if we modified the selector above\n+\t( compiled || compile( selector, match ) )(\n+\t\tseed,\n+\t\tcontext,\n+\t\t!documentIsHTML,\n+\t\tresults,\n+\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n+\t);\n+\treturn results;\n+};\n+\n+// One-time assignments\n+\n+// Sort stability\n+support.sortStable = expando.split( \"\" ).sort( sortOrder ).join( \"\" ) === expando;\n+\n+// Support: Chrome 14-35+\n+// Always assume duplicates if they aren't passed to the comparison function\n+support.detectDuplicates = !!hasDuplicate;\n+\n+// Initialize against the default document\n+setDocument();\n+\n+// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n+// Detached nodes confoundingly follow *each other*\n+support.sortDetached = assert( function( el ) {\n+\n+\t// Should return 1, but returns 4 (following)\n+\treturn el.compareDocumentPosition( document.createElement( \"fieldset\" ) ) & 1;\n+} );\n+\n+// Support: IE<8\n+// Prevent attribute/property \"interpolation\"\n+// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n+if ( !assert( function( el ) {\n+\tel.innerHTML = \"<a href='#'></a>\";\n+\treturn el.firstChild.getAttribute( \"href\" ) === \"#\";\n+} ) ) {\n+\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n+\t\tif ( !isXML ) {\n+\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n+\t\t}\n+\t} );\n+}\n+\n+// Support: IE<9\n+// Use defaultValue in place of getAttribute(\"value\")\n+if ( !support.attributes || !assert( function( el ) {\n+\tel.innerHTML = \"<input/>\";\n+\tel.firstChild.setAttribute( \"value\", \"\" );\n+\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n+} ) ) {\n+\taddHandle( \"value\", function( elem, _name, isXML ) {\n+\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n+\t\t\treturn elem.defaultValue;\n+\t\t}\n+\t} );\n+}\n+\n+// Support: IE<9\n+// Use getAttributeNode to fetch booleans when getAttribute lies\n+if ( !assert( function( el ) {\n+\treturn el.getAttribute( \"disabled\" ) == null;\n+} ) ) {\n+\taddHandle( booleans, function( elem, name, isXML ) {\n+\t\tvar val;\n+\t\tif ( !isXML ) {\n+\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n+\t\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n+\t\t\t\t\tval.value :\n+\t\t\t\t\tnull;\n+\t\t}\n+\t} );\n+}\n+\n+return Sizzle;\n+\n+} )( window );\n+\n+\n+\n+jQuery.find = Sizzle;\n+jQuery.expr = Sizzle.selectors;\n+\n+// Deprecated\n+jQuery.expr[ \":\" ] = jQuery.expr.pseudos;\n+jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n+jQuery.text = Sizzle.getText;\n+jQuery.isXMLDoc = Sizzle.isXML;\n+jQuery.contains = Sizzle.contains;\n+jQuery.escapeSelector = Sizzle.escape;\n+\n+\n+\n+\n+var dir = function( elem, dir, until ) {\n+\tvar matched = [],\n+\t\ttruncate = until !== undefined;\n+\n+\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n+\t\tif ( elem.nodeType === 1 ) {\n+\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tmatched.push( elem );\n+\t\t}\n+\t}\n+\treturn matched;\n+};\n+\n+\n+var siblings = function( n, elem ) {\n+\tvar matched = [];\n+\n+\tfor ( ; n; n = n.nextSibling ) {\n+\t\tif ( n.nodeType === 1 && n !== elem ) {\n+\t\t\tmatched.push( n );\n+\t\t}\n+\t}\n+\n+\treturn matched;\n+};\n+\n+\n+var rneedsContext = jQuery.expr.match.needsContext;\n+\n+\n+\n+function nodeName( elem, name ) {\n+\n+\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n+\n+}\n+var rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n+\n+\n+\n+// Implement the identical functionality for filter and not\n+function winnow( elements, qualifier, not ) {\n+\tif ( isFunction( qualifier ) ) {\n+\t\treturn jQuery.grep( elements, function( elem, i ) {\n+\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n+\t\t} );\n+\t}\n+\n+\t// Single element\n+\tif ( qualifier.nodeType ) {\n+\t\treturn jQuery.grep( elements, function( elem ) {\n+\t\t\treturn ( elem === qualifier ) !== not;\n+\t\t} );\n+\t}\n+\n+\t// Arraylike of elements (jQuery, arguments, Array)\n+\tif ( typeof qualifier !== \"string\" ) {\n+\t\treturn jQuery.grep( elements, function( elem ) {\n+\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n+\t\t} );\n+\t}\n+\n+\t// Filtered directly for both simple and complex selectors\n+\treturn jQuery.filter( qualifier, elements, not );\n+}\n+\n+jQuery.filter = function( expr, elems, not ) {\n+\tvar elem = elems[ 0 ];\n+\n+\tif ( not ) {\n+\t\texpr = \":not(\" + expr + \")\";\n+\t}\n+\n+\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n+\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n+\t}\n+\n+\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n+\t\treturn elem.nodeType === 1;\n+\t} ) );\n+};\n+\n+jQuery.fn.extend( {\n+\tfind: function( selector ) {\n+\t\tvar i, ret,\n+\t\t\tlen = this.length,\n+\t\t\tself = this;\n+\n+\t\tif ( typeof selector !== \"string\" ) {\n+\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n+\t\t\t\tfor ( i = 0; i < len; i++ ) {\n+\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} ) );\n+\t\t}\n+\n+\t\tret = this.pushStack( [] );\n+\n+\t\tfor ( i = 0; i < len; i++ ) {\n+\t\t\tjQuery.find( selector, self[ i ], ret );\n+\t\t}\n+\n+\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n+\t},\n+\tfilter: function( selector ) {\n+\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n+\t},\n+\tnot: function( selector ) {\n+\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n+\t},\n+\tis: function( selector ) {\n+\t\treturn !!winnow(\n+\t\t\tthis,\n+\n+\t\t\t// If this is a positional/relative selector, check membership in the returned set\n+\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n+\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n+\t\t\t\tjQuery( selector ) :\n+\t\t\t\tselector || [],\n+\t\t\tfalse\n+\t\t).length;\n+\t}\n+} );\n+\n+\n+// Initialize a jQuery object\n+\n+\n+// A central reference to the root jQuery(document)\n+var rootjQuery,\n+\n+\t// A simple way to check for HTML strings\n+\t// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n+\t// Strict HTML recognition (trac-11290: must start with <)\n+\t// Shortcut simple #id case for speed\n+\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n+\n+\tinit = jQuery.fn.init = function( selector, context, root ) {\n+\t\tvar match, elem;\n+\n+\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n+\t\tif ( !selector ) {\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\t// Method init() accepts an alternate rootjQuery\n+\t\t// so migrate can support jQuery.sub (gh-2101)\n+\t\troot = root || rootjQuery;\n+\n+\t\t// Handle HTML strings\n+\t\tif ( typeof selector === \"string\" ) {\n+\t\t\tif ( selector[ 0 ] === \"<\" &&\n+\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n+\t\t\t\tselector.length >= 3 ) {\n+\n+\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n+\t\t\t\tmatch = [ null, selector, null ];\n+\n+\t\t\t} else {\n+\t\t\t\tmatch = rquickExpr.exec( selector );\n+\t\t\t}\n+\n+\t\t\t// Match html or make sure no context is specified for #id\n+\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n+\n+\t\t\t\t// HANDLE: $(html) -> $(array)\n+\t\t\t\tif ( match[ 1 ] ) {\n+\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n+\n+\t\t\t\t\t// Option to run scripts is true for back-compat\n+\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n+\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n+\t\t\t\t\t\tmatch[ 1 ],\n+\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n+\t\t\t\t\t\ttrue\n+\t\t\t\t\t) );\n+\n+\t\t\t\t\t// HANDLE: $(html, props)\n+\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n+\t\t\t\t\t\tfor ( match in context ) {\n+\n+\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n+\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n+\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n+\n+\t\t\t\t\t\t\t// ...and otherwise set as attributes\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn this;\n+\n+\t\t\t\t// HANDLE: $(#id)\n+\t\t\t\t} else {\n+\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n+\n+\t\t\t\t\tif ( elem ) {\n+\n+\t\t\t\t\t\t// Inject the element directly into the jQuery object\n+\t\t\t\t\t\tthis[ 0 ] = elem;\n+\t\t\t\t\t\tthis.length = 1;\n+\t\t\t\t\t}\n+\t\t\t\t\treturn this;\n+\t\t\t\t}\n+\n+\t\t\t// HANDLE: $(expr, $(...))\n+\t\t\t} else if ( !context || context.jquery ) {\n+\t\t\t\treturn ( context || root ).find( selector );\n+\n+\t\t\t// HANDLE: $(expr, context)\n+\t\t\t// (which is just equivalent to: $(context).find(expr)\n+\t\t\t} else {\n+\t\t\t\treturn this.constructor( context ).find( selector );\n+\t\t\t}\n+\n+\t\t// HANDLE: $(DOMElement)\n+\t\t} else if ( selector.nodeType ) {\n+\t\t\tthis[ 0 ] = selector;\n+\t\t\tthis.length = 1;\n+\t\t\treturn this;\n+\n+\t\t// HANDLE: $(function)\n+\t\t// Shortcut for document ready\n+\t\t} else if ( isFunction( selector ) ) {\n+\t\t\treturn root.ready !== undefined ?\n+\t\t\t\troot.ready( selector ) :\n+\n+\t\t\t\t// Execute immediately if ready is not present\n+\t\t\t\tselector( jQuery );\n+\t\t}\n+\n+\t\treturn jQuery.makeArray( selector, this );\n+\t};\n+\n+// Give the init function the jQuery prototype for later instantiation\n+init.prototype = jQuery.fn;\n+\n+// Initialize central reference\n+rootjQuery = jQuery( document );\n+\n+\n+var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n+\n+\t// Methods guaranteed to produce a unique set when starting from a unique set\n+\tguaranteedUnique = {\n+\t\tchildren: true,\n+\t\tcontents: true,\n+\t\tnext: true,\n+\t\tprev: true\n+\t};\n+\n+jQuery.fn.extend( {\n+\thas: function( target ) {\n+\t\tvar targets = jQuery( target, this ),\n+\t\t\tl = targets.length;\n+\n+\t\treturn this.filter( function() {\n+\t\t\tvar i = 0;\n+\t\t\tfor ( ; i < l; i++ ) {\n+\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\tclosest: function( selectors, context ) {\n+\t\tvar cur,\n+\t\t\ti = 0,\n+\t\t\tl = this.length,\n+\t\t\tmatched = [],\n+\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n+\n+\t\t// Positional selectors never match, since there's no _selection_ context\n+\t\tif ( !rneedsContext.test( selectors ) ) {\n+\t\t\tfor ( ; i < l; i++ ) {\n+\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n+\n+\t\t\t\t\t// Always skip document fragments\n+\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n+\t\t\t\t\t\ttargets.index( cur ) > -1 :\n+\n+\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n+\t\t\t\t\t\tcur.nodeType === 1 &&\n+\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n+\n+\t\t\t\t\t\tmatched.push( cur );\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n+\t},\n+\n+\t// Determine the position of an element within the set\n+\tindex: function( elem ) {\n+\n+\t\t// No argument, return index in parent\n+\t\tif ( !elem ) {\n+\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n+\t\t}\n+\n+\t\t// Index in selector\n+\t\tif ( typeof elem === \"string\" ) {\n+\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n+\t\t}\n+\n+\t\t// Locate the position of the desired element\n+\t\treturn indexOf.call( this,\n+\n+\t\t\t// If it receives a jQuery object, the first element is used\n+\t\t\telem.jquery ? elem[ 0 ] : elem\n+\t\t);\n+\t},\n+\n+\tadd: function( selector, context ) {\n+\t\treturn this.pushStack(\n+\t\t\tjQuery.uniqueSort(\n+\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n+\t\t\t)\n+\t\t);\n+\t},\n+\n+\taddBack: function( selector ) {\n+\t\treturn this.add( selector == null ?\n+\t\t\tthis.prevObject : this.prevObject.filter( selector )\n+\t\t);\n+\t}\n+} );\n+\n+function sibling( cur, dir ) {\n+\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n+\treturn cur;\n+}\n+\n+jQuery.each( {\n+\tparent: function( elem ) {\n+\t\tvar parent = elem.parentNode;\n+\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n+\t},\n+\tparents: function( elem ) {\n+\t\treturn dir( elem, \"parentNode\" );\n+\t},\n+\tparentsUntil: function( elem, _i, until ) {\n+\t\treturn dir( elem, \"parentNode\", until );\n+\t},\n+\tnext: function( elem ) {\n+\t\treturn sibling( elem, \"nextSibling\" );\n+\t},\n+\tprev: function( elem ) {\n+\t\treturn sibling( elem, \"previousSibling\" );\n+\t},\n+\tnextAll: function( elem ) {\n+\t\treturn dir( elem, \"nextSibling\" );\n+\t},\n+\tprevAll: function( elem ) {\n+\t\treturn dir( elem, \"previousSibling\" );\n+\t},\n+\tnextUntil: function( elem, _i, until ) {\n+\t\treturn dir( elem, \"nextSibling\", until );\n+\t},\n+\tprevUntil: function( elem, _i, until ) {\n+\t\treturn dir( elem, \"previousSibling\", until );\n+\t},\n+\tsiblings: function( elem ) {\n+\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n+\t},\n+\tchildren: function( elem ) {\n+\t\treturn siblings( elem.firstChild );\n+\t},\n+\tcontents: function( elem ) {\n+\t\tif ( elem.contentDocument != null &&\n+\n+\t\t\t// Support: IE 11+\n+\t\t\t// <object> elements with no `data` attribute has an object\n+\t\t\t// `contentDocument` with a `null` prototype.\n+\t\t\tgetProto( elem.contentDocument ) ) {\n+\n+\t\t\treturn elem.contentDocument;\n+\t\t}\n+\n+\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n+\t\t// Treat the template element as a regular one in browsers that\n+\t\t// don't support it.\n+\t\tif ( nodeName( elem, \"template\" ) ) {\n+\t\t\telem = elem.content || elem;\n+\t\t}\n+\n+\t\treturn jQuery.merge( [], elem.childNodes );\n+\t}\n+}, function( name, fn ) {\n+\tjQuery.fn[ name ] = function( until, selector ) {\n+\t\tvar matched = jQuery.map( this, fn, until );\n+\n+\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n+\t\t\tselector = until;\n+\t\t}\n+\n+\t\tif ( selector && typeof selector === \"string\" ) {\n+\t\t\tmatched = jQuery.filter( selector, matched );\n+\t\t}\n+\n+\t\tif ( this.length > 1 ) {\n+\n+\t\t\t// Remove duplicates\n+\t\t\tif ( !guaranteedUnique[ name ] ) {\n+\t\t\t\tjQuery.uniqueSort( matched );\n+\t\t\t}\n+\n+\t\t\t// Reverse order for parents* and prev-derivatives\n+\t\t\tif ( rparentsprev.test( name ) ) {\n+\t\t\t\tmatched.reverse();\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn this.pushStack( matched );\n+\t};\n+} );\n+var rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n+\n+\n+\n+// Convert String-formatted options into Object-formatted ones\n+function createOptions( options ) {\n+\tvar object = {};\n+\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n+\t\tobject[ flag ] = true;\n+\t} );\n+\treturn object;\n+}\n+\n+/*\n+ * Create a callback list using the following parameters:\n+ *\n+ *\toptions: an optional list of space-separated options that will change how\n+ *\t\t\tthe callback list behaves or a more traditional option object\n+ *\n+ * By default a callback list will act like an event callback list and can be\n+ * \"fired\" multiple times.\n+ *\n+ * Possible options:\n+ *\n+ *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n+ *\n+ *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n+ *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n+ *\t\t\t\t\tvalues (like a Deferred)\n+ *\n+ *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n+ *\n+ *\tstopOnFalse:\tinterrupt callings when a callback returns false\n+ *\n+ */\n+jQuery.Callbacks = function( options ) {\n+\n+\t// Convert options from String-formatted to Object-formatted if needed\n+\t// (we check in cache first)\n+\toptions = typeof options === \"string\" ?\n+\t\tcreateOptions( options ) :\n+\t\tjQuery.extend( {}, options );\n+\n+\tvar // Flag to know if list is currently firing\n+\t\tfiring,\n+\n+\t\t// Last fire value for non-forgettable lists\n+\t\tmemory,\n+\n+\t\t// Flag to know if list was already fired\n+\t\tfired,\n+\n+\t\t// Flag to prevent firing\n+\t\tlocked,\n+\n+\t\t// Actual callback list\n+\t\tlist = [],\n+\n+\t\t// Queue of execution data for repeatable lists\n+\t\tqueue = [],\n+\n+\t\t// Index of currently firing callback (modified by add/remove as needed)\n+\t\tfiringIndex = -1,\n+\n+\t\t// Fire callbacks\n+\t\tfire = function() {\n+\n+\t\t\t// Enforce single-firing\n+\t\t\tlocked = locked || options.once;\n+\n+\t\t\t// Execute callbacks for all pending executions,\n+\t\t\t// respecting firingIndex overrides and runtime changes\n+\t\t\tfired = firing = true;\n+\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n+\t\t\t\tmemory = queue.shift();\n+\t\t\t\twhile ( ++firingIndex < list.length ) {\n+\n+\t\t\t\t\t// Run callback and check for early termination\n+\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n+\t\t\t\t\t\toptions.stopOnFalse ) {\n+\n+\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n+\t\t\t\t\t\tfiringIndex = list.length;\n+\t\t\t\t\t\tmemory = false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Forget the data if we're done with it\n+\t\t\tif ( !options.memory ) {\n+\t\t\t\tmemory = false;\n+\t\t\t}\n+\n+\t\t\tfiring = false;\n+\n+\t\t\t// Clean up if we're done firing for good\n+\t\t\tif ( locked ) {\n+\n+\t\t\t\t// Keep an empty list if we have data for future add calls\n+\t\t\t\tif ( memory ) {\n+\t\t\t\t\tlist = [];\n+\n+\t\t\t\t// Otherwise, this object is spent\n+\t\t\t\t} else {\n+\t\t\t\t\tlist = \"\";\n+\t\t\t\t}\n+\t\t\t}\n+\t\t},\n+\n+\t\t// Actual Callbacks object\n+\t\tself = {\n+\n+\t\t\t// Add a callback or a collection of callbacks to the list\n+\t\t\tadd: function() {\n+\t\t\t\tif ( list ) {\n+\n+\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n+\t\t\t\t\tif ( memory && !firing ) {\n+\t\t\t\t\t\tfiringIndex = list.length - 1;\n+\t\t\t\t\t\tqueue.push( memory );\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t( function add( args ) {\n+\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n+\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n+\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n+\t\t\t\t\t\t\t\t\tlist.push( arg );\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n+\n+\t\t\t\t\t\t\t\t// Inspect recursively\n+\t\t\t\t\t\t\t\tadd( arg );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} );\n+\t\t\t\t\t} )( arguments );\n+\n+\t\t\t\t\tif ( memory && !firing ) {\n+\t\t\t\t\t\tfire();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn this;\n+\t\t\t},\n+\n+\t\t\t// Remove a callback from the list\n+\t\t\tremove: function() {\n+\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n+\t\t\t\t\tvar index;\n+\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n+\t\t\t\t\t\tlist.splice( index, 1 );\n+\n+\t\t\t\t\t\t// Handle firing indexes\n+\t\t\t\t\t\tif ( index <= firingIndex ) {\n+\t\t\t\t\t\t\tfiringIndex--;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} );\n+\t\t\t\treturn this;\n+\t\t\t},\n+\n+\t\t\t// Check if a given callback is in the list.\n+\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n+\t\t\thas: function( fn ) {\n+\t\t\t\treturn fn ?\n+\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n+\t\t\t\t\tlist.length > 0;\n+\t\t\t},\n+\n+\t\t\t// Remove all callbacks from the list\n+\t\t\tempty: function() {\n+\t\t\t\tif ( list ) {\n+\t\t\t\t\tlist = [];\n+\t\t\t\t}\n+\t\t\t\treturn this;\n+\t\t\t},\n+\n+\t\t\t// Disable .fire and .add\n+\t\t\t// Abort any current/pending executions\n+\t\t\t// Clear all callbacks and values\n+\t\t\tdisable: function() {\n+\t\t\t\tlocked = queue = [];\n+\t\t\t\tlist = memory = \"\";\n+\t\t\t\treturn this;\n+\t\t\t},\n+\t\t\tdisabled: function() {\n+\t\t\t\treturn !list;\n+\t\t\t},\n+\n+\t\t\t// Disable .fire\n+\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n+\t\t\t// Abort any pending executions\n+\t\t\tlock: function() {\n+\t\t\t\tlocked = queue = [];\n+\t\t\t\tif ( !memory && !firing ) {\n+\t\t\t\t\tlist = memory = \"\";\n+\t\t\t\t}\n+\t\t\t\treturn this;\n+\t\t\t},\n+\t\t\tlocked: function() {\n+\t\t\t\treturn !!locked;\n+\t\t\t},\n+\n+\t\t\t// Call all callbacks with the given context and arguments\n+\t\t\tfireWith: function( context, args ) {\n+\t\t\t\tif ( !locked ) {\n+\t\t\t\t\targs = args || [];\n+\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n+\t\t\t\t\tqueue.push( args );\n+\t\t\t\t\tif ( !firing ) {\n+\t\t\t\t\t\tfire();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn this;\n+\t\t\t},\n+\n+\t\t\t// Call all the callbacks with the given arguments\n+\t\t\tfire: function() {\n+\t\t\t\tself.fireWith( this, arguments );\n+\t\t\t\treturn this;\n+\t\t\t},\n+\n+\t\t\t// To know if the callbacks have already been called at least once\n+\t\t\tfired: function() {\n+\t\t\t\treturn !!fired;\n+\t\t\t}\n+\t\t};\n+\n+\treturn self;\n+};\n+\n+\n+function Identity( v ) {\n+\treturn v;\n+}\n+function Thrower( ex ) {\n+\tthrow ex;\n+}\n+\n+function adoptValue( value, resolve, reject, noValue ) {\n+\tvar method;\n+\n+\ttry {\n+\n+\t\t// Check for promise aspect first to privilege synchronous behavior\n+\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n+\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n+\n+\t\t// Other thenables\n+\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n+\t\t\tmethod.call( value, resolve, reject );\n+\n+\t\t// Other non-thenables\n+\t\t} else {\n+\n+\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n+\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n+\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n+\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n+\t\t}\n+\n+\t// For Promises/A+, convert exceptions into rejections\n+\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n+\t// Deferred#then to conditionally suppress rejection.\n+\t} catch ( value ) {\n+\n+\t\t// Support: Android 4.0 only\n+\t\t// Strict mode functions invoked without .call/.apply get global-object context\n+\t\treject.apply( undefined, [ value ] );\n+\t}\n+}\n+\n+jQuery.extend( {\n+\n+\tDeferred: function( func ) {\n+\t\tvar tuples = [\n+\n+\t\t\t\t// action, add listener, callbacks,\n+\t\t\t\t// ... .then handlers, argument index, [final state]\n+\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n+\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n+\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n+\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n+\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n+\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n+\t\t\t],\n+\t\t\tstate = \"pending\",\n+\t\t\tpromise = {\n+\t\t\t\tstate: function() {\n+\t\t\t\t\treturn state;\n+\t\t\t\t},\n+\t\t\t\talways: function() {\n+\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n+\t\t\t\t\treturn this;\n+\t\t\t\t},\n+\t\t\t\t\"catch\": function( fn ) {\n+\t\t\t\t\treturn promise.then( null, fn );\n+\t\t\t\t},\n+\n+\t\t\t\t// Keep pipe for back-compat\n+\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n+\t\t\t\t\tvar fns = arguments;\n+\n+\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n+\t\t\t\t\t\tjQuery.each( tuples, function( _i, tuple ) {\n+\n+\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n+\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n+\n+\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n+\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n+\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n+\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n+\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n+\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n+\t\t\t\t\t\t\t\t\treturned.promise()\n+\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n+\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n+\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n+\t\t\t\t\t\t\t\t\t\tthis,\n+\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n+\t\t\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} );\n+\t\t\t\t\t\t} );\n+\t\t\t\t\t\tfns = null;\n+\t\t\t\t\t} ).promise();\n+\t\t\t\t},\n+\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n+\t\t\t\t\tvar maxDepth = 0;\n+\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n+\t\t\t\t\t\treturn function() {\n+\t\t\t\t\t\t\tvar that = this,\n+\t\t\t\t\t\t\t\targs = arguments,\n+\t\t\t\t\t\t\t\tmightThrow = function() {\n+\t\t\t\t\t\t\t\t\tvar returned, then;\n+\n+\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n+\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n+\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n+\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n+\t\t\t\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n+\n+\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n+\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n+\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n+\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n+\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n+\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n+\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n+\t\t\t\t\t\t\t\t\tthen = returned &&\n+\n+\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n+\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n+\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n+\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n+\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n+\t\t\t\t\t\t\t\t\t\treturned.then;\n+\n+\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n+\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n+\n+\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n+\t\t\t\t\t\t\t\t\t\tif ( special ) {\n+\t\t\t\t\t\t\t\t\t\t\tthen.call(\n+\t\t\t\t\t\t\t\t\t\t\t\treturned,\n+\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n+\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n+\t\t\t\t\t\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n+\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n+\n+\t\t\t\t\t\t\t\t\t\t\tthen.call(\n+\t\t\t\t\t\t\t\t\t\t\t\treturned,\n+\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n+\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n+\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n+\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n+\t\t\t\t\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t// Handle all other returned values\n+\t\t\t\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n+\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n+\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n+\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n+\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n+\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n+\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n+\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t},\n+\n+\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n+\t\t\t\t\t\t\t\tprocess = special ?\n+\t\t\t\t\t\t\t\t\tmightThrow :\n+\t\t\t\t\t\t\t\t\tfunction() {\n+\t\t\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n+\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n+\n+\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n+\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n+\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n+\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n+\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n+\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n+\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n+\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n+\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t};\n+\n+\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n+\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n+\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n+\t\t\t\t\t\t\t// subsequent errors\n+\t\t\t\t\t\t\tif ( depth ) {\n+\t\t\t\t\t\t\t\tprocess();\n+\t\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n+\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n+\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n+\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\twindow.setTimeout( process );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t};\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n+\n+\t\t\t\t\t\t// progress_handlers.add( ... )\n+\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n+\t\t\t\t\t\t\tresolve(\n+\t\t\t\t\t\t\t\t0,\n+\t\t\t\t\t\t\t\tnewDefer,\n+\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n+\t\t\t\t\t\t\t\t\tonProgress :\n+\t\t\t\t\t\t\t\t\tIdentity,\n+\t\t\t\t\t\t\t\tnewDefer.notifyWith\n+\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n+\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n+\t\t\t\t\t\t\tresolve(\n+\t\t\t\t\t\t\t\t0,\n+\t\t\t\t\t\t\t\tnewDefer,\n+\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n+\t\t\t\t\t\t\t\t\tonFulfilled :\n+\t\t\t\t\t\t\t\t\tIdentity\n+\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t// rejected_handlers.add( ... )\n+\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n+\t\t\t\t\t\t\tresolve(\n+\t\t\t\t\t\t\t\t0,\n+\t\t\t\t\t\t\t\tnewDefer,\n+\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n+\t\t\t\t\t\t\t\t\tonRejected :\n+\t\t\t\t\t\t\t\t\tThrower\n+\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t);\n+\t\t\t\t\t} ).promise();\n+\t\t\t\t},\n+\n+\t\t\t\t// Get a promise for this deferred\n+\t\t\t\t// If obj is provided, the promise aspect is added to the object\n+\t\t\t\tpromise: function( obj ) {\n+\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\tdeferred = {};\n+\n+\t\t// Add list-specific methods\n+\t\tjQuery.each( tuples, function( i, tuple ) {\n+\t\t\tvar list = tuple[ 2 ],\n+\t\t\t\tstateString = tuple[ 5 ];\n+\n+\t\t\t// promise.progress = list.add\n+\t\t\t// promise.done = list.add\n+\t\t\t// promise.fail = list.add\n+\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n+\n+\t\t\t// Handle state\n+\t\t\tif ( stateString ) {\n+\t\t\t\tlist.add(\n+\t\t\t\t\tfunction() {\n+\n+\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n+\t\t\t\t\t\t// state = \"rejected\"\n+\t\t\t\t\t\tstate = stateString;\n+\t\t\t\t\t},\n+\n+\t\t\t\t\t// rejected_callbacks.disable\n+\t\t\t\t\t// fulfilled_callbacks.disable\n+\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n+\n+\t\t\t\t\t// rejected_handlers.disable\n+\t\t\t\t\t// fulfilled_handlers.disable\n+\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n+\n+\t\t\t\t\t// progress_callbacks.lock\n+\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n+\n+\t\t\t\t\t// progress_handlers.lock\n+\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n+\t\t\t\t);\n+\t\t\t}\n+\n+\t\t\t// progress_handlers.fire\n+\t\t\t// fulfilled_handlers.fire\n+\t\t\t// rejected_handlers.fire\n+\t\t\tlist.add( tuple[ 3 ].fire );\n+\n+\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n+\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n+\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n+\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n+\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n+\t\t\t\treturn this;\n+\t\t\t};\n+\n+\t\t\t// deferred.notifyWith = list.fireWith\n+\t\t\t// deferred.resolveWith = list.fireWith\n+\t\t\t// deferred.rejectWith = list.fireWith\n+\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n+\t\t} );\n+\n+\t\t// Make the deferred a promise\n+\t\tpromise.promise( deferred );\n+\n+\t\t// Call given func if any\n+\t\tif ( func ) {\n+\t\t\tfunc.call( deferred, deferred );\n+\t\t}\n+\n+\t\t// All done!\n+\t\treturn deferred;\n+\t},\n+\n+\t// Deferred helper\n+\twhen: function( singleValue ) {\n+\t\tvar\n+\n+\t\t\t// count of uncompleted subordinates\n+\t\t\tremaining = arguments.length,\n+\n+\t\t\t// count of unprocessed arguments\n+\t\t\ti = remaining,\n+\n+\t\t\t// subordinate fulfillment data\n+\t\t\tresolveContexts = Array( i ),\n+\t\t\tresolveValues = slice.call( arguments ),\n+\n+\t\t\t// the primary Deferred\n+\t\t\tprimary = jQuery.Deferred(),\n+\n+\t\t\t// subordinate callback factory\n+\t\t\tupdateFunc = function( i ) {\n+\t\t\t\treturn function( value ) {\n+\t\t\t\t\tresolveContexts[ i ] = this;\n+\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n+\t\t\t\t\tif ( !( --remaining ) ) {\n+\t\t\t\t\t\tprimary.resolveWith( resolveContexts, resolveValues );\n+\t\t\t\t\t}\n+\t\t\t\t};\n+\t\t\t};\n+\n+\t\t// Single- and empty arguments are adopted like Promise.resolve\n+\t\tif ( remaining <= 1 ) {\n+\t\t\tadoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,\n+\t\t\t\t!remaining );\n+\n+\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n+\t\t\tif ( primary.state() === \"pending\" ||\n+\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n+\n+\t\t\t\treturn primary.then();\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Multiple arguments are aggregated like Promise.all array elements\n+\t\twhile ( i-- ) {\n+\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );\n+\t\t}\n+\n+\t\treturn primary.promise();\n+\t}\n+} );\n+\n+\n+// These usually indicate a programmer mistake during development,\n+// warn about them ASAP rather than swallowing them by default.\n+var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n+\n+jQuery.Deferred.exceptionHook = function( error, stack ) {\n+\n+\t// Support: IE 8 - 9 only\n+\t// Console exists when dev tools are open, which can happen at any time\n+\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n+\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n+\t}\n+};\n+\n+\n+\n+\n+jQuery.readyException = function( error ) {\n+\twindow.setTimeout( function() {\n+\t\tthrow error;\n+\t} );\n+};\n+\n+\n+\n+\n+// The deferred used on DOM ready\n+var readyList = jQuery.Deferred();\n+\n+jQuery.fn.ready = function( fn ) {\n+\n+\treadyList\n+\t\t.then( fn )\n+\n+\t\t// Wrap jQuery.readyException in a function so that the lookup\n+\t\t// happens at the time of error handling instead of callback\n+\t\t// registration.\n+\t\t.catch( function( error ) {\n+\t\t\tjQuery.readyException( error );\n+\t\t} );\n+\n+\treturn this;\n+};\n+\n+jQuery.extend( {\n+\n+\t// Is the DOM ready to be used? Set to true once it occurs.\n+\tisReady: false,\n+\n+\t// A counter to track how many items to wait for before\n+\t// the ready event fires. See trac-6781\n+\treadyWait: 1,\n+\n+\t// Handle when the DOM is ready\n+\tready: function( wait ) {\n+\n+\t\t// Abort if there are pending holds or we're already ready\n+\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Remember that the DOM is ready\n+\t\tjQuery.isReady = true;\n+\n+\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n+\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// If there are functions bound, to execute\n+\t\treadyList.resolveWith( document, [ jQuery ] );\n+\t}\n+} );\n+\n+jQuery.ready.then = readyList.then;\n+\n+// The ready event handler and self cleanup method\n+function completed() {\n+\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n+\twindow.removeEventListener( \"load\", completed );\n+\tjQuery.ready();\n+}\n+\n+// Catch cases where $(document).ready() is called\n+// after the browser event has already occurred.\n+// Support: IE <=9 - 10 only\n+// Older IE sometimes signals \"interactive\" too soon\n+if ( document.readyState === \"complete\" ||\n+\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n+\n+\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n+\twindow.setTimeout( jQuery.ready );\n+\n+} else {\n+\n+\t// Use the handy event callback\n+\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n+\n+\t// A fallback to window.onload, that will always work\n+\twindow.addEventListener( \"load\", completed );\n+}\n+\n+\n+\n+\n+// Multifunctional method to get and set values of a collection\n+// The value/s can optionally be executed if it's a function\n+var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n+\tvar i = 0,\n+\t\tlen = elems.length,\n+\t\tbulk = key == null;\n+\n+\t// Sets many values\n+\tif ( toType( key ) === \"object\" ) {\n+\t\tchainable = true;\n+\t\tfor ( i in key ) {\n+\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n+\t\t}\n+\n+\t// Sets one value\n+\t} else if ( value !== undefined ) {\n+\t\tchainable = true;\n+\n+\t\tif ( !isFunction( value ) ) {\n+\t\t\traw = true;\n+\t\t}\n+\n+\t\tif ( bulk ) {\n+\n+\t\t\t// Bulk operations run against the entire set\n+\t\t\tif ( raw ) {\n+\t\t\t\tfn.call( elems, value );\n+\t\t\t\tfn = null;\n+\n+\t\t\t// ...except when executing function values\n+\t\t\t} else {\n+\t\t\t\tbulk = fn;\n+\t\t\t\tfn = function( elem, _key, value ) {\n+\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n+\t\t\t\t};\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ( fn ) {\n+\t\t\tfor ( ; i < len; i++ ) {\n+\t\t\t\tfn(\n+\t\t\t\t\telems[ i ], key, raw ?\n+\t\t\t\t\t\tvalue :\n+\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n+\t\t\t\t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif ( chainable ) {\n+\t\treturn elems;\n+\t}\n+\n+\t// Gets\n+\tif ( bulk ) {\n+\t\treturn fn.call( elems );\n+\t}\n+\n+\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n+};\n+\n+\n+// Matches dashed string for camelizing\n+var rmsPrefix = /^-ms-/,\n+\trdashAlpha = /-([a-z])/g;\n+\n+// Used by camelCase as callback to replace()\n+function fcamelCase( _all, letter ) {\n+\treturn letter.toUpperCase();\n+}\n+\n+// Convert dashed to camelCase; used by the css and data modules\n+// Support: IE <=9 - 11, Edge 12 - 15\n+// Microsoft forgot to hump their vendor prefix (trac-9572)\n+function camelCase( string ) {\n+\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n+}\n+var acceptData = function( owner ) {\n+\n+\t// Accepts only:\n+\t//  - Node\n+\t//    - Node.ELEMENT_NODE\n+\t//    - Node.DOCUMENT_NODE\n+\t//  - Object\n+\t//    - Any\n+\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n+};\n+\n+\n+\n+\n+function Data() {\n+\tthis.expando = jQuery.expando + Data.uid++;\n+}\n+\n+Data.uid = 1;\n+\n+Data.prototype = {\n+\n+\tcache: function( owner ) {\n+\n+\t\t// Check if the owner object already has a cache\n+\t\tvar value = owner[ this.expando ];\n+\n+\t\t// If not, create one\n+\t\tif ( !value ) {\n+\t\t\tvalue = {};\n+\n+\t\t\t// We can accept data for non-element nodes in modern browsers,\n+\t\t\t// but we should not, see trac-8335.\n+\t\t\t// Always return an empty object.\n+\t\t\tif ( acceptData( owner ) ) {\n+\n+\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n+\t\t\t\t// use plain assignment\n+\t\t\t\tif ( owner.nodeType ) {\n+\t\t\t\t\towner[ this.expando ] = value;\n+\n+\t\t\t\t// Otherwise secure it in a non-enumerable property\n+\t\t\t\t// configurable must be true to allow the property to be\n+\t\t\t\t// deleted when data is removed\n+\t\t\t\t} else {\n+\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n+\t\t\t\t\t\tvalue: value,\n+\t\t\t\t\t\tconfigurable: true\n+\t\t\t\t\t} );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn value;\n+\t},\n+\tset: function( owner, data, value ) {\n+\t\tvar prop,\n+\t\t\tcache = this.cache( owner );\n+\n+\t\t// Handle: [ owner, key, value ] args\n+\t\t// Always use camelCase key (gh-2257)\n+\t\tif ( typeof data === \"string\" ) {\n+\t\t\tcache[ camelCase( data ) ] = value;\n+\n+\t\t// Handle: [ owner, { properties } ] args\n+\t\t} else {\n+\n+\t\t\t// Copy the properties one-by-one to the cache object\n+\t\t\tfor ( prop in data ) {\n+\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n+\t\t\t}\n+\t\t}\n+\t\treturn cache;\n+\t},\n+\tget: function( owner, key ) {\n+\t\treturn key === undefined ?\n+\t\t\tthis.cache( owner ) :\n+\n+\t\t\t// Always use camelCase key (gh-2257)\n+\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n+\t},\n+\taccess: function( owner, key, value ) {\n+\n+\t\t// In cases where either:\n+\t\t//\n+\t\t//   1. No key was specified\n+\t\t//   2. A string key was specified, but no value provided\n+\t\t//\n+\t\t// Take the \"read\" path and allow the get method to determine\n+\t\t// which value to return, respectively either:\n+\t\t//\n+\t\t//   1. The entire cache object\n+\t\t//   2. The data stored at the key\n+\t\t//\n+\t\tif ( key === undefined ||\n+\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n+\n+\t\t\treturn this.get( owner, key );\n+\t\t}\n+\n+\t\t// When the key is not a string, or both a key and value\n+\t\t// are specified, set or extend (existing objects) with either:\n+\t\t//\n+\t\t//   1. An object of properties\n+\t\t//   2. A key and value\n+\t\t//\n+\t\tthis.set( owner, key, value );\n+\n+\t\t// Since the \"set\" path can have two possible entry points\n+\t\t// return the expected data based on which path was taken[*]\n+\t\treturn value !== undefined ? value : key;\n+\t},\n+\tremove: function( owner, key ) {\n+\t\tvar i,\n+\t\t\tcache = owner[ this.expando ];\n+\n+\t\tif ( cache === undefined ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif ( key !== undefined ) {\n+\n+\t\t\t// Support array or space separated string of keys\n+\t\t\tif ( Array.isArray( key ) ) {\n+\n+\t\t\t\t// If key is an array of keys...\n+\t\t\t\t// We always set camelCase keys, so remove that.\n+\t\t\t\tkey = key.map( camelCase );\n+\t\t\t} else {\n+\t\t\t\tkey = camelCase( key );\n+\n+\t\t\t\t// If a key with the spaces exists, use it.\n+\t\t\t\t// Otherwise, create an array by matching non-whitespace\n+\t\t\t\tkey = key in cache ?\n+\t\t\t\t\t[ key ] :\n+\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n+\t\t\t}\n+\n+\t\t\ti = key.length;\n+\n+\t\t\twhile ( i-- ) {\n+\t\t\t\tdelete cache[ key[ i ] ];\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Remove the expando if there's no more data\n+\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n+\n+\t\t\t// Support: Chrome <=35 - 45\n+\t\t\t// Webkit & Blink performance suffers when deleting properties\n+\t\t\t// from DOM nodes, so set to undefined instead\n+\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n+\t\t\tif ( owner.nodeType ) {\n+\t\t\t\towner[ this.expando ] = undefined;\n+\t\t\t} else {\n+\t\t\t\tdelete owner[ this.expando ];\n+\t\t\t}\n+\t\t}\n+\t},\n+\thasData: function( owner ) {\n+\t\tvar cache = owner[ this.expando ];\n+\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n+\t}\n+};\n+var dataPriv = new Data();\n+\n+var dataUser = new Data();\n+\n+\n+\n+//\tImplementation Summary\n+//\n+//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n+//\t2. Improve the module's maintainability by reducing the storage\n+//\t\tpaths to a single mechanism.\n+//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n+//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n+//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n+//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n+\n+var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n+\trmultiDash = /[A-Z]/g;\n+\n+function getData( data ) {\n+\tif ( data === \"true\" ) {\n+\t\treturn true;\n+\t}\n+\n+\tif ( data === \"false\" ) {\n+\t\treturn false;\n+\t}\n+\n+\tif ( data === \"null\" ) {\n+\t\treturn null;\n+\t}\n+\n+\t// Only convert to a number if it doesn't change the string\n+\tif ( data === +data + \"\" ) {\n+\t\treturn +data;\n+\t}\n+\n+\tif ( rbrace.test( data ) ) {\n+\t\treturn JSON.parse( data );\n+\t}\n+\n+\treturn data;\n+}\n+\n+function dataAttr( elem, key, data ) {\n+\tvar name;\n+\n+\t// If nothing was found internally, try to fetch any\n+\t// data from the HTML5 data-* attribute\n+\tif ( data === undefined && elem.nodeType === 1 ) {\n+\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n+\t\tdata = elem.getAttribute( name );\n+\n+\t\tif ( typeof data === \"string\" ) {\n+\t\t\ttry {\n+\t\t\t\tdata = getData( data );\n+\t\t\t} catch ( e ) {}\n+\n+\t\t\t// Make sure we set the data so it isn't changed later\n+\t\t\tdataUser.set( elem, key, data );\n+\t\t} else {\n+\t\t\tdata = undefined;\n+\t\t}\n+\t}\n+\treturn data;\n+}\n+\n+jQuery.extend( {\n+\thasData: function( elem ) {\n+\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n+\t},\n+\n+\tdata: function( elem, name, data ) {\n+\t\treturn dataUser.access( elem, name, data );\n+\t},\n+\n+\tremoveData: function( elem, name ) {\n+\t\tdataUser.remove( elem, name );\n+\t},\n+\n+\t// TODO: Now that all calls to _data and _removeData have been replaced\n+\t// with direct calls to dataPriv methods, these can be deprecated.\n+\t_data: function( elem, name, data ) {\n+\t\treturn dataPriv.access( elem, name, data );\n+\t},\n+\n+\t_removeData: function( elem, name ) {\n+\t\tdataPriv.remove( elem, name );\n+\t}\n+} );\n+\n+jQuery.fn.extend( {\n+\tdata: function( key, value ) {\n+\t\tvar i, name, data,\n+\t\t\telem = this[ 0 ],\n+\t\t\tattrs = elem && elem.attributes;\n+\n+\t\t// Gets all values\n+\t\tif ( key === undefined ) {\n+\t\t\tif ( this.length ) {\n+\t\t\t\tdata = dataUser.get( elem );\n+\n+\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n+\t\t\t\t\ti = attrs.length;\n+\t\t\t\t\twhile ( i-- ) {\n+\n+\t\t\t\t\t\t// Support: IE 11 only\n+\t\t\t\t\t\t// The attrs elements can be null (trac-14894)\n+\t\t\t\t\t\tif ( attrs[ i ] ) {\n+\t\t\t\t\t\t\tname = attrs[ i ].name;\n+\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n+\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n+\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn data;\n+\t\t}\n+\n+\t\t// Sets multiple values\n+\t\tif ( typeof key === \"object\" ) {\n+\t\t\treturn this.each( function() {\n+\t\t\t\tdataUser.set( this, key );\n+\t\t\t} );\n+\t\t}\n+\n+\t\treturn access( this, function( value ) {\n+\t\t\tvar data;\n+\n+\t\t\t// The calling jQuery object (element matches) is not empty\n+\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n+\t\t\t// `value` parameter was not undefined. An empty jQuery object\n+\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n+\t\t\t// throw an exception if an attempt to read a data cache is made.\n+\t\t\tif ( elem && value === undefined ) {\n+\n+\t\t\t\t// Attempt to get data from the cache\n+\t\t\t\t// The key will always be camelCased in Data\n+\t\t\t\tdata = dataUser.get( elem, key );\n+\t\t\t\tif ( data !== undefined ) {\n+\t\t\t\t\treturn data;\n+\t\t\t\t}\n+\n+\t\t\t\t// Attempt to \"discover\" the data in\n+\t\t\t\t// HTML5 custom data-* attrs\n+\t\t\t\tdata = dataAttr( elem, key );\n+\t\t\t\tif ( data !== undefined ) {\n+\t\t\t\t\treturn data;\n+\t\t\t\t}\n+\n+\t\t\t\t// We tried really hard, but the data doesn't exist.\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Set the data...\n+\t\t\tthis.each( function() {\n+\n+\t\t\t\t// We always store the camelCased key\n+\t\t\t\tdataUser.set( this, key, value );\n+\t\t\t} );\n+\t\t}, null, value, arguments.length > 1, null, true );\n+\t},\n+\n+\tremoveData: function( key ) {\n+\t\treturn this.each( function() {\n+\t\t\tdataUser.remove( this, key );\n+\t\t} );\n+\t}\n+} );\n+\n+\n+jQuery.extend( {\n+\tqueue: function( elem, type, data ) {\n+\t\tvar queue;\n+\n+\t\tif ( elem ) {\n+\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n+\t\t\tqueue = dataPriv.get( elem, type );\n+\n+\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n+\t\t\tif ( data ) {\n+\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n+\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n+\t\t\t\t} else {\n+\t\t\t\t\tqueue.push( data );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn queue || [];\n+\t\t}\n+\t},\n+\n+\tdequeue: function( elem, type ) {\n+\t\ttype = type || \"fx\";\n+\n+\t\tvar queue = jQuery.queue( elem, type ),\n+\t\t\tstartLength = queue.length,\n+\t\t\tfn = queue.shift(),\n+\t\t\thooks = jQuery._queueHooks( elem, type ),\n+\t\t\tnext = function() {\n+\t\t\t\tjQuery.dequeue( elem, type );\n+\t\t\t};\n+\n+\t\t// If the fx queue is dequeued, always remove the progress sentinel\n+\t\tif ( fn === \"inprogress\" ) {\n+\t\t\tfn = queue.shift();\n+\t\t\tstartLength--;\n+\t\t}\n+\n+\t\tif ( fn ) {\n+\n+\t\t\t// Add a progress sentinel to prevent the fx queue from being\n+\t\t\t// automatically dequeued\n+\t\t\tif ( type === \"fx\" ) {\n+\t\t\t\tqueue.unshift( \"inprogress\" );\n+\t\t\t}\n+\n+\t\t\t// Clear up the last queue stop function\n+\t\t\tdelete hooks.stop;\n+\t\t\tfn.call( elem, next, hooks );\n+\t\t}\n+\n+\t\tif ( !startLength && hooks ) {\n+\t\t\thooks.empty.fire();\n+\t\t}\n+\t},\n+\n+\t// Not public - generate a queueHooks object, or return the current one\n+\t_queueHooks: function( elem, type ) {\n+\t\tvar key = type + \"queueHooks\";\n+\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n+\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n+\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n+\t\t\t} )\n+\t\t} );\n+\t}\n+} );\n+\n+jQuery.fn.extend( {\n+\tqueue: function( type, data ) {\n+\t\tvar setter = 2;\n+\n+\t\tif ( typeof type !== \"string\" ) {\n+\t\t\tdata = type;\n+\t\t\ttype = \"fx\";\n+\t\t\tsetter--;\n+\t\t}\n+\n+\t\tif ( arguments.length < setter ) {\n+\t\t\treturn jQuery.queue( this[ 0 ], type );\n+\t\t}\n+\n+\t\treturn data === undefined ?\n+\t\t\tthis :\n+\t\t\tthis.each( function() {\n+\t\t\t\tvar queue = jQuery.queue( this, type, data );\n+\n+\t\t\t\t// Ensure a hooks for this queue\n+\t\t\t\tjQuery._queueHooks( this, type );\n+\n+\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n+\t\t\t\t\tjQuery.dequeue( this, type );\n+\t\t\t\t}\n+\t\t\t} );\n+\t},\n+\tdequeue: function( type ) {\n+\t\treturn this.each( function() {\n+\t\t\tjQuery.dequeue( this, type );\n+\t\t} );\n+\t},\n+\tclearQueue: function( type ) {\n+\t\treturn this.queue( type || \"fx\", [] );\n+\t},\n+\n+\t// Get a promise resolved when queues of a certain type\n+\t// are emptied (fx is the type by default)\n+\tpromise: function( type, obj ) {\n+\t\tvar tmp,\n+\t\t\tcount = 1,\n+\t\t\tdefer = jQuery.Deferred(),\n+\t\t\telements = this,\n+\t\t\ti = this.length,\n+\t\t\tresolve = function() {\n+\t\t\t\tif ( !( --count ) ) {\n+\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n+\t\t\t\t}\n+\t\t\t};\n+\n+\t\tif ( typeof type !== \"string\" ) {\n+\t\t\tobj = type;\n+\t\t\ttype = undefined;\n+\t\t}\n+\t\ttype = type || \"fx\";\n+\n+\t\twhile ( i-- ) {\n+\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n+\t\t\tif ( tmp && tmp.empty ) {\n+\t\t\t\tcount++;\n+\t\t\t\ttmp.empty.add( resolve );\n+\t\t\t}\n+\t\t}\n+\t\tresolve();\n+\t\treturn defer.promise( obj );\n+\t}\n+} );\n+var pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n+\n+var rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n+\n+\n+var cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n+\n+var documentElement = document.documentElement;\n+\n+\n+\n+\tvar isAttached = function( elem ) {\n+\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n+\t\t},\n+\t\tcomposed = { composed: true };\n+\n+\t// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n+\t// Check attachment across shadow DOM boundaries when possible (gh-3504)\n+\t// Support: iOS 10.0-10.2 only\n+\t// Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n+\t// leading to errors. We need to check for `getRootNode`.\n+\tif ( documentElement.getRootNode ) {\n+\t\tisAttached = function( elem ) {\n+\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n+\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n+\t\t};\n+\t}\n+var isHiddenWithinTree = function( elem, el ) {\n+\n+\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n+\t\t// in that case, element will be second argument\n+\t\telem = el || elem;\n+\n+\t\t// Inline style trumps all\n+\t\treturn elem.style.display === \"none\" ||\n+\t\t\telem.style.display === \"\" &&\n+\n+\t\t\t// Otherwise, check computed style\n+\t\t\t// Support: Firefox <=43 - 45\n+\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n+\t\t\t// in the document.\n+\t\t\tisAttached( elem ) &&\n+\n+\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n+\t};\n+\n+\n+\n+function adjustCSS( elem, prop, valueParts, tween ) {\n+\tvar adjusted, scale,\n+\t\tmaxIterations = 20,\n+\t\tcurrentValue = tween ?\n+\t\t\tfunction() {\n+\t\t\t\treturn tween.cur();\n+\t\t\t} :\n+\t\t\tfunction() {\n+\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n+\t\t\t},\n+\t\tinitial = currentValue(),\n+\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n+\n+\t\t// Starting value computation is required for potential unit mismatches\n+\t\tinitialInUnit = elem.nodeType &&\n+\t\t\t( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n+\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n+\n+\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n+\n+\t\t// Support: Firefox <=54\n+\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n+\t\tinitial = initial / 2;\n+\n+\t\t// Trust units reported by jQuery.css\n+\t\tunit = unit || initialInUnit[ 3 ];\n+\n+\t\t// Iteratively approximate from a nonzero starting point\n+\t\tinitialInUnit = +initial || 1;\n+\n+\t\twhile ( maxIterations-- ) {\n+\n+\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n+\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n+\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n+\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n+\t\t\t\tmaxIterations = 0;\n+\t\t\t}\n+\t\t\tinitialInUnit = initialInUnit / scale;\n+\n+\t\t}\n+\n+\t\tinitialInUnit = initialInUnit * 2;\n+\t\tjQuery.style( elem, prop, initialInUnit + unit );\n+\n+\t\t// Make sure we update the tween properties later on\n+\t\tvalueParts = valueParts || [];\n+\t}\n+\n+\tif ( valueParts ) {\n+\t\tinitialInUnit = +initialInUnit || +initial || 0;\n+\n+\t\t// Apply relative offset (+=/-=) if specified\n+\t\tadjusted = valueParts[ 1 ] ?\n+\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n+\t\t\t+valueParts[ 2 ];\n+\t\tif ( tween ) {\n+\t\t\ttween.unit = unit;\n+\t\t\ttween.start = initialInUnit;\n+\t\t\ttween.end = adjusted;\n+\t\t}\n+\t}\n+\treturn adjusted;\n+}\n+\n+\n+var defaultDisplayMap = {};\n+\n+function getDefaultDisplay( elem ) {\n+\tvar temp,\n+\t\tdoc = elem.ownerDocument,\n+\t\tnodeName = elem.nodeName,\n+\t\tdisplay = defaultDisplayMap[ nodeName ];\n+\n+\tif ( display ) {\n+\t\treturn display;\n+\t}\n+\n+\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n+\tdisplay = jQuery.css( temp, \"display\" );\n+\n+\ttemp.parentNode.removeChild( temp );\n+\n+\tif ( display === \"none\" ) {\n+\t\tdisplay = \"block\";\n+\t}\n+\tdefaultDisplayMap[ nodeName ] = display;\n+\n+\treturn display;\n+}\n+\n+function showHide( elements, show ) {\n+\tvar display, elem,\n+\t\tvalues = [],\n+\t\tindex = 0,\n+\t\tlength = elements.length;\n+\n+\t// Determine new display value for elements that need to change\n+\tfor ( ; index < length; index++ ) {\n+\t\telem = elements[ index ];\n+\t\tif ( !elem.style ) {\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tdisplay = elem.style.display;\n+\t\tif ( show ) {\n+\n+\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n+\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n+\t\t\t// inline or about-to-be-restored)\n+\t\t\tif ( display === \"none\" ) {\n+\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n+\t\t\t\tif ( !values[ index ] ) {\n+\t\t\t\t\telem.style.display = \"\";\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n+\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif ( display !== \"none\" ) {\n+\t\t\t\tvalues[ index ] = \"none\";\n+\n+\t\t\t\t// Remember what we're overwriting\n+\t\t\t\tdataPriv.set( elem, \"display\", display );\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Set the display of the elements in a second loop to avoid constant reflow\n+\tfor ( index = 0; index < length; index++ ) {\n+\t\tif ( values[ index ] != null ) {\n+\t\t\telements[ index ].style.display = values[ index ];\n+\t\t}\n+\t}\n+\n+\treturn elements;\n+}\n+\n+jQuery.fn.extend( {\n+\tshow: function() {\n+\t\treturn showHide( this, true );\n+\t},\n+\thide: function() {\n+\t\treturn showHide( this );\n+\t},\n+\ttoggle: function( state ) {\n+\t\tif ( typeof state === \"boolean\" ) {\n+\t\t\treturn state ? this.show() : this.hide();\n+\t\t}\n+\n+\t\treturn this.each( function() {\n+\t\t\tif ( isHiddenWithinTree( this ) ) {\n+\t\t\t\tjQuery( this ).show();\n+\t\t\t} else {\n+\t\t\t\tjQuery( this ).hide();\n+\t\t\t}\n+\t\t} );\n+\t}\n+} );\n+var rcheckableType = ( /^(?:checkbox|radio)$/i );\n+\n+var rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i );\n+\n+var rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n+\n+\n+\n+( function() {\n+\tvar fragment = document.createDocumentFragment(),\n+\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n+\t\tinput = document.createElement( \"input\" );\n+\n+\t// Support: Android 4.0 - 4.3 only\n+\t// Check state lost if the name is set (trac-11217)\n+\t// Support: Windows Web Apps (WWA)\n+\t// `name` and `type` must use .setAttribute for WWA (trac-14901)\n+\tinput.setAttribute( \"type\", \"radio\" );\n+\tinput.setAttribute( \"checked\", \"checked\" );\n+\tinput.setAttribute( \"name\", \"t\" );\n+\n+\tdiv.appendChild( input );\n+\n+\t// Support: Android <=4.1 only\n+\t// Older WebKit doesn't clone checked state correctly in fragments\n+\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n+\n+\t// Support: IE <=11 only\n+\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n+\tdiv.innerHTML = \"<textarea>x</textarea>\";\n+\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n+\n+\t// Support: IE <=9 only\n+\t// IE <=9 replaces <option> tags with their contents when inserted outside of\n+\t// the select element.\n+\tdiv.innerHTML = \"<option></option>\";\n+\tsupport.option = !!div.lastChild;\n+} )();\n+\n+\n+// We have to close these tags to support XHTML (trac-13200)\n+var wrapMap = {\n+\n+\t// XHTML parsers do not magically insert elements in the\n+\t// same way that tag soup parsers do. So we cannot shorten\n+\t// this by omitting <tbody> or other required elements.\n+\tthead: [ 1, \"<table>\", \"</table>\" ],\n+\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n+\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n+\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n+\n+\t_default: [ 0, \"\", \"\" ]\n+};\n+\n+wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n+wrapMap.th = wrapMap.td;\n+\n+// Support: IE <=9 only\n+if ( !support.option ) {\n+\twrapMap.optgroup = wrapMap.option = [ 1, \"<select multiple='multiple'>\", \"</select>\" ];\n+}\n+\n+\n+function getAll( context, tag ) {\n+\n+\t// Support: IE <=9 - 11 only\n+\t// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)\n+\tvar ret;\n+\n+\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n+\t\tret = context.getElementsByTagName( tag || \"*\" );\n+\n+\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n+\t\tret = context.querySelectorAll( tag || \"*\" );\n+\n+\t} else {\n+\t\tret = [];\n+\t}\n+\n+\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n+\t\treturn jQuery.merge( [ context ], ret );\n+\t}\n+\n+\treturn ret;\n+}\n+\n+\n+// Mark scripts as having already been evaluated\n+function setGlobalEval( elems, refElements ) {\n+\tvar i = 0,\n+\t\tl = elems.length;\n+\n+\tfor ( ; i < l; i++ ) {\n+\t\tdataPriv.set(\n+\t\t\telems[ i ],\n+\t\t\t\"globalEval\",\n+\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n+\t\t);\n+\t}\n+}\n+\n+\n+var rhtml = /<|&#?\\w+;/;\n+\n+function buildFragment( elems, context, scripts, selection, ignored ) {\n+\tvar elem, tmp, tag, wrap, attached, j,\n+\t\tfragment = context.createDocumentFragment(),\n+\t\tnodes = [],\n+\t\ti = 0,\n+\t\tl = elems.length;\n+\n+\tfor ( ; i < l; i++ ) {\n+\t\telem = elems[ i ];\n+\n+\t\tif ( elem || elem === 0 ) {\n+\n+\t\t\t// Add nodes directly\n+\t\t\tif ( toType( elem ) === \"object\" ) {\n+\n+\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n+\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n+\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n+\n+\t\t\t// Convert non-html into a text node\n+\t\t\t} else if ( !rhtml.test( elem ) ) {\n+\t\t\t\tnodes.push( context.createTextNode( elem ) );\n+\n+\t\t\t// Convert html into DOM nodes\n+\t\t\t} else {\n+\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n+\n+\t\t\t\t// Deserialize a standard representation\n+\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n+\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n+\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n+\n+\t\t\t\t// Descend through wrappers to the right content\n+\t\t\t\tj = wrap[ 0 ];\n+\t\t\t\twhile ( j-- ) {\n+\t\t\t\t\ttmp = tmp.lastChild;\n+\t\t\t\t}\n+\n+\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n+\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n+\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n+\n+\t\t\t\t// Remember the top-level container\n+\t\t\t\ttmp = fragment.firstChild;\n+\n+\t\t\t\t// Ensure the created nodes are orphaned (trac-12392)\n+\t\t\t\ttmp.textContent = \"\";\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Remove wrapper from fragment\n+\tfragment.textContent = \"\";\n+\n+\ti = 0;\n+\twhile ( ( elem = nodes[ i++ ] ) ) {\n+\n+\t\t// Skip elements already in the context collection (trac-4087)\n+\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n+\t\t\tif ( ignored ) {\n+\t\t\t\tignored.push( elem );\n+\t\t\t}\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tattached = isAttached( elem );\n+\n+\t\t// Append to fragment\n+\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n+\n+\t\t// Preserve script evaluation history\n+\t\tif ( attached ) {\n+\t\t\tsetGlobalEval( tmp );\n+\t\t}\n+\n+\t\t// Capture executables\n+\t\tif ( scripts ) {\n+\t\t\tj = 0;\n+\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n+\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n+\t\t\t\t\tscripts.push( elem );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn fragment;\n+}\n+\n+\n+var rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n+\n+function returnTrue() {\n+\treturn true;\n+}\n+\n+function returnFalse() {\n+\treturn false;\n+}\n+\n+// Support: IE <=9 - 11+\n+// focus() and blur() are asynchronous, except when they are no-op.\n+// So expect focus to be synchronous when the element is already active,\n+// and blur to be synchronous when the element is not already active.\n+// (focus and blur are always synchronous in other supported browsers,\n+// this just defines when we can count on it).\n+function expectSync( elem, type ) {\n+\treturn ( elem === safeActiveElement() ) === ( type === \"focus\" );\n+}\n+\n+// Support: IE <=9 only\n+// Accessing document.activeElement can throw unexpectedly\n+// https://bugs.jquery.com/ticket/13393\n+function safeActiveElement() {\n+\ttry {\n+\t\treturn document.activeElement;\n+\t} catch ( err ) { }\n+}\n+\n+function on( elem, types, selector, data, fn, one ) {\n+\tvar origFn, type;\n+\n+\t// Types can be a map of types/handlers\n+\tif ( typeof types === \"object\" ) {\n+\n+\t\t// ( types-Object, selector, data )\n+\t\tif ( typeof selector !== \"string\" ) {\n+\n+\t\t\t// ( types-Object, data )\n+\t\t\tdata = data || selector;\n+\t\t\tselector = undefined;\n+\t\t}\n+\t\tfor ( type in types ) {\n+\t\t\ton( elem, type, selector, data, types[ type ], one );\n+\t\t}\n+\t\treturn elem;\n+\t}\n+\n+\tif ( data == null && fn == null ) {\n+\n+\t\t// ( types, fn )\n+\t\tfn = selector;\n+\t\tdata = selector = undefined;\n+\t} else if ( fn == null ) {\n+\t\tif ( typeof selector === \"string\" ) {\n+\n+\t\t\t// ( types, selector, fn )\n+\t\t\tfn = data;\n+\t\t\tdata = undefined;\n+\t\t} else {\n+\n+\t\t\t// ( types, data, fn )\n+\t\t\tfn = data;\n+\t\t\tdata = selector;\n+\t\t\tselector = undefined;\n+\t\t}\n+\t}\n+\tif ( fn === false ) {\n+\t\tfn = returnFalse;\n+\t} else if ( !fn ) {\n+\t\treturn elem;\n+\t}\n+\n+\tif ( one === 1 ) {\n+\t\torigFn = fn;\n+\t\tfn = function( event ) {\n+\n+\t\t\t// Can use an empty set, since event contains the info\n+\t\t\tjQuery().off( event );\n+\t\t\treturn origFn.apply( this, arguments );\n+\t\t};\n+\n+\t\t// Use same guid so caller can remove using origFn\n+\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n+\t}\n+\treturn elem.each( function() {\n+\t\tjQuery.event.add( this, types, fn, data, selector );\n+\t} );\n+}\n+\n+/*\n+ * Helper functions for managing events -- not part of the public interface.\n+ * Props to Dean Edwards' addEvent library for many of the ideas.\n+ */\n+jQuery.event = {\n+\n+\tglobal: {},\n+\n+\tadd: function( elem, types, handler, data, selector ) {\n+\n+\t\tvar handleObjIn, eventHandle, tmp,\n+\t\t\tevents, t, handleObj,\n+\t\t\tspecial, handlers, type, namespaces, origType,\n+\t\t\telemData = dataPriv.get( elem );\n+\n+\t\t// Only attach events to objects that accept data\n+\t\tif ( !acceptData( elem ) ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Caller can pass in an object of custom data in lieu of the handler\n+\t\tif ( handler.handler ) {\n+\t\t\thandleObjIn = handler;\n+\t\t\thandler = handleObjIn.handler;\n+\t\t\tselector = handleObjIn.selector;\n+\t\t}\n+\n+\t\t// Ensure that invalid selectors throw exceptions at attach time\n+\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n+\t\tif ( selector ) {\n+\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n+\t\t}\n+\n+\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n+\t\tif ( !handler.guid ) {\n+\t\t\thandler.guid = jQuery.guid++;\n+\t\t}\n+\n+\t\t// Init the element's event structure and main handler, if this is the first\n+\t\tif ( !( events = elemData.events ) ) {\n+\t\t\tevents = elemData.events = Object.create( null );\n+\t\t}\n+\t\tif ( !( eventHandle = elemData.handle ) ) {\n+\t\t\teventHandle = elemData.handle = function( e ) {\n+\n+\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n+\t\t\t\t// when an event is called after a page has unloaded\n+\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n+\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n+\t\t\t};\n+\t\t}\n+\n+\t\t// Handle multiple events separated by a space\n+\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n+\t\tt = types.length;\n+\t\twhile ( t-- ) {\n+\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n+\t\t\ttype = origType = tmp[ 1 ];\n+\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n+\n+\t\t\t// There *must* be a type, no attaching namespace-only handlers\n+\t\t\tif ( !type ) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\t// If event changes its type, use the special event handlers for the changed type\n+\t\t\tspecial = jQuery.event.special[ type ] || {};\n+\n+\t\t\t// If selector defined, determine special event api type, otherwise given type\n+\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n+\n+\t\t\t// Update special based on newly reset type\n+\t\t\tspecial = jQuery.event.special[ type ] || {};\n+\n+\t\t\t// handleObj is passed to all event handlers\n+\t\t\thandleObj = jQuery.extend( {\n+\t\t\t\ttype: type,\n+\t\t\t\torigType: origType,\n+\t\t\t\tdata: data,\n+\t\t\t\thandler: handler,\n+\t\t\t\tguid: handler.guid,\n+\t\t\t\tselector: selector,\n+\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n+\t\t\t\tnamespace: namespaces.join( \".\" )\n+\t\t\t}, handleObjIn );\n+\n+\t\t\t// Init the event handler queue if we're the first\n+\t\t\tif ( !( handlers = events[ type ] ) ) {\n+\t\t\t\thandlers = events[ type ] = [];\n+\t\t\t\thandlers.delegateCount = 0;\n+\n+\t\t\t\t// Only use addEventListener if the special events handler returns false\n+\t\t\t\tif ( !special.setup ||\n+\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n+\n+\t\t\t\t\tif ( elem.addEventListener ) {\n+\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif ( special.add ) {\n+\t\t\t\tspecial.add.call( elem, handleObj );\n+\n+\t\t\t\tif ( !handleObj.handler.guid ) {\n+\t\t\t\t\thandleObj.handler.guid = handler.guid;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Add to the element's handler list, delegates in front\n+\t\t\tif ( selector ) {\n+\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n+\t\t\t} else {\n+\t\t\t\thandlers.push( handleObj );\n+\t\t\t}\n+\n+\t\t\t// Keep track of which events have ever been used, for event optimization\n+\t\t\tjQuery.event.global[ type ] = true;\n+\t\t}\n+\n+\t},\n+\n+\t// Detach an event or set of events from an element\n+\tremove: function( elem, types, handler, selector, mappedTypes ) {\n+\n+\t\tvar j, origCount, tmp,\n+\t\t\tevents, t, handleObj,\n+\t\t\tspecial, handlers, type, namespaces, origType,\n+\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n+\n+\t\tif ( !elemData || !( events = elemData.events ) ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Once for each type.namespace in types; type may be omitted\n+\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n+\t\tt = types.length;\n+\t\twhile ( t-- ) {\n+\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n+\t\t\ttype = origType = tmp[ 1 ];\n+\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n+\n+\t\t\t// Unbind all events (on this namespace, if provided) for the element\n+\t\t\tif ( !type ) {\n+\t\t\t\tfor ( type in events ) {\n+\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n+\t\t\t\t}\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tspecial = jQuery.event.special[ type ] || {};\n+\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n+\t\t\thandlers = events[ type ] || [];\n+\t\t\ttmp = tmp[ 2 ] &&\n+\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n+\n+\t\t\t// Remove matching events\n+\t\t\torigCount = j = handlers.length;\n+\t\t\twhile ( j-- ) {\n+\t\t\t\thandleObj = handlers[ j ];\n+\n+\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n+\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n+\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n+\t\t\t\t\t( !selector || selector === handleObj.selector ||\n+\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n+\t\t\t\t\thandlers.splice( j, 1 );\n+\n+\t\t\t\t\tif ( handleObj.selector ) {\n+\t\t\t\t\t\thandlers.delegateCount--;\n+\t\t\t\t\t}\n+\t\t\t\t\tif ( special.remove ) {\n+\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n+\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n+\t\t\tif ( origCount && !handlers.length ) {\n+\t\t\t\tif ( !special.teardown ||\n+\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n+\n+\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n+\t\t\t\t}\n+\n+\t\t\t\tdelete events[ type ];\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Remove data and the expando if it's no longer used\n+\t\tif ( jQuery.isEmptyObject( events ) ) {\n+\t\t\tdataPriv.remove( elem, \"handle events\" );\n+\t\t}\n+\t},\n+\n+\tdispatch: function( nativeEvent ) {\n+\n+\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n+\t\t\targs = new Array( arguments.length ),\n+\n+\t\t\t// Make a writable jQuery.Event from the native event object\n+\t\t\tevent = jQuery.event.fix( nativeEvent ),\n+\n+\t\t\thandlers = (\n+\t\t\t\tdataPriv.get( this, \"events\" ) || Object.create( null )\n+\t\t\t)[ event.type ] || [],\n+\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n+\n+\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n+\t\targs[ 0 ] = event;\n+\n+\t\tfor ( i = 1; i < arguments.length; i++ ) {\n+\t\t\targs[ i ] = arguments[ i ];\n+\t\t}\n+\n+\t\tevent.delegateTarget = this;\n+\n+\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n+\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Determine handlers\n+\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n+\n+\t\t// Run delegates first; they may want to stop propagation beneath us\n+\t\ti = 0;\n+\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n+\t\t\tevent.currentTarget = matched.elem;\n+\n+\t\t\tj = 0;\n+\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n+\t\t\t\t!event.isImmediatePropagationStopped() ) {\n+\n+\t\t\t\t// If the event is namespaced, then each handler is only invoked if it is\n+\t\t\t\t// specially universal or its namespaces are a superset of the event's.\n+\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n+\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n+\n+\t\t\t\t\tevent.handleObj = handleObj;\n+\t\t\t\t\tevent.data = handleObj.data;\n+\n+\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n+\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n+\n+\t\t\t\t\tif ( ret !== undefined ) {\n+\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n+\t\t\t\t\t\t\tevent.preventDefault();\n+\t\t\t\t\t\t\tevent.stopPropagation();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Call the postDispatch hook for the mapped type\n+\t\tif ( special.postDispatch ) {\n+\t\t\tspecial.postDispatch.call( this, event );\n+\t\t}\n+\n+\t\treturn event.result;\n+\t},\n+\n+\thandlers: function( event, handlers ) {\n+\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n+\t\t\thandlerQueue = [],\n+\t\t\tdelegateCount = handlers.delegateCount,\n+\t\t\tcur = event.target;\n+\n+\t\t// Find delegate handlers\n+\t\tif ( delegateCount &&\n+\n+\t\t\t// Support: IE <=9\n+\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n+\t\t\tcur.nodeType &&\n+\n+\t\t\t// Support: Firefox <=42\n+\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n+\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n+\t\t\t// Support: IE 11 only\n+\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n+\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n+\n+\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n+\n+\t\t\t\t// Don't check non-elements (trac-13208)\n+\t\t\t\t// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n+\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n+\t\t\t\t\tmatchedHandlers = [];\n+\t\t\t\t\tmatchedSelectors = {};\n+\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n+\t\t\t\t\t\thandleObj = handlers[ i ];\n+\n+\t\t\t\t\t\t// Don't conflict with Object.prototype properties (trac-13203)\n+\t\t\t\t\t\tsel = handleObj.selector + \" \";\n+\n+\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n+\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n+\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n+\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n+\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif ( matchedHandlers.length ) {\n+\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Add the remaining (directly-bound) handlers\n+\t\tcur = this;\n+\t\tif ( delegateCount < handlers.length ) {\n+\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n+\t\t}\n+\n+\t\treturn handlerQueue;\n+\t},\n+\n+\taddProp: function( name, hook ) {\n+\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n+\t\t\tenumerable: true,\n+\t\t\tconfigurable: true,\n+\n+\t\t\tget: isFunction( hook ) ?\n+\t\t\t\tfunction() {\n+\t\t\t\t\tif ( this.originalEvent ) {\n+\t\t\t\t\t\treturn hook( this.originalEvent );\n+\t\t\t\t\t}\n+\t\t\t\t} :\n+\t\t\t\tfunction() {\n+\t\t\t\t\tif ( this.originalEvent ) {\n+\t\t\t\t\t\treturn this.originalEvent[ name ];\n+\t\t\t\t\t}\n+\t\t\t\t},\n+\n+\t\t\tset: function( value ) {\n+\t\t\t\tObject.defineProperty( this, name, {\n+\t\t\t\t\tenumerable: true,\n+\t\t\t\t\tconfigurable: true,\n+\t\t\t\t\twritable: true,\n+\t\t\t\t\tvalue: value\n+\t\t\t\t} );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\tfix: function( originalEvent ) {\n+\t\treturn originalEvent[ jQuery.expando ] ?\n+\t\t\toriginalEvent :\n+\t\t\tnew jQuery.Event( originalEvent );\n+\t},\n+\n+\tspecial: {\n+\t\tload: {\n+\n+\t\t\t// Prevent triggered image.load events from bubbling to window.load\n+\t\t\tnoBubble: true\n+\t\t},\n+\t\tclick: {\n+\n+\t\t\t// Utilize native event to ensure correct state for checkable inputs\n+\t\t\tsetup: function( data ) {\n+\n+\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n+\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n+\t\t\t\tvar el = this || data;\n+\n+\t\t\t\t// Claim the first handler\n+\t\t\t\tif ( rcheckableType.test( el.type ) &&\n+\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n+\n+\t\t\t\t\t// dataPriv.set( el, \"click\", ... )\n+\t\t\t\t\tleverageNative( el, \"click\", returnTrue );\n+\t\t\t\t}\n+\n+\t\t\t\t// Return false to allow normal processing in the caller\n+\t\t\t\treturn false;\n+\t\t\t},\n+\t\t\ttrigger: function( data ) {\n+\n+\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n+\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n+\t\t\t\tvar el = this || data;\n+\n+\t\t\t\t// Force setup before triggering a click\n+\t\t\t\tif ( rcheckableType.test( el.type ) &&\n+\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n+\n+\t\t\t\t\tleverageNative( el, \"click\" );\n+\t\t\t\t}\n+\n+\t\t\t\t// Return non-false to allow normal event-path propagation\n+\t\t\t\treturn true;\n+\t\t\t},\n+\n+\t\t\t// For cross-browser consistency, suppress native .click() on links\n+\t\t\t// Also prevent it if we're currently inside a leveraged native-event stack\n+\t\t\t_default: function( event ) {\n+\t\t\t\tvar target = event.target;\n+\t\t\t\treturn rcheckableType.test( target.type ) &&\n+\t\t\t\t\ttarget.click && nodeName( target, \"input\" ) &&\n+\t\t\t\t\tdataPriv.get( target, \"click\" ) ||\n+\t\t\t\t\tnodeName( target, \"a\" );\n+\t\t\t}\n+\t\t},\n+\n+\t\tbeforeunload: {\n+\t\t\tpostDispatch: function( event ) {\n+\n+\t\t\t\t// Support: Firefox 20+\n+\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n+\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n+\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+};\n+\n+// Ensure the presence of an event listener that handles manually-triggered\n+// synthetic events by interrupting progress until reinvoked in response to\n+// *native* events that it fires directly, ensuring that state changes have\n+// already occurred before other listeners are invoked.\n+function leverageNative( el, type, expectSync ) {\n+\n+\t// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n+\tif ( !expectSync ) {\n+\t\tif ( dataPriv.get( el, type ) === undefined ) {\n+\t\t\tjQuery.event.add( el, type, returnTrue );\n+\t\t}\n+\t\treturn;\n+\t}\n+\n+\t// Register the controller as a special universal handler for all event namespaces\n+\tdataPriv.set( el, type, false );\n+\tjQuery.event.add( el, type, {\n+\t\tnamespace: false,\n+\t\thandler: function( event ) {\n+\t\t\tvar notAsync, result,\n+\t\t\t\tsaved = dataPriv.get( this, type );\n+\n+\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n+\n+\t\t\t\t// Interrupt processing of the outer synthetic .trigger()ed event\n+\t\t\t\t// Saved data should be false in such cases, but might be a leftover capture object\n+\t\t\t\t// from an async native handler (gh-4350)\n+\t\t\t\tif ( !saved.length ) {\n+\n+\t\t\t\t\t// Store arguments for use when handling the inner native event\n+\t\t\t\t\t// There will always be at least one argument (an event object), so this array\n+\t\t\t\t\t// will not be confused with a leftover capture object.\n+\t\t\t\t\tsaved = slice.call( arguments );\n+\t\t\t\t\tdataPriv.set( this, type, saved );\n+\n+\t\t\t\t\t// Trigger the native event and capture its result\n+\t\t\t\t\t// Support: IE <=9 - 11+\n+\t\t\t\t\t// focus() and blur() are asynchronous\n+\t\t\t\t\tnotAsync = expectSync( this, type );\n+\t\t\t\t\tthis[ type ]();\n+\t\t\t\t\tresult = dataPriv.get( this, type );\n+\t\t\t\t\tif ( saved !== result || notAsync ) {\n+\t\t\t\t\t\tdataPriv.set( this, type, false );\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tresult = {};\n+\t\t\t\t\t}\n+\t\t\t\t\tif ( saved !== result ) {\n+\n+\t\t\t\t\t\t// Cancel the outer synthetic event\n+\t\t\t\t\t\tevent.stopImmediatePropagation();\n+\t\t\t\t\t\tevent.preventDefault();\n+\n+\t\t\t\t\t\t// Support: Chrome 86+\n+\t\t\t\t\t\t// In Chrome, if an element having a focusout handler is blurred by\n+\t\t\t\t\t\t// clicking outside of it, it invokes the handler synchronously. If\n+\t\t\t\t\t\t// that handler calls `.remove()` on the element, the data is cleared,\n+\t\t\t\t\t\t// leaving `result` undefined. We need to guard against this.\n+\t\t\t\t\t\treturn result && result.value;\n+\t\t\t\t\t}\n+\n+\t\t\t\t// If this is an inner synthetic event for an event with a bubbling surrogate\n+\t\t\t\t// (focus or blur), assume that the surrogate already propagated from triggering the\n+\t\t\t\t// native event and prevent that from happening again here.\n+\t\t\t\t// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n+\t\t\t\t// bubbling surrogate propagates *after* the non-bubbling base), but that seems\n+\t\t\t\t// less bad than duplication.\n+\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n+\t\t\t\t\tevent.stopPropagation();\n+\t\t\t\t}\n+\n+\t\t\t// If this is a native event triggered above, everything is now in order\n+\t\t\t// Fire an inner synthetic event with the original arguments\n+\t\t\t} else if ( saved.length ) {\n+\n+\t\t\t\t// ...and capture the result\n+\t\t\t\tdataPriv.set( this, type, {\n+\t\t\t\t\tvalue: jQuery.event.trigger(\n+\n+\t\t\t\t\t\t// Support: IE <=9 - 11+\n+\t\t\t\t\t\t// Extend with the prototype to reset the above stopImmediatePropagation()\n+\t\t\t\t\t\tjQuery.extend( saved[ 0 ], jQuery.Event.prototype ),\n+\t\t\t\t\t\tsaved.slice( 1 ),\n+\t\t\t\t\t\tthis\n+\t\t\t\t\t)\n+\t\t\t\t} );\n+\n+\t\t\t\t// Abort handling of the native event\n+\t\t\t\tevent.stopImmediatePropagation();\n+\t\t\t}\n+\t\t}\n+\t} );\n+}\n+\n+jQuery.removeEvent = function( elem, type, handle ) {\n+\n+\t// This \"if\" is needed for plain objects\n+\tif ( elem.removeEventListener ) {\n+\t\telem.removeEventListener( type, handle );\n+\t}\n+};\n+\n+jQuery.Event = function( src, props ) {\n+\n+\t// Allow instantiation without the 'new' keyword\n+\tif ( !( this instanceof jQuery.Event ) ) {\n+\t\treturn new jQuery.Event( src, props );\n+\t}\n+\n+\t// Event object\n+\tif ( src && src.type ) {\n+\t\tthis.originalEvent = src;\n+\t\tthis.type = src.type;\n+\n+\t\t// Events bubbling up the document may have been marked as prevented\n+\t\t// by a handler lower down the tree; reflect the correct value.\n+\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n+\t\t\t\tsrc.defaultPrevented === undefined &&\n+\n+\t\t\t\t// Support: Android <=2.3 only\n+\t\t\t\tsrc.returnValue === false ?\n+\t\t\treturnTrue :\n+\t\t\treturnFalse;\n+\n+\t\t// Create target properties\n+\t\t// Support: Safari <=6 - 7 only\n+\t\t// Target should not be a text node (trac-504, trac-13143)\n+\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n+\t\t\tsrc.target.parentNode :\n+\t\t\tsrc.target;\n+\n+\t\tthis.currentTarget = src.currentTarget;\n+\t\tthis.relatedTarget = src.relatedTarget;\n+\n+\t// Event type\n+\t} else {\n+\t\tthis.type = src;\n+\t}\n+\n+\t// Put explicitly provided properties onto the event object\n+\tif ( props ) {\n+\t\tjQuery.extend( this, props );\n+\t}\n+\n+\t// Create a timestamp if incoming event doesn't have one\n+\tthis.timeStamp = src && src.timeStamp || Date.now();\n+\n+\t// Mark it as fixed\n+\tthis[ jQuery.expando ] = true;\n+};\n+\n+// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n+// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n+jQuery.Event.prototype = {\n+\tconstructor: jQuery.Event,\n+\tisDefaultPrevented: returnFalse,\n+\tisPropagationStopped: returnFalse,\n+\tisImmediatePropagationStopped: returnFalse,\n+\tisSimulated: false,\n+\n+\tpreventDefault: function() {\n+\t\tvar e = this.originalEvent;\n+\n+\t\tthis.isDefaultPrevented = returnTrue;\n+\n+\t\tif ( e && !this.isSimulated ) {\n+\t\t\te.preventDefault();\n+\t\t}\n+\t},\n+\tstopPropagation: function() {\n+\t\tvar e = this.originalEvent;\n+\n+\t\tthis.isPropagationStopped = returnTrue;\n+\n+\t\tif ( e && !this.isSimulated ) {\n+\t\t\te.stopPropagation();\n+\t\t}\n+\t},\n+\tstopImmediatePropagation: function() {\n+\t\tvar e = this.originalEvent;\n+\n+\t\tthis.isImmediatePropagationStopped = returnTrue;\n+\n+\t\tif ( e && !this.isSimulated ) {\n+\t\t\te.stopImmediatePropagation();\n+\t\t}\n+\n+\t\tthis.stopPropagation();\n+\t}\n+};\n+\n+// Includes all common event props including KeyEvent and MouseEvent specific props\n+jQuery.each( {\n+\taltKey: true,\n+\tbubbles: true,\n+\tcancelable: true,\n+\tchangedTouches: true,\n+\tctrlKey: true,\n+\tdetail: true,\n+\teventPhase: true,\n+\tmetaKey: true,\n+\tpageX: true,\n+\tpageY: true,\n+\tshiftKey: true,\n+\tview: true,\n+\t\"char\": true,\n+\tcode: true,\n+\tcharCode: true,\n+\tkey: true,\n+\tkeyCode: true,\n+\tbutton: true,\n+\tbuttons: true,\n+\tclientX: true,\n+\tclientY: true,\n+\toffsetX: true,\n+\toffsetY: true,\n+\tpointerId: true,\n+\tpointerType: true,\n+\tscreenX: true,\n+\tscreenY: true,\n+\ttargetTouches: true,\n+\ttoElement: true,\n+\ttouches: true,\n+\twhich: true\n+}, jQuery.event.addProp );\n+\n+jQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( type, delegateType ) {\n+\tjQuery.event.special[ type ] = {\n+\n+\t\t// Utilize native event if possible so blur/focus sequence is correct\n+\t\tsetup: function() {\n+\n+\t\t\t// Claim the first handler\n+\t\t\t// dataPriv.set( this, \"focus\", ... )\n+\t\t\t// dataPriv.set( this, \"blur\", ... )\n+\t\t\tleverageNative( this, type, expectSync );\n+\n+\t\t\t// Return false to allow normal processing in the caller\n+\t\t\treturn false;\n+\t\t},\n+\t\ttrigger: function() {\n+\n+\t\t\t// Force setup before trigger\n+\t\t\tleverageNative( this, type );\n+\n+\t\t\t// Return non-false to allow normal event-path propagation\n+\t\t\treturn true;\n+\t\t},\n+\n+\t\t// Suppress native focus or blur if we're currently inside\n+\t\t// a leveraged native-event stack\n+\t\t_default: function( event ) {\n+\t\t\treturn dataPriv.get( event.target, type );\n+\t\t},\n+\n+\t\tdelegateType: delegateType\n+\t};\n+} );\n+\n+// Create mouseenter/leave events using mouseover/out and event-time checks\n+// so that event delegation works in jQuery.\n+// Do the same for pointerenter/pointerleave and pointerover/pointerout\n+//\n+// Support: Safari 7 only\n+// Safari sends mouseenter too often; see:\n+// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n+// for the description of the bug (it existed in older Chrome versions as well).\n+jQuery.each( {\n+\tmouseenter: \"mouseover\",\n+\tmouseleave: \"mouseout\",\n+\tpointerenter: \"pointerover\",\n+\tpointerleave: \"pointerout\"\n+}, function( orig, fix ) {\n+\tjQuery.event.special[ orig ] = {\n+\t\tdelegateType: fix,\n+\t\tbindType: fix,\n+\n+\t\thandle: function( event ) {\n+\t\t\tvar ret,\n+\t\t\t\ttarget = this,\n+\t\t\t\trelated = event.relatedTarget,\n+\t\t\t\thandleObj = event.handleObj;\n+\n+\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n+\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n+\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n+\t\t\t\tevent.type = handleObj.origType;\n+\t\t\t\tret = handleObj.handler.apply( this, arguments );\n+\t\t\t\tevent.type = fix;\n+\t\t\t}\n+\t\t\treturn ret;\n+\t\t}\n+\t};\n+} );\n+\n+jQuery.fn.extend( {\n+\n+\ton: function( types, selector, data, fn ) {\n+\t\treturn on( this, types, selector, data, fn );\n+\t},\n+\tone: function( types, selector, data, fn ) {\n+\t\treturn on( this, types, selector, data, fn, 1 );\n+\t},\n+\toff: function( types, selector, fn ) {\n+\t\tvar handleObj, type;\n+\t\tif ( types && types.preventDefault && types.handleObj ) {\n+\n+\t\t\t// ( event )  dispatched jQuery.Event\n+\t\t\thandleObj = types.handleObj;\n+\t\t\tjQuery( types.delegateTarget ).off(\n+\t\t\t\thandleObj.namespace ?\n+\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n+\t\t\t\t\thandleObj.origType,\n+\t\t\t\thandleObj.selector,\n+\t\t\t\thandleObj.handler\n+\t\t\t);\n+\t\t\treturn this;\n+\t\t}\n+\t\tif ( typeof types === \"object\" ) {\n+\n+\t\t\t// ( types-object [, selector] )\n+\t\t\tfor ( type in types ) {\n+\t\t\t\tthis.off( type, selector, types[ type ] );\n+\t\t\t}\n+\t\t\treturn this;\n+\t\t}\n+\t\tif ( selector === false || typeof selector === \"function\" ) {\n+\n+\t\t\t// ( types [, fn] )\n+\t\t\tfn = selector;\n+\t\t\tselector = undefined;\n+\t\t}\n+\t\tif ( fn === false ) {\n+\t\t\tfn = returnFalse;\n+\t\t}\n+\t\treturn this.each( function() {\n+\t\t\tjQuery.event.remove( this, types, fn, selector );\n+\t\t} );\n+\t}\n+} );\n+\n+\n+var\n+\n+\t// Support: IE <=10 - 11, Edge 12 - 13 only\n+\t// In IE/Edge using regex groups here causes severe slowdowns.\n+\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n+\trnoInnerhtml = /<script|<style|<link/i,\n+\n+\t// checked=\"checked\" or checked\n+\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n+\n+\trcleanScript = /^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$/g;\n+\n+// Prefer a tbody over its parent table for containing new rows\n+function manipulationTarget( elem, content ) {\n+\tif ( nodeName( elem, \"table\" ) &&\n+\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n+\n+\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n+\t}\n+\n+\treturn elem;\n+}\n+\n+// Replace/restore the type attribute of script elements for safe DOM manipulation\n+function disableScript( elem ) {\n+\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n+\treturn elem;\n+}\n+function restoreScript( elem ) {\n+\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n+\t\telem.type = elem.type.slice( 5 );\n+\t} else {\n+\t\telem.removeAttribute( \"type\" );\n+\t}\n+\n+\treturn elem;\n+}\n+\n+function cloneCopyEvent( src, dest ) {\n+\tvar i, l, type, pdataOld, udataOld, udataCur, events;\n+\n+\tif ( dest.nodeType !== 1 ) {\n+\t\treturn;\n+\t}\n+\n+\t// 1. Copy private data: events, handlers, etc.\n+\tif ( dataPriv.hasData( src ) ) {\n+\t\tpdataOld = dataPriv.get( src );\n+\t\tevents = pdataOld.events;\n+\n+\t\tif ( events ) {\n+\t\t\tdataPriv.remove( dest, \"handle events\" );\n+\n+\t\t\tfor ( type in events ) {\n+\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n+\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// 2. Copy user data\n+\tif ( dataUser.hasData( src ) ) {\n+\t\tudataOld = dataUser.access( src );\n+\t\tudataCur = jQuery.extend( {}, udataOld );\n+\n+\t\tdataUser.set( dest, udataCur );\n+\t}\n+}\n+\n+// Fix IE bugs, see support tests\n+function fixInput( src, dest ) {\n+\tvar nodeName = dest.nodeName.toLowerCase();\n+\n+\t// Fails to persist the checked state of a cloned checkbox or radio button.\n+\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n+\t\tdest.checked = src.checked;\n+\n+\t// Fails to return the selected option to the default selected state when cloning options\n+\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n+\t\tdest.defaultValue = src.defaultValue;\n+\t}\n+}\n+\n+function domManip( collection, args, callback, ignored ) {\n+\n+\t// Flatten any nested arrays\n+\targs = flat( args );\n+\n+\tvar fragment, first, scripts, hasScripts, node, doc,\n+\t\ti = 0,\n+\t\tl = collection.length,\n+\t\tiNoClone = l - 1,\n+\t\tvalue = args[ 0 ],\n+\t\tvalueIsFunction = isFunction( value );\n+\n+\t// We can't cloneNode fragments that contain checked, in WebKit\n+\tif ( valueIsFunction ||\n+\t\t\t( l > 1 && typeof value === \"string\" &&\n+\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n+\t\treturn collection.each( function( index ) {\n+\t\t\tvar self = collection.eq( index );\n+\t\t\tif ( valueIsFunction ) {\n+\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n+\t\t\t}\n+\t\t\tdomManip( self, args, callback, ignored );\n+\t\t} );\n+\t}\n+\n+\tif ( l ) {\n+\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n+\t\tfirst = fragment.firstChild;\n+\n+\t\tif ( fragment.childNodes.length === 1 ) {\n+\t\t\tfragment = first;\n+\t\t}\n+\n+\t\t// Require either new content or an interest in ignored elements to invoke the callback\n+\t\tif ( first || ignored ) {\n+\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n+\t\t\thasScripts = scripts.length;\n+\n+\t\t\t// Use the original fragment for the last item\n+\t\t\t// instead of the first because it can end up\n+\t\t\t// being emptied incorrectly in certain situations (trac-8070).\n+\t\t\tfor ( ; i < l; i++ ) {\n+\t\t\t\tnode = fragment;\n+\n+\t\t\t\tif ( i !== iNoClone ) {\n+\t\t\t\t\tnode = jQuery.clone( node, true, true );\n+\n+\t\t\t\t\t// Keep references to cloned scripts for later restoration\n+\t\t\t\t\tif ( hasScripts ) {\n+\n+\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n+\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n+\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tcallback.call( collection[ i ], node, i );\n+\t\t\t}\n+\n+\t\t\tif ( hasScripts ) {\n+\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n+\n+\t\t\t\t// Reenable scripts\n+\t\t\t\tjQuery.map( scripts, restoreScript );\n+\n+\t\t\t\t// Evaluate executable scripts on first document insertion\n+\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n+\t\t\t\t\tnode = scripts[ i ];\n+\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n+\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n+\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n+\n+\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n+\n+\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n+\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n+\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n+\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( \"nonce\" )\n+\t\t\t\t\t\t\t\t}, doc );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t// Unwrap a CDATA section containing script contents. This shouldn't be\n+\t\t\t\t\t\t\t// needed as in XML documents they're already not visible when\n+\t\t\t\t\t\t\t// inspecting element contents and in HTML documents they have no\n+\t\t\t\t\t\t\t// meaning but we're preserving that logic for backwards compatibility.\n+\t\t\t\t\t\t\t// This will be removed completely in 4.0. See gh-4904.\n+\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), node, doc );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn collection;\n+}\n+\n+function remove( elem, selector, keepData ) {\n+\tvar node,\n+\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n+\t\ti = 0;\n+\n+\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n+\t\tif ( !keepData && node.nodeType === 1 ) {\n+\t\t\tjQuery.cleanData( getAll( node ) );\n+\t\t}\n+\n+\t\tif ( node.parentNode ) {\n+\t\t\tif ( keepData && isAttached( node ) ) {\n+\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n+\t\t\t}\n+\t\t\tnode.parentNode.removeChild( node );\n+\t\t}\n+\t}\n+\n+\treturn elem;\n+}\n+\n+jQuery.extend( {\n+\thtmlPrefilter: function( html ) {\n+\t\treturn html;\n+\t},\n+\n+\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n+\t\tvar i, l, srcElements, destElements,\n+\t\t\tclone = elem.cloneNode( true ),\n+\t\t\tinPage = isAttached( elem );\n+\n+\t\t// Fix IE cloning issues\n+\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n+\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n+\n+\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n+\t\t\tdestElements = getAll( clone );\n+\t\t\tsrcElements = getAll( elem );\n+\n+\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n+\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Copy the events from the original to the clone\n+\t\tif ( dataAndEvents ) {\n+\t\t\tif ( deepDataAndEvents ) {\n+\t\t\t\tsrcElements = srcElements || getAll( elem );\n+\t\t\t\tdestElements = destElements || getAll( clone );\n+\n+\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n+\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tcloneCopyEvent( elem, clone );\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Preserve script evaluation history\n+\t\tdestElements = getAll( clone, \"script\" );\n+\t\tif ( destElements.length > 0 ) {\n+\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n+\t\t}\n+\n+\t\t// Return the cloned set\n+\t\treturn clone;\n+\t},\n+\n+\tcleanData: function( elems ) {\n+\t\tvar data, elem, type,\n+\t\t\tspecial = jQuery.event.special,\n+\t\t\ti = 0;\n+\n+\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n+\t\t\tif ( acceptData( elem ) ) {\n+\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n+\t\t\t\t\tif ( data.events ) {\n+\t\t\t\t\t\tfor ( type in data.events ) {\n+\t\t\t\t\t\t\tif ( special[ type ] ) {\n+\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n+\n+\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Support: Chrome <=35 - 45+\n+\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n+\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n+\t\t\t\t}\n+\t\t\t\tif ( elem[ dataUser.expando ] ) {\n+\n+\t\t\t\t\t// Support: Chrome <=35 - 45+\n+\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n+\t\t\t\t\telem[ dataUser.expando ] = undefined;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+} );\n+\n+jQuery.fn.extend( {\n+\tdetach: function( selector ) {\n+\t\treturn remove( this, selector, true );\n+\t},\n+\n+\tremove: function( selector ) {\n+\t\treturn remove( this, selector );\n+\t},\n+\n+\ttext: function( value ) {\n+\t\treturn access( this, function( value ) {\n+\t\t\treturn value === undefined ?\n+\t\t\t\tjQuery.text( this ) :\n+\t\t\t\tthis.empty().each( function() {\n+\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n+\t\t\t\t\t\tthis.textContent = value;\n+\t\t\t\t\t}\n+\t\t\t\t} );\n+\t\t}, null, value, arguments.length );\n+\t},\n+\n+\tappend: function() {\n+\t\treturn domManip( this, arguments, function( elem ) {\n+\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n+\t\t\t\tvar target = manipulationTarget( this, elem );\n+\t\t\t\ttarget.appendChild( elem );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\tprepend: function() {\n+\t\treturn domManip( this, arguments, function( elem ) {\n+\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n+\t\t\t\tvar target = manipulationTarget( this, elem );\n+\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\tbefore: function() {\n+\t\treturn domManip( this, arguments, function( elem ) {\n+\t\t\tif ( this.parentNode ) {\n+\t\t\t\tthis.parentNode.insertBefore( elem, this );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\tafter: function() {\n+\t\treturn domManip( this, arguments, function( elem ) {\n+\t\t\tif ( this.parentNode ) {\n+\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\tempty: function() {\n+\t\tvar elem,\n+\t\t\ti = 0;\n+\n+\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n+\t\t\tif ( elem.nodeType === 1 ) {\n+\n+\t\t\t\t// Prevent memory leaks\n+\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n+\n+\t\t\t\t// Remove any remaining nodes\n+\t\t\t\telem.textContent = \"\";\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn this;\n+\t},\n+\n+\tclone: function( dataAndEvents, deepDataAndEvents ) {\n+\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n+\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n+\n+\t\treturn this.map( function() {\n+\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n+\t\t} );\n+\t},\n+\n+\thtml: function( value ) {\n+\t\treturn access( this, function( value ) {\n+\t\t\tvar elem = this[ 0 ] || {},\n+\t\t\t\ti = 0,\n+\t\t\t\tl = this.length;\n+\n+\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n+\t\t\t\treturn elem.innerHTML;\n+\t\t\t}\n+\n+\t\t\t// See if we can take a shortcut and just use innerHTML\n+\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n+\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n+\n+\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tfor ( ; i < l; i++ ) {\n+\t\t\t\t\t\telem = this[ i ] || {};\n+\n+\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n+\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n+\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n+\t\t\t\t\t\t\telem.innerHTML = value;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\telem = 0;\n+\n+\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n+\t\t\t\t} catch ( e ) {}\n+\t\t\t}\n+\n+\t\t\tif ( elem ) {\n+\t\t\t\tthis.empty().append( value );\n+\t\t\t}\n+\t\t}, null, value, arguments.length );\n+\t},\n+\n+\treplaceWith: function() {\n+\t\tvar ignored = [];\n+\n+\t\t// Make the changes, replacing each non-ignored context element with the new content\n+\t\treturn domManip( this, arguments, function( elem ) {\n+\t\t\tvar parent = this.parentNode;\n+\n+\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n+\t\t\t\tjQuery.cleanData( getAll( this ) );\n+\t\t\t\tif ( parent ) {\n+\t\t\t\t\tparent.replaceChild( elem, this );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t// Force callback invocation\n+\t\t}, ignored );\n+\t}\n+} );\n+\n+jQuery.each( {\n+\tappendTo: \"append\",\n+\tprependTo: \"prepend\",\n+\tinsertBefore: \"before\",\n+\tinsertAfter: \"after\",\n+\treplaceAll: \"replaceWith\"\n+}, function( name, original ) {\n+\tjQuery.fn[ name ] = function( selector ) {\n+\t\tvar elems,\n+\t\t\tret = [],\n+\t\t\tinsert = jQuery( selector ),\n+\t\t\tlast = insert.length - 1,\n+\t\t\ti = 0;\n+\n+\t\tfor ( ; i <= last; i++ ) {\n+\t\t\telems = i === last ? this : this.clone( true );\n+\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n+\n+\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n+\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n+\t\t\tpush.apply( ret, elems.get() );\n+\t\t}\n+\n+\t\treturn this.pushStack( ret );\n+\t};\n+} );\n+var rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n+\n+var rcustomProp = /^--/;\n+\n+\n+var getStyles = function( elem ) {\n+\n+\t\t// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)\n+\t\t// IE throws on elements created in popups\n+\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n+\t\tvar view = elem.ownerDocument.defaultView;\n+\n+\t\tif ( !view || !view.opener ) {\n+\t\t\tview = window;\n+\t\t}\n+\n+\t\treturn view.getComputedStyle( elem );\n+\t};\n+\n+var swap = function( elem, options, callback ) {\n+\tvar ret, name,\n+\t\told = {};\n+\n+\t// Remember the old values, and insert the new ones\n+\tfor ( name in options ) {\n+\t\told[ name ] = elem.style[ name ];\n+\t\telem.style[ name ] = options[ name ];\n+\t}\n+\n+\tret = callback.call( elem );\n+\n+\t// Revert the old values\n+\tfor ( name in options ) {\n+\t\telem.style[ name ] = old[ name ];\n+\t}\n+\n+\treturn ret;\n+};\n+\n+\n+var rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n+\n+var whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\n+\n+\n+var rtrimCSS = new RegExp(\n+\t\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\",\n+\t\"g\"\n+);\n+\n+\n+\n+\n+( function() {\n+\n+\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n+\t// so they're executed at the same time to save the second computation.\n+\tfunction computeStyleTests() {\n+\n+\t\t// This is a singleton, we need to execute it only once\n+\t\tif ( !div ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n+\t\t\t\"margin-top:1px;padding:0;border:0\";\n+\t\tdiv.style.cssText =\n+\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n+\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n+\t\t\t\"width:60%;top:1%\";\n+\t\tdocumentElement.appendChild( container ).appendChild( div );\n+\n+\t\tvar divStyle = window.getComputedStyle( div );\n+\t\tpixelPositionVal = divStyle.top !== \"1%\";\n+\n+\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n+\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n+\n+\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n+\t\t// Some styles come back with percentage values, even though they shouldn't\n+\t\tdiv.style.right = \"60%\";\n+\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n+\n+\t\t// Support: IE 9 - 11 only\n+\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n+\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n+\n+\t\t// Support: IE 9 only\n+\t\t// Detect overflow:scroll screwiness (gh-3699)\n+\t\t// Support: Chrome <=64\n+\t\t// Don't get tricked when zoom affects offsetWidth (gh-4029)\n+\t\tdiv.style.position = \"absolute\";\n+\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;\n+\n+\t\tdocumentElement.removeChild( container );\n+\n+\t\t// Nullify the div so it wouldn't be stored in the memory and\n+\t\t// it will also be a sign that checks already performed\n+\t\tdiv = null;\n+\t}\n+\n+\tfunction roundPixelMeasures( measure ) {\n+\t\treturn Math.round( parseFloat( measure ) );\n+\t}\n+\n+\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n+\t\treliableTrDimensionsVal, reliableMarginLeftVal,\n+\t\tcontainer = document.createElement( \"div\" ),\n+\t\tdiv = document.createElement( \"div\" );\n+\n+\t// Finish early in limited (non-browser) environments\n+\tif ( !div.style ) {\n+\t\treturn;\n+\t}\n+\n+\t// Support: IE <=9 - 11 only\n+\t// Style of cloned element affects source element cloned (trac-8908)\n+\tdiv.style.backgroundClip = \"content-box\";\n+\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n+\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n+\n+\tjQuery.extend( support, {\n+\t\tboxSizingReliable: function() {\n+\t\t\tcomputeStyleTests();\n+\t\t\treturn boxSizingReliableVal;\n+\t\t},\n+\t\tpixelBoxStyles: function() {\n+\t\t\tcomputeStyleTests();\n+\t\t\treturn pixelBoxStylesVal;\n+\t\t},\n+\t\tpixelPosition: function() {\n+\t\t\tcomputeStyleTests();\n+\t\t\treturn pixelPositionVal;\n+\t\t},\n+\t\treliableMarginLeft: function() {\n+\t\t\tcomputeStyleTests();\n+\t\t\treturn reliableMarginLeftVal;\n+\t\t},\n+\t\tscrollboxSize: function() {\n+\t\t\tcomputeStyleTests();\n+\t\t\treturn scrollboxSizeVal;\n+\t\t},\n+\n+\t\t// Support: IE 9 - 11+, Edge 15 - 18+\n+\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n+\t\t// set in CSS while `offset*` properties report correct values.\n+\t\t// Behavior in IE 9 is more subtle than in newer versions & it passes\n+\t\t// some versions of this test; make sure not to make it pass there!\n+\t\t//\n+\t\t// Support: Firefox 70+\n+\t\t// Only Firefox includes border widths\n+\t\t// in computed dimensions. (gh-4529)\n+\t\treliableTrDimensions: function() {\n+\t\t\tvar table, tr, trChild, trStyle;\n+\t\t\tif ( reliableTrDimensionsVal == null ) {\n+\t\t\t\ttable = document.createElement( \"table\" );\n+\t\t\t\ttr = document.createElement( \"tr\" );\n+\t\t\t\ttrChild = document.createElement( \"div\" );\n+\n+\t\t\t\ttable.style.cssText = \"position:absolute;left:-11111px;border-collapse:separate\";\n+\t\t\t\ttr.style.cssText = \"border:1px solid\";\n+\n+\t\t\t\t// Support: Chrome 86+\n+\t\t\t\t// Height set through cssText does not get applied.\n+\t\t\t\t// Computed height then comes back as 0.\n+\t\t\t\ttr.style.height = \"1px\";\n+\t\t\t\ttrChild.style.height = \"9px\";\n+\n+\t\t\t\t// Support: Android 8 Chrome 86+\n+\t\t\t\t// In our bodyBackground.html iframe,\n+\t\t\t\t// display for all div elements is set to \"inline\",\n+\t\t\t\t// which causes a problem only in Android 8 Chrome 86.\n+\t\t\t\t// Ensuring the div is display: block\n+\t\t\t\t// gets around this issue.\n+\t\t\t\ttrChild.style.display = \"block\";\n+\n+\t\t\t\tdocumentElement\n+\t\t\t\t\t.appendChild( table )\n+\t\t\t\t\t.appendChild( tr )\n+\t\t\t\t\t.appendChild( trChild );\n+\n+\t\t\t\ttrStyle = window.getComputedStyle( tr );\n+\t\t\t\treliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +\n+\t\t\t\t\tparseInt( trStyle.borderTopWidth, 10 ) +\n+\t\t\t\t\tparseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;\n+\n+\t\t\t\tdocumentElement.removeChild( table );\n+\t\t\t}\n+\t\t\treturn reliableTrDimensionsVal;\n+\t\t}\n+\t} );\n+} )();\n+\n+\n+function curCSS( elem, name, computed ) {\n+\tvar width, minWidth, maxWidth, ret,\n+\t\tisCustomProp = rcustomProp.test( name ),\n+\n+\t\t// Support: Firefox 51+\n+\t\t// Retrieving style before computed somehow\n+\t\t// fixes an issue with getting wrong values\n+\t\t// on detached elements\n+\t\tstyle = elem.style;\n+\n+\tcomputed = computed || getStyles( elem );\n+\n+\t// getPropertyValue is needed for:\n+\t//   .css('filter') (IE 9 only, trac-12537)\n+\t//   .css('--customProperty) (gh-3144)\n+\tif ( computed ) {\n+\n+\t\t// Support: IE <=9 - 11+\n+\t\t// IE only supports `\"float\"` in `getPropertyValue`; in computed styles\n+\t\t// it's only available as `\"cssFloat\"`. We no longer modify properties\n+\t\t// sent to `.css()` apart from camelCasing, so we need to check both.\n+\t\t// Normally, this would create difference in behavior: if\n+\t\t// `getPropertyValue` returns an empty string, the value returned\n+\t\t// by `.css()` would be `undefined`. This is usually the case for\n+\t\t// disconnected elements. However, in IE even disconnected elements\n+\t\t// with no styles return `\"none\"` for `getPropertyValue( \"float\" )`\n+\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n+\n+\t\tif ( isCustomProp && ret ) {\n+\n+\t\t\t// Support: Firefox 105+, Chrome <=105+\n+\t\t\t// Spec requires trimming whitespace for custom properties (gh-4926).\n+\t\t\t// Firefox only trims leading whitespace. Chrome just collapses\n+\t\t\t// both leading & trailing whitespace to a single space.\n+\t\t\t//\n+\t\t\t// Fall back to `undefined` if empty string returned.\n+\t\t\t// This collapses a missing definition with property defined\n+\t\t\t// and set to an empty string but there's no standard API\n+\t\t\t// allowing us to differentiate them without a performance penalty\n+\t\t\t// and returning `undefined` aligns with older jQuery.\n+\t\t\t//\n+\t\t\t// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED\n+\t\t\t// as whitespace while CSS does not, but this is not a problem\n+\t\t\t// because CSS preprocessing replaces them with U+000A LINE FEED\n+\t\t\t// (which *is* CSS whitespace)\n+\t\t\t// https://www.w3.org/TR/css-syntax-3/#input-preprocessing\n+\t\t\tret = ret.replace( rtrimCSS, \"$1\" ) || undefined;\n+\t\t}\n+\n+\t\tif ( ret === \"\" && !isAttached( elem ) ) {\n+\t\t\tret = jQuery.style( elem, name );\n+\t\t}\n+\n+\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n+\t\t// Android Browser returns percentage for some values,\n+\t\t// but width seems to be reliably pixels.\n+\t\t// This is against the CSSOM draft spec:\n+\t\t// https://drafts.csswg.org/cssom/#resolved-values\n+\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n+\n+\t\t\t// Remember the original values\n+\t\t\twidth = style.width;\n+\t\t\tminWidth = style.minWidth;\n+\t\t\tmaxWidth = style.maxWidth;\n+\n+\t\t\t// Put in the new values to get a computed value out\n+\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n+\t\t\tret = computed.width;\n+\n+\t\t\t// Revert the changed values\n+\t\t\tstyle.width = width;\n+\t\t\tstyle.minWidth = minWidth;\n+\t\t\tstyle.maxWidth = maxWidth;\n+\t\t}\n+\t}\n+\n+\treturn ret !== undefined ?\n+\n+\t\t// Support: IE <=9 - 11 only\n+\t\t// IE returns zIndex value as an integer.\n+\t\tret + \"\" :\n+\t\tret;\n+}\n+\n+\n+function addGetHookIf( conditionFn, hookFn ) {\n+\n+\t// Define the hook, we'll check on the first run if it's really needed.\n+\treturn {\n+\t\tget: function() {\n+\t\t\tif ( conditionFn() ) {\n+\n+\t\t\t\t// Hook not needed (or it's not possible to use it due\n+\t\t\t\t// to missing dependency), remove it.\n+\t\t\t\tdelete this.get;\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n+\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n+\t\t}\n+\t};\n+}\n+\n+\n+var cssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n+\temptyStyle = document.createElement( \"div\" ).style,\n+\tvendorProps = {};\n+\n+// Return a vendor-prefixed property or undefined\n+function vendorPropName( name ) {\n+\n+\t// Check for vendor prefixed names\n+\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n+\t\ti = cssPrefixes.length;\n+\n+\twhile ( i-- ) {\n+\t\tname = cssPrefixes[ i ] + capName;\n+\t\tif ( name in emptyStyle ) {\n+\t\t\treturn name;\n+\t\t}\n+\t}\n+}\n+\n+// Return a potentially-mapped jQuery.cssProps or vendor prefixed property\n+function finalPropName( name ) {\n+\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n+\n+\tif ( final ) {\n+\t\treturn final;\n+\t}\n+\tif ( name in emptyStyle ) {\n+\t\treturn name;\n+\t}\n+\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n+}\n+\n+\n+var\n+\n+\t// Swappable if display is none or starts with table\n+\t// except \"table\", \"table-cell\", or \"table-caption\"\n+\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n+\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n+\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n+\tcssNormalTransform = {\n+\t\tletterSpacing: \"0\",\n+\t\tfontWeight: \"400\"\n+\t};\n+\n+function setPositiveNumber( _elem, value, subtract ) {\n+\n+\t// Any relative (+/-) values have already been\n+\t// normalized at this point\n+\tvar matches = rcssNum.exec( value );\n+\treturn matches ?\n+\n+\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n+\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n+\t\tvalue;\n+}\n+\n+function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n+\tvar i = dimension === \"width\" ? 1 : 0,\n+\t\textra = 0,\n+\t\tdelta = 0;\n+\n+\t// Adjustment may not be necessary\n+\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n+\t\treturn 0;\n+\t}\n+\n+\tfor ( ; i < 4; i += 2 ) {\n+\n+\t\t// Both box models exclude margin\n+\t\tif ( box === \"margin\" ) {\n+\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n+\t\t}\n+\n+\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n+\t\tif ( !isBorderBox ) {\n+\n+\t\t\t// Add padding\n+\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n+\n+\t\t\t// For \"border\" or \"margin\", add border\n+\t\t\tif ( box !== \"padding\" ) {\n+\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n+\n+\t\t\t// But still keep track of it otherwise\n+\t\t\t} else {\n+\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n+\t\t\t}\n+\n+\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n+\t\t// \"padding\" or \"margin\"\n+\t\t} else {\n+\n+\t\t\t// For \"content\", subtract padding\n+\t\t\tif ( box === \"content\" ) {\n+\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n+\t\t\t}\n+\n+\t\t\t// For \"content\" or \"padding\", subtract border\n+\t\t\tif ( box !== \"margin\" ) {\n+\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Account for positive content-box scroll gutter when requested by providing computedVal\n+\tif ( !isBorderBox && computedVal >= 0 ) {\n+\n+\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n+\t\t// Assuming integer scroll gutter, subtract the rest and round down\n+\t\tdelta += Math.max( 0, Math.ceil(\n+\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n+\t\t\tcomputedVal -\n+\t\t\tdelta -\n+\t\t\textra -\n+\t\t\t0.5\n+\n+\t\t// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n+\t\t// Use an explicit zero to avoid NaN (gh-3964)\n+\t\t) ) || 0;\n+\t}\n+\n+\treturn delta;\n+}\n+\n+function getWidthOrHeight( elem, dimension, extra ) {\n+\n+\t// Start with computed style\n+\tvar styles = getStyles( elem ),\n+\n+\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n+\t\t// Fake content-box until we know it's needed to know the true value.\n+\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n+\t\tisBorderBox = boxSizingNeeded &&\n+\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n+\t\tvalueIsBorderBox = isBorderBox,\n+\n+\t\tval = curCSS( elem, dimension, styles ),\n+\t\toffsetProp = \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n+\n+\t// Support: Firefox <=54\n+\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n+\tif ( rnumnonpx.test( val ) ) {\n+\t\tif ( !extra ) {\n+\t\t\treturn val;\n+\t\t}\n+\t\tval = \"auto\";\n+\t}\n+\n+\n+\t// Support: IE 9 - 11 only\n+\t// Use offsetWidth/offsetHeight for when box sizing is unreliable.\n+\t// In those cases, the computed value can be trusted to be border-box.\n+\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n+\n+\t\t// Support: IE 10 - 11+, Edge 15 - 18+\n+\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n+\t\t// set in CSS while `offset*` properties report correct values.\n+\t\t// Interestingly, in some cases IE 9 doesn't suffer from this issue.\n+\t\t!support.reliableTrDimensions() && nodeName( elem, \"tr\" ) ||\n+\n+\t\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n+\t\t// This happens for inline elements with no explicit setting (gh-3571)\n+\t\tval === \"auto\" ||\n+\n+\t\t// Support: Android <=4.1 - 4.3 only\n+\t\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n+\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) &&\n+\n+\t\t// Make sure the element is visible & connected\n+\t\telem.getClientRects().length ) {\n+\n+\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n+\n+\t\t// Where available, offsetWidth/offsetHeight approximate border box dimensions.\n+\t\t// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n+\t\t// retrieved value as a content box dimension.\n+\t\tvalueIsBorderBox = offsetProp in elem;\n+\t\tif ( valueIsBorderBox ) {\n+\t\t\tval = elem[ offsetProp ];\n+\t\t}\n+\t}\n+\n+\t// Normalize \"\" and auto\n+\tval = parseFloat( val ) || 0;\n+\n+\t// Adjust for the element's box model\n+\treturn ( val +\n+\t\tboxModelAdjustment(\n+\t\t\telem,\n+\t\t\tdimension,\n+\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n+\t\t\tvalueIsBorderBox,\n+\t\t\tstyles,\n+\n+\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n+\t\t\tval\n+\t\t)\n+\t) + \"px\";\n+}\n+\n+jQuery.extend( {\n+\n+\t// Add in style property hooks for overriding the default\n+\t// behavior of getting and setting a style property\n+\tcssHooks: {\n+\t\topacity: {\n+\t\t\tget: function( elem, computed ) {\n+\t\t\t\tif ( computed ) {\n+\n+\t\t\t\t\t// We should always get a number back from opacity\n+\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n+\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t},\n+\n+\t// Don't automatically add \"px\" to these possibly-unitless properties\n+\tcssNumber: {\n+\t\t\"animationIterationCount\": true,\n+\t\t\"columnCount\": true,\n+\t\t\"fillOpacity\": true,\n+\t\t\"flexGrow\": true,\n+\t\t\"flexShrink\": true,\n+\t\t\"fontWeight\": true,\n+\t\t\"gridArea\": true,\n+\t\t\"gridColumn\": true,\n+\t\t\"gridColumnEnd\": true,\n+\t\t\"gridColumnStart\": true,\n+\t\t\"gridRow\": true,\n+\t\t\"gridRowEnd\": true,\n+\t\t\"gridRowStart\": true,\n+\t\t\"lineHeight\": true,\n+\t\t\"opacity\": true,\n+\t\t\"order\": true,\n+\t\t\"orphans\": true,\n+\t\t\"widows\": true,\n+\t\t\"zIndex\": true,\n+\t\t\"zoom\": true\n+\t},\n+\n+\t// Add in properties whose names you wish to fix before\n+\t// setting or getting the value\n+\tcssProps: {},\n+\n+\t// Get and set the style property on a DOM Node\n+\tstyle: function( elem, name, value, extra ) {\n+\n+\t\t// Don't set styles on text and comment nodes\n+\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Make sure that we're working with the right name\n+\t\tvar ret, type, hooks,\n+\t\t\torigName = camelCase( name ),\n+\t\t\tisCustomProp = rcustomProp.test( name ),\n+\t\t\tstyle = elem.style;\n+\n+\t\t// Make sure that we're working with the right name. We don't\n+\t\t// want to query the value if it is a CSS custom property\n+\t\t// since they are user-defined.\n+\t\tif ( !isCustomProp ) {\n+\t\t\tname = finalPropName( origName );\n+\t\t}\n+\n+\t\t// Gets hook for the prefixed version, then unprefixed version\n+\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n+\n+\t\t// Check if we're setting a value\n+\t\tif ( value !== undefined ) {\n+\t\t\ttype = typeof value;\n+\n+\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (trac-7345)\n+\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n+\t\t\t\tvalue = adjustCSS( elem, name, ret );\n+\n+\t\t\t\t// Fixes bug trac-9237\n+\t\t\t\ttype = \"number\";\n+\t\t\t}\n+\n+\t\t\t// Make sure that null and NaN values aren't set (trac-7116)\n+\t\t\tif ( value == null || value !== value ) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n+\t\t\t// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n+\t\t\t// \"px\" to a few hardcoded values.\n+\t\t\tif ( type === \"number\" && !isCustomProp ) {\n+\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n+\t\t\t}\n+\n+\t\t\t// background-* props affect original clone's values\n+\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n+\t\t\t\tstyle[ name ] = \"inherit\";\n+\t\t\t}\n+\n+\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n+\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n+\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n+\n+\t\t\t\tif ( isCustomProp ) {\n+\t\t\t\t\tstyle.setProperty( name, value );\n+\t\t\t\t} else {\n+\t\t\t\t\tstyle[ name ] = value;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t} else {\n+\n+\t\t\t// If a hook was provided get the non-computed value from there\n+\t\t\tif ( hooks && \"get\" in hooks &&\n+\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n+\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\n+\t\t\t// Otherwise just get the value from the style object\n+\t\t\treturn style[ name ];\n+\t\t}\n+\t},\n+\n+\tcss: function( elem, name, extra, styles ) {\n+\t\tvar val, num, hooks,\n+\t\t\torigName = camelCase( name ),\n+\t\t\tisCustomProp = rcustomProp.test( name );\n+\n+\t\t// Make sure that we're working with the right name. We don't\n+\t\t// want to modify the value if it is a CSS custom property\n+\t\t// since they are user-defined.\n+\t\tif ( !isCustomProp ) {\n+\t\t\tname = finalPropName( origName );\n+\t\t}\n+\n+\t\t// Try prefixed name followed by the unprefixed name\n+\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n+\n+\t\t// If a hook was provided get the computed value from there\n+\t\tif ( hooks && \"get\" in hooks ) {\n+\t\t\tval = hooks.get( elem, true, extra );\n+\t\t}\n+\n+\t\t// Otherwise, if a way to get the computed value exists, use that\n+\t\tif ( val === undefined ) {\n+\t\t\tval = curCSS( elem, name, styles );\n+\t\t}\n+\n+\t\t// Convert \"normal\" to computed value\n+\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n+\t\t\tval = cssNormalTransform[ name ];\n+\t\t}\n+\n+\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n+\t\tif ( extra === \"\" || extra ) {\n+\t\t\tnum = parseFloat( val );\n+\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n+\t\t}\n+\n+\t\treturn val;\n+\t}\n+} );\n+\n+jQuery.each( [ \"height\", \"width\" ], function( _i, dimension ) {\n+\tjQuery.cssHooks[ dimension ] = {\n+\t\tget: function( elem, computed, extra ) {\n+\t\t\tif ( computed ) {\n+\n+\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n+\t\t\t\t// but it must have a current display style that would benefit\n+\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n+\n+\t\t\t\t\t// Support: Safari 8+\n+\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n+\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n+\t\t\t\t\t// Support: IE <=11 only\n+\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n+\t\t\t\t\t// in IE throws an error.\n+\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n+\t\t\t\t\tswap( elem, cssShow, function() {\n+\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n+\t\t\t\t\t} ) :\n+\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n+\t\t\t}\n+\t\t},\n+\n+\t\tset: function( elem, value, extra ) {\n+\t\t\tvar matches,\n+\t\t\t\tstyles = getStyles( elem ),\n+\n+\t\t\t\t// Only read styles.position if the test has a chance to fail\n+\t\t\t\t// to avoid forcing a reflow.\n+\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n+\t\t\t\t\tstyles.position === \"absolute\",\n+\n+\t\t\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n+\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n+\t\t\t\tisBorderBox = boxSizingNeeded &&\n+\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n+\t\t\t\tsubtract = extra ?\n+\t\t\t\t\tboxModelAdjustment(\n+\t\t\t\t\t\telem,\n+\t\t\t\t\t\tdimension,\n+\t\t\t\t\t\textra,\n+\t\t\t\t\t\tisBorderBox,\n+\t\t\t\t\t\tstyles\n+\t\t\t\t\t) :\n+\t\t\t\t\t0;\n+\n+\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n+\t\t\t// faking a content-box to get border and padding (gh-3699)\n+\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n+\t\t\t\tsubtract -= Math.ceil(\n+\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n+\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n+\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n+\t\t\t\t\t0.5\n+\t\t\t\t);\n+\t\t\t}\n+\n+\t\t\t// Convert to pixels if value adjustment is needed\n+\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n+\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n+\n+\t\t\t\telem.style[ dimension ] = value;\n+\t\t\t\tvalue = jQuery.css( elem, dimension );\n+\t\t\t}\n+\n+\t\t\treturn setPositiveNumber( elem, value, subtract );\n+\t\t}\n+\t};\n+} );\n+\n+jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n+\tfunction( elem, computed ) {\n+\t\tif ( computed ) {\n+\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n+\t\t\t\telem.getBoundingClientRect().left -\n+\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n+\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n+\t\t\t\t\t} )\n+\t\t\t) + \"px\";\n+\t\t}\n+\t}\n+);\n+\n+// These hooks are used by animate to expand properties\n+jQuery.each( {\n+\tmargin: \"\",\n+\tpadding: \"\",\n+\tborder: \"Width\"\n+}, function( prefix, suffix ) {\n+\tjQuery.cssHooks[ prefix + suffix ] = {\n+\t\texpand: function( value ) {\n+\t\t\tvar i = 0,\n+\t\t\t\texpanded = {},\n+\n+\t\t\t\t// Assumes a single number if not a string\n+\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n+\n+\t\t\tfor ( ; i < 4; i++ ) {\n+\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n+\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n+\t\t\t}\n+\n+\t\t\treturn expanded;\n+\t\t}\n+\t};\n+\n+\tif ( prefix !== \"margin\" ) {\n+\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n+\t}\n+} );\n+\n+jQuery.fn.extend( {\n+\tcss: function( name, value ) {\n+\t\treturn access( this, function( elem, name, value ) {\n+\t\t\tvar styles, len,\n+\t\t\t\tmap = {},\n+\t\t\t\ti = 0;\n+\n+\t\t\tif ( Array.isArray( name ) ) {\n+\t\t\t\tstyles = getStyles( elem );\n+\t\t\t\tlen = name.length;\n+\n+\t\t\t\tfor ( ; i < len; i++ ) {\n+\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n+\t\t\t\t}\n+\n+\t\t\t\treturn map;\n+\t\t\t}\n+\n+\t\t\treturn value !== undefined ?\n+\t\t\t\tjQuery.style( elem, name, value ) :\n+\t\t\t\tjQuery.css( elem, name );\n+\t\t}, name, value, arguments.length > 1 );\n+\t}\n+} );\n+\n+\n+function Tween( elem, options, prop, end, easing ) {\n+\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n+}\n+jQuery.Tween = Tween;\n+\n+Tween.prototype = {\n+\tconstructor: Tween,\n+\tinit: function( elem, options, prop, end, easing, unit ) {\n+\t\tthis.elem = elem;\n+\t\tthis.prop = prop;\n+\t\tthis.easing = easing || jQuery.easing._default;\n+\t\tthis.options = options;\n+\t\tthis.start = this.now = this.cur();\n+\t\tthis.end = end;\n+\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n+\t},\n+\tcur: function() {\n+\t\tvar hooks = Tween.propHooks[ this.prop ];\n+\n+\t\treturn hooks && hooks.get ?\n+\t\t\thooks.get( this ) :\n+\t\t\tTween.propHooks._default.get( this );\n+\t},\n+\trun: function( percent ) {\n+\t\tvar eased,\n+\t\t\thooks = Tween.propHooks[ this.prop ];\n+\n+\t\tif ( this.options.duration ) {\n+\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n+\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n+\t\t\t);\n+\t\t} else {\n+\t\t\tthis.pos = eased = percent;\n+\t\t}\n+\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n+\n+\t\tif ( this.options.step ) {\n+\t\t\tthis.options.step.call( this.elem, this.now, this );\n+\t\t}\n+\n+\t\tif ( hooks && hooks.set ) {\n+\t\t\thooks.set( this );\n+\t\t} else {\n+\t\t\tTween.propHooks._default.set( this );\n+\t\t}\n+\t\treturn this;\n+\t}\n+};\n+\n+Tween.prototype.init.prototype = Tween.prototype;\n+\n+Tween.propHooks = {\n+\t_default: {\n+\t\tget: function( tween ) {\n+\t\t\tvar result;\n+\n+\t\t\t// Use a property on the element directly when it is not a DOM element,\n+\t\t\t// or when there is no matching style property that exists.\n+\t\t\tif ( tween.elem.nodeType !== 1 ||\n+\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n+\t\t\t\treturn tween.elem[ tween.prop ];\n+\t\t\t}\n+\n+\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n+\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n+\t\t\t// Simple values such as \"10px\" are parsed to Float;\n+\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n+\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n+\n+\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n+\t\t\treturn !result || result === \"auto\" ? 0 : result;\n+\t\t},\n+\t\tset: function( tween ) {\n+\n+\t\t\t// Use step hook for back compat.\n+\t\t\t// Use cssHook if its there.\n+\t\t\t// Use .style if available and use plain properties where available.\n+\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n+\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n+\t\t\t} else if ( tween.elem.nodeType === 1 && (\n+\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n+\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n+\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n+\t\t\t} else {\n+\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n+\t\t\t}\n+\t\t}\n+\t}\n+};\n+\n+// Support: IE <=9 only\n+// Panic based approach to setting things on disconnected nodes\n+Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n+\tset: function( tween ) {\n+\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n+\t\t\ttween.elem[ tween.prop ] = tween.now;\n+\t\t}\n+\t}\n+};\n+\n+jQuery.easing = {\n+\tlinear: function( p ) {\n+\t\treturn p;\n+\t},\n+\tswing: function( p ) {\n+\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n+\t},\n+\t_default: \"swing\"\n+};\n+\n+jQuery.fx = Tween.prototype.init;\n+\n+// Back compat <1.8 extension point\n+jQuery.fx.step = {};\n+\n+\n+\n+\n+var\n+\tfxNow, inProgress,\n+\trfxtypes = /^(?:toggle|show|hide)$/,\n+\trrun = /queueHooks$/;\n+\n+function schedule() {\n+\tif ( inProgress ) {\n+\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n+\t\t\twindow.requestAnimationFrame( schedule );\n+\t\t} else {\n+\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n+\t\t}\n+\n+\t\tjQuery.fx.tick();\n+\t}\n+}\n+\n+// Animations created synchronously will run synchronously\n+function createFxNow() {\n+\twindow.setTimeout( function() {\n+\t\tfxNow = undefined;\n+\t} );\n+\treturn ( fxNow = Date.now() );\n+}\n+\n+// Generate parameters to create a standard animation\n+function genFx( type, includeWidth ) {\n+\tvar which,\n+\t\ti = 0,\n+\t\tattrs = { height: type };\n+\n+\t// If we include width, step value is 1 to do all cssExpand values,\n+\t// otherwise step value is 2 to skip over Left and Right\n+\tincludeWidth = includeWidth ? 1 : 0;\n+\tfor ( ; i < 4; i += 2 - includeWidth ) {\n+\t\twhich = cssExpand[ i ];\n+\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n+\t}\n+\n+\tif ( includeWidth ) {\n+\t\tattrs.opacity = attrs.width = type;\n+\t}\n+\n+\treturn attrs;\n+}\n+\n+function createTween( value, prop, animation ) {\n+\tvar tween,\n+\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n+\t\tindex = 0,\n+\t\tlength = collection.length;\n+\tfor ( ; index < length; index++ ) {\n+\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n+\n+\t\t\t// We're done with this property\n+\t\t\treturn tween;\n+\t\t}\n+\t}\n+}\n+\n+function defaultPrefilter( elem, props, opts ) {\n+\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n+\t\tisBox = \"width\" in props || \"height\" in props,\n+\t\tanim = this,\n+\t\torig = {},\n+\t\tstyle = elem.style,\n+\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n+\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n+\n+\t// Queue-skipping animations hijack the fx hooks\n+\tif ( !opts.queue ) {\n+\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n+\t\tif ( hooks.unqueued == null ) {\n+\t\t\thooks.unqueued = 0;\n+\t\t\toldfire = hooks.empty.fire;\n+\t\t\thooks.empty.fire = function() {\n+\t\t\t\tif ( !hooks.unqueued ) {\n+\t\t\t\t\toldfire();\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t\thooks.unqueued++;\n+\n+\t\tanim.always( function() {\n+\n+\t\t\t// Ensure the complete handler is called before this completes\n+\t\t\tanim.always( function() {\n+\t\t\t\thooks.unqueued--;\n+\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n+\t\t\t\t\thooks.empty.fire();\n+\t\t\t\t}\n+\t\t\t} );\n+\t\t} );\n+\t}\n+\n+\t// Detect show/hide animations\n+\tfor ( prop in props ) {\n+\t\tvalue = props[ prop ];\n+\t\tif ( rfxtypes.test( value ) ) {\n+\t\t\tdelete props[ prop ];\n+\t\t\ttoggle = toggle || value === \"toggle\";\n+\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n+\n+\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n+\t\t\t\t// there is still data from a stopped show/hide\n+\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n+\t\t\t\t\thidden = true;\n+\n+\t\t\t\t// Ignore all other no-op show/hide data\n+\t\t\t\t} else {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n+\t\t}\n+\t}\n+\n+\t// Bail out if this is a no-op like .hide().hide()\n+\tpropTween = !jQuery.isEmptyObject( props );\n+\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n+\t\treturn;\n+\t}\n+\n+\t// Restrict \"overflow\" and \"display\" styles during box animations\n+\tif ( isBox && elem.nodeType === 1 ) {\n+\n+\t\t// Support: IE <=9 - 11, Edge 12 - 15\n+\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n+\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n+\t\t// the overflowX value there.\n+\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n+\n+\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n+\t\trestoreDisplay = dataShow && dataShow.display;\n+\t\tif ( restoreDisplay == null ) {\n+\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n+\t\t}\n+\t\tdisplay = jQuery.css( elem, \"display\" );\n+\t\tif ( display === \"none\" ) {\n+\t\t\tif ( restoreDisplay ) {\n+\t\t\t\tdisplay = restoreDisplay;\n+\t\t\t} else {\n+\n+\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n+\t\t\t\tshowHide( [ elem ], true );\n+\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n+\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n+\t\t\t\tshowHide( [ elem ] );\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Animate inline elements as inline-block\n+\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n+\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n+\n+\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n+\t\t\t\tif ( !propTween ) {\n+\t\t\t\t\tanim.done( function() {\n+\t\t\t\t\t\tstyle.display = restoreDisplay;\n+\t\t\t\t\t} );\n+\t\t\t\t\tif ( restoreDisplay == null ) {\n+\t\t\t\t\t\tdisplay = style.display;\n+\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tstyle.display = \"inline-block\";\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif ( opts.overflow ) {\n+\t\tstyle.overflow = \"hidden\";\n+\t\tanim.always( function() {\n+\t\t\tstyle.overflow = opts.overflow[ 0 ];\n+\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n+\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n+\t\t} );\n+\t}\n+\n+\t// Implement show/hide animations\n+\tpropTween = false;\n+\tfor ( prop in orig ) {\n+\n+\t\t// General show/hide setup for this element animation\n+\t\tif ( !propTween ) {\n+\t\t\tif ( dataShow ) {\n+\t\t\t\tif ( \"hidden\" in dataShow ) {\n+\t\t\t\t\thidden = dataShow.hidden;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n+\t\t\t}\n+\n+\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n+\t\t\tif ( toggle ) {\n+\t\t\t\tdataShow.hidden = !hidden;\n+\t\t\t}\n+\n+\t\t\t// Show elements before animating them\n+\t\t\tif ( hidden ) {\n+\t\t\t\tshowHide( [ elem ], true );\n+\t\t\t}\n+\n+\t\t\t/* eslint-disable no-loop-func */\n+\n+\t\t\tanim.done( function() {\n+\n+\t\t\t\t/* eslint-enable no-loop-func */\n+\n+\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n+\t\t\t\tif ( !hidden ) {\n+\t\t\t\t\tshowHide( [ elem ] );\n+\t\t\t\t}\n+\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n+\t\t\t\tfor ( prop in orig ) {\n+\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n+\t\t\t\t}\n+\t\t\t} );\n+\t\t}\n+\n+\t\t// Per-property setup\n+\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n+\t\tif ( !( prop in dataShow ) ) {\n+\t\t\tdataShow[ prop ] = propTween.start;\n+\t\t\tif ( hidden ) {\n+\t\t\t\tpropTween.end = propTween.start;\n+\t\t\t\tpropTween.start = 0;\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+function propFilter( props, specialEasing ) {\n+\tvar index, name, easing, value, hooks;\n+\n+\t// camelCase, specialEasing and expand cssHook pass\n+\tfor ( index in props ) {\n+\t\tname = camelCase( index );\n+\t\teasing = specialEasing[ name ];\n+\t\tvalue = props[ index ];\n+\t\tif ( Array.isArray( value ) ) {\n+\t\t\teasing = value[ 1 ];\n+\t\t\tvalue = props[ index ] = value[ 0 ];\n+\t\t}\n+\n+\t\tif ( index !== name ) {\n+\t\t\tprops[ name ] = value;\n+\t\t\tdelete props[ index ];\n+\t\t}\n+\n+\t\thooks = jQuery.cssHooks[ name ];\n+\t\tif ( hooks && \"expand\" in hooks ) {\n+\t\t\tvalue = hooks.expand( value );\n+\t\t\tdelete props[ name ];\n+\n+\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n+\t\t\t// Reusing 'index' because we have the correct \"name\"\n+\t\t\tfor ( index in value ) {\n+\t\t\t\tif ( !( index in props ) ) {\n+\t\t\t\t\tprops[ index ] = value[ index ];\n+\t\t\t\t\tspecialEasing[ index ] = easing;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tspecialEasing[ name ] = easing;\n+\t\t}\n+\t}\n+}\n+\n+function Animation( elem, properties, options ) {\n+\tvar result,\n+\t\tstopped,\n+\t\tindex = 0,\n+\t\tlength = Animation.prefilters.length,\n+\t\tdeferred = jQuery.Deferred().always( function() {\n+\n+\t\t\t// Don't match elem in the :animated selector\n+\t\t\tdelete tick.elem;\n+\t\t} ),\n+\t\ttick = function() {\n+\t\t\tif ( stopped ) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tvar currentTime = fxNow || createFxNow(),\n+\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n+\n+\t\t\t\t// Support: Android 2.3 only\n+\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)\n+\t\t\t\ttemp = remaining / animation.duration || 0,\n+\t\t\t\tpercent = 1 - temp,\n+\t\t\t\tindex = 0,\n+\t\t\t\tlength = animation.tweens.length;\n+\n+\t\t\tfor ( ; index < length; index++ ) {\n+\t\t\t\tanimation.tweens[ index ].run( percent );\n+\t\t\t}\n+\n+\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n+\n+\t\t\t// If there's more to do, yield\n+\t\t\tif ( percent < 1 && length ) {\n+\t\t\t\treturn remaining;\n+\t\t\t}\n+\n+\t\t\t// If this was an empty animation, synthesize a final progress notification\n+\t\t\tif ( !length ) {\n+\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n+\t\t\t}\n+\n+\t\t\t// Resolve the animation and report its conclusion\n+\t\t\tdeferred.resolveWith( elem, [ animation ] );\n+\t\t\treturn false;\n+\t\t},\n+\t\tanimation = deferred.promise( {\n+\t\t\telem: elem,\n+\t\t\tprops: jQuery.extend( {}, properties ),\n+\t\t\topts: jQuery.extend( true, {\n+\t\t\t\tspecialEasing: {},\n+\t\t\t\teasing: jQuery.easing._default\n+\t\t\t}, options ),\n+\t\t\toriginalProperties: properties,\n+\t\t\toriginalOptions: options,\n+\t\t\tstartTime: fxNow || createFxNow(),\n+\t\t\tduration: options.duration,\n+\t\t\ttweens: [],\n+\t\t\tcreateTween: function( prop, end ) {\n+\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n+\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n+\t\t\t\tanimation.tweens.push( tween );\n+\t\t\t\treturn tween;\n+\t\t\t},\n+\t\t\tstop: function( gotoEnd ) {\n+\t\t\t\tvar index = 0,\n+\n+\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n+\t\t\t\t\t// otherwise we skip this part\n+\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n+\t\t\t\tif ( stopped ) {\n+\t\t\t\t\treturn this;\n+\t\t\t\t}\n+\t\t\t\tstopped = true;\n+\t\t\t\tfor ( ; index < length; index++ ) {\n+\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n+\t\t\t\t}\n+\n+\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n+\t\t\t\tif ( gotoEnd ) {\n+\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n+\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n+\t\t\t\t} else {\n+\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n+\t\t\t\t}\n+\t\t\t\treturn this;\n+\t\t\t}\n+\t\t} ),\n+\t\tprops = animation.props;\n+\n+\tpropFilter( props, animation.opts.specialEasing );\n+\n+\tfor ( ; index < length; index++ ) {\n+\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n+\t\tif ( result ) {\n+\t\t\tif ( isFunction( result.stop ) ) {\n+\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n+\t\t\t\t\tresult.stop.bind( result );\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\t}\n+\n+\tjQuery.map( props, createTween, animation );\n+\n+\tif ( isFunction( animation.opts.start ) ) {\n+\t\tanimation.opts.start.call( elem, animation );\n+\t}\n+\n+\t// Attach callbacks from options\n+\tanimation\n+\t\t.progress( animation.opts.progress )\n+\t\t.done( animation.opts.done, animation.opts.complete )\n+\t\t.fail( animation.opts.fail )\n+\t\t.always( animation.opts.always );\n+\n+\tjQuery.fx.timer(\n+\t\tjQuery.extend( tick, {\n+\t\t\telem: elem,\n+\t\t\tanim: animation,\n+\t\t\tqueue: animation.opts.queue\n+\t\t} )\n+\t);\n+\n+\treturn animation;\n+}\n+\n+jQuery.Animation = jQuery.extend( Animation, {\n+\n+\ttweeners: {\n+\t\t\"*\": [ function( prop, value ) {\n+\t\t\tvar tween = this.createTween( prop, value );\n+\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n+\t\t\treturn tween;\n+\t\t} ]\n+\t},\n+\n+\ttweener: function( props, callback ) {\n+\t\tif ( isFunction( props ) ) {\n+\t\t\tcallback = props;\n+\t\t\tprops = [ \"*\" ];\n+\t\t} else {\n+\t\t\tprops = props.match( rnothtmlwhite );\n+\t\t}\n+\n+\t\tvar prop,\n+\t\t\tindex = 0,\n+\t\t\tlength = props.length;\n+\n+\t\tfor ( ; index < length; index++ ) {\n+\t\t\tprop = props[ index ];\n+\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n+\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n+\t\t}\n+\t},\n+\n+\tprefilters: [ defaultPrefilter ],\n+\n+\tprefilter: function( callback, prepend ) {\n+\t\tif ( prepend ) {\n+\t\t\tAnimation.prefilters.unshift( callback );\n+\t\t} else {\n+\t\t\tAnimation.prefilters.push( callback );\n+\t\t}\n+\t}\n+} );\n+\n+jQuery.speed = function( speed, easing, fn ) {\n+\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n+\t\tcomplete: fn || !fn && easing ||\n+\t\t\tisFunction( speed ) && speed,\n+\t\tduration: speed,\n+\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n+\t};\n+\n+\t// Go to the end state if fx are off\n+\tif ( jQuery.fx.off ) {\n+\t\topt.duration = 0;\n+\n+\t} else {\n+\t\tif ( typeof opt.duration !== \"number\" ) {\n+\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n+\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n+\n+\t\t\t} else {\n+\t\t\t\topt.duration = jQuery.fx.speeds._default;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n+\tif ( opt.queue == null || opt.queue === true ) {\n+\t\topt.queue = \"fx\";\n+\t}\n+\n+\t// Queueing\n+\topt.old = opt.complete;\n+\n+\topt.complete = function() {\n+\t\tif ( isFunction( opt.old ) ) {\n+\t\t\topt.old.call( this );\n+\t\t}\n+\n+\t\tif ( opt.queue ) {\n+\t\t\tjQuery.dequeue( this, opt.queue );\n+\t\t}\n+\t};\n+\n+\treturn opt;\n+};\n+\n+jQuery.fn.extend( {\n+\tfadeTo: function( speed, to, easing, callback ) {\n+\n+\t\t// Show any hidden elements after setting opacity to 0\n+\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n+\n+\t\t\t// Animate to the value specified\n+\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n+\t},\n+\tanimate: function( prop, speed, easing, callback ) {\n+\t\tvar empty = jQuery.isEmptyObject( prop ),\n+\t\t\toptall = jQuery.speed( speed, easing, callback ),\n+\t\t\tdoAnimation = function() {\n+\n+\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n+\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n+\n+\t\t\t\t// Empty animations, or finishing resolves immediately\n+\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n+\t\t\t\t\tanim.stop( true );\n+\t\t\t\t}\n+\t\t\t};\n+\n+\t\tdoAnimation.finish = doAnimation;\n+\n+\t\treturn empty || optall.queue === false ?\n+\t\t\tthis.each( doAnimation ) :\n+\t\t\tthis.queue( optall.queue, doAnimation );\n+\t},\n+\tstop: function( type, clearQueue, gotoEnd ) {\n+\t\tvar stopQueue = function( hooks ) {\n+\t\t\tvar stop = hooks.stop;\n+\t\t\tdelete hooks.stop;\n+\t\t\tstop( gotoEnd );\n+\t\t};\n+\n+\t\tif ( typeof type !== \"string\" ) {\n+\t\t\tgotoEnd = clearQueue;\n+\t\t\tclearQueue = type;\n+\t\t\ttype = undefined;\n+\t\t}\n+\t\tif ( clearQueue ) {\n+\t\t\tthis.queue( type || \"fx\", [] );\n+\t\t}\n+\n+\t\treturn this.each( function() {\n+\t\t\tvar dequeue = true,\n+\t\t\t\tindex = type != null && type + \"queueHooks\",\n+\t\t\t\ttimers = jQuery.timers,\n+\t\t\t\tdata = dataPriv.get( this );\n+\n+\t\t\tif ( index ) {\n+\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n+\t\t\t\t\tstopQueue( data[ index ] );\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfor ( index in data ) {\n+\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n+\t\t\t\t\t\tstopQueue( data[ index ] );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfor ( index = timers.length; index--; ) {\n+\t\t\t\tif ( timers[ index ].elem === this &&\n+\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n+\n+\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n+\t\t\t\t\tdequeue = false;\n+\t\t\t\t\ttimers.splice( index, 1 );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Start the next in the queue if the last step wasn't forced.\n+\t\t\t// Timers currently will call their complete callbacks, which\n+\t\t\t// will dequeue but only if they were gotoEnd.\n+\t\t\tif ( dequeue || !gotoEnd ) {\n+\t\t\t\tjQuery.dequeue( this, type );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\tfinish: function( type ) {\n+\t\tif ( type !== false ) {\n+\t\t\ttype = type || \"fx\";\n+\t\t}\n+\t\treturn this.each( function() {\n+\t\t\tvar index,\n+\t\t\t\tdata = dataPriv.get( this ),\n+\t\t\t\tqueue = data[ type + \"queue\" ],\n+\t\t\t\thooks = data[ type + \"queueHooks\" ],\n+\t\t\t\ttimers = jQuery.timers,\n+\t\t\t\tlength = queue ? queue.length : 0;\n+\n+\t\t\t// Enable finishing flag on private data\n+\t\t\tdata.finish = true;\n+\n+\t\t\t// Empty the queue first\n+\t\t\tjQuery.queue( this, type, [] );\n+\n+\t\t\tif ( hooks && hooks.stop ) {\n+\t\t\t\thooks.stop.call( this, true );\n+\t\t\t}\n+\n+\t\t\t// Look for any active animations, and finish them\n+\t\t\tfor ( index = timers.length; index--; ) {\n+\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n+\t\t\t\t\ttimers[ index ].anim.stop( true );\n+\t\t\t\t\ttimers.splice( index, 1 );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Look for any animations in the old queue and finish them\n+\t\t\tfor ( index = 0; index < length; index++ ) {\n+\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n+\t\t\t\t\tqueue[ index ].finish.call( this );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Turn off finishing flag\n+\t\t\tdelete data.finish;\n+\t\t} );\n+\t}\n+} );\n+\n+jQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( _i, name ) {\n+\tvar cssFn = jQuery.fn[ name ];\n+\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n+\t\treturn speed == null || typeof speed === \"boolean\" ?\n+\t\t\tcssFn.apply( this, arguments ) :\n+\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n+\t};\n+} );\n+\n+// Generate shortcuts for custom animations\n+jQuery.each( {\n+\tslideDown: genFx( \"show\" ),\n+\tslideUp: genFx( \"hide\" ),\n+\tslideToggle: genFx( \"toggle\" ),\n+\tfadeIn: { opacity: \"show\" },\n+\tfadeOut: { opacity: \"hide\" },\n+\tfadeToggle: { opacity: \"toggle\" }\n+}, function( name, props ) {\n+\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n+\t\treturn this.animate( props, speed, easing, callback );\n+\t};\n+} );\n+\n+jQuery.timers = [];\n+jQuery.fx.tick = function() {\n+\tvar timer,\n+\t\ti = 0,\n+\t\ttimers = jQuery.timers;\n+\n+\tfxNow = Date.now();\n+\n+\tfor ( ; i < timers.length; i++ ) {\n+\t\ttimer = timers[ i ];\n+\n+\t\t// Run the timer and safely remove it when done (allowing for external removal)\n+\t\tif ( !timer() && timers[ i ] === timer ) {\n+\t\t\ttimers.splice( i--, 1 );\n+\t\t}\n+\t}\n+\n+\tif ( !timers.length ) {\n+\t\tjQuery.fx.stop();\n+\t}\n+\tfxNow = undefined;\n+};\n+\n+jQuery.fx.timer = function( timer ) {\n+\tjQuery.timers.push( timer );\n+\tjQuery.fx.start();\n+};\n+\n+jQuery.fx.interval = 13;\n+jQuery.fx.start = function() {\n+\tif ( inProgress ) {\n+\t\treturn;\n+\t}\n+\n+\tinProgress = true;\n+\tschedule();\n+};\n+\n+jQuery.fx.stop = function() {\n+\tinProgress = null;\n+};\n+\n+jQuery.fx.speeds = {\n+\tslow: 600,\n+\tfast: 200,\n+\n+\t// Default speed\n+\t_default: 400\n+};\n+\n+\n+// Based off of the plugin by Clint Helfers, with permission.\n+jQuery.fn.delay = function( time, type ) {\n+\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n+\ttype = type || \"fx\";\n+\n+\treturn this.queue( type, function( next, hooks ) {\n+\t\tvar timeout = window.setTimeout( next, time );\n+\t\thooks.stop = function() {\n+\t\t\twindow.clearTimeout( timeout );\n+\t\t};\n+\t} );\n+};\n+\n+\n+( function() {\n+\tvar input = document.createElement( \"input\" ),\n+\t\tselect = document.createElement( \"select\" ),\n+\t\topt = select.appendChild( document.createElement( \"option\" ) );\n+\n+\tinput.type = \"checkbox\";\n+\n+\t// Support: Android <=4.3 only\n+\t// Default value for a checkbox should be \"on\"\n+\tsupport.checkOn = input.value !== \"\";\n+\n+\t// Support: IE <=11 only\n+\t// Must access selectedIndex to make default options select\n+\tsupport.optSelected = opt.selected;\n+\n+\t// Support: IE <=11 only\n+\t// An input loses its value after becoming a radio\n+\tinput = document.createElement( \"input\" );\n+\tinput.value = \"t\";\n+\tinput.type = \"radio\";\n+\tsupport.radioValue = input.value === \"t\";\n+} )();\n+\n+\n+var boolHook,\n+\tattrHandle = jQuery.expr.attrHandle;\n+\n+jQuery.fn.extend( {\n+\tattr: function( name, value ) {\n+\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n+\t},\n+\n+\tremoveAttr: function( name ) {\n+\t\treturn this.each( function() {\n+\t\t\tjQuery.removeAttr( this, name );\n+\t\t} );\n+\t}\n+} );\n+\n+jQuery.extend( {\n+\tattr: function( elem, name, value ) {\n+\t\tvar ret, hooks,\n+\t\t\tnType = elem.nodeType;\n+\n+\t\t// Don't get/set attributes on text, comment and attribute nodes\n+\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Fallback to prop when attributes are not supported\n+\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n+\t\t\treturn jQuery.prop( elem, name, value );\n+\t\t}\n+\n+\t\t// Attribute hooks are determined by the lowercase version\n+\t\t// Grab necessary hook if one is defined\n+\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n+\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n+\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n+\t\t}\n+\n+\t\tif ( value !== undefined ) {\n+\t\t\tif ( value === null ) {\n+\t\t\t\tjQuery.removeAttr( elem, name );\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tif ( hooks && \"set\" in hooks &&\n+\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\n+\t\t\telem.setAttribute( name, value + \"\" );\n+\t\t\treturn value;\n+\t\t}\n+\n+\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n+\t\t\treturn ret;\n+\t\t}\n+\n+\t\tret = jQuery.find.attr( elem, name );\n+\n+\t\t// Non-existent attributes return null, we normalize to undefined\n+\t\treturn ret == null ? undefined : ret;\n+\t},\n+\n+\tattrHooks: {\n+\t\ttype: {\n+\t\t\tset: function( elem, value ) {\n+\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n+\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n+\t\t\t\t\tvar val = elem.value;\n+\t\t\t\t\telem.setAttribute( \"type\", value );\n+\t\t\t\t\tif ( val ) {\n+\t\t\t\t\t\telem.value = val;\n+\t\t\t\t\t}\n+\t\t\t\t\treturn value;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t},\n+\n+\tremoveAttr: function( elem, value ) {\n+\t\tvar name,\n+\t\t\ti = 0,\n+\n+\t\t\t// Attribute names can contain non-HTML whitespace characters\n+\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n+\t\t\tattrNames = value && value.match( rnothtmlwhite );\n+\n+\t\tif ( attrNames && elem.nodeType === 1 ) {\n+\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n+\t\t\t\telem.removeAttribute( name );\n+\t\t\t}\n+\t\t}\n+\t}\n+} );\n+\n+// Hooks for boolean attributes\n+boolHook = {\n+\tset: function( elem, value, name ) {\n+\t\tif ( value === false ) {\n+\n+\t\t\t// Remove boolean attributes when set to false\n+\t\t\tjQuery.removeAttr( elem, name );\n+\t\t} else {\n+\t\t\telem.setAttribute( name, name );\n+\t\t}\n+\t\treturn name;\n+\t}\n+};\n+\n+jQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( _i, name ) {\n+\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n+\n+\tattrHandle[ name ] = function( elem, name, isXML ) {\n+\t\tvar ret, handle,\n+\t\t\tlowercaseName = name.toLowerCase();\n+\n+\t\tif ( !isXML ) {\n+\n+\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n+\t\t\thandle = attrHandle[ lowercaseName ];\n+\t\t\tattrHandle[ lowercaseName ] = ret;\n+\t\t\tret = getter( elem, name, isXML ) != null ?\n+\t\t\t\tlowercaseName :\n+\t\t\t\tnull;\n+\t\t\tattrHandle[ lowercaseName ] = handle;\n+\t\t}\n+\t\treturn ret;\n+\t};\n+} );\n+\n+\n+\n+\n+var rfocusable = /^(?:input|select|textarea|button)$/i,\n+\trclickable = /^(?:a|area)$/i;\n+\n+jQuery.fn.extend( {\n+\tprop: function( name, value ) {\n+\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n+\t},\n+\n+\tremoveProp: function( name ) {\n+\t\treturn this.each( function() {\n+\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n+\t\t} );\n+\t}\n+} );\n+\n+jQuery.extend( {\n+\tprop: function( elem, name, value ) {\n+\t\tvar ret, hooks,\n+\t\t\tnType = elem.nodeType;\n+\n+\t\t// Don't get/set properties on text, comment and attribute nodes\n+\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n+\n+\t\t\t// Fix name and attach hooks\n+\t\t\tname = jQuery.propFix[ name ] || name;\n+\t\t\thooks = jQuery.propHooks[ name ];\n+\t\t}\n+\n+\t\tif ( value !== undefined ) {\n+\t\t\tif ( hooks && \"set\" in hooks &&\n+\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\n+\t\t\treturn ( elem[ name ] = value );\n+\t\t}\n+\n+\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n+\t\t\treturn ret;\n+\t\t}\n+\n+\t\treturn elem[ name ];\n+\t},\n+\n+\tpropHooks: {\n+\t\ttabIndex: {\n+\t\t\tget: function( elem ) {\n+\n+\t\t\t\t// Support: IE <=9 - 11 only\n+\t\t\t\t// elem.tabIndex doesn't always return the\n+\t\t\t\t// correct value when it hasn't been explicitly set\n+\t\t\t\t// Use proper attribute retrieval (trac-12072)\n+\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n+\n+\t\t\t\tif ( tabindex ) {\n+\t\t\t\t\treturn parseInt( tabindex, 10 );\n+\t\t\t\t}\n+\n+\t\t\t\tif (\n+\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n+\t\t\t\t\trclickable.test( elem.nodeName ) &&\n+\t\t\t\t\telem.href\n+\t\t\t\t) {\n+\t\t\t\t\treturn 0;\n+\t\t\t\t}\n+\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t}\n+\t},\n+\n+\tpropFix: {\n+\t\t\"for\": \"htmlFor\",\n+\t\t\"class\": \"className\"\n+\t}\n+} );\n+\n+// Support: IE <=11 only\n+// Accessing the selectedIndex property\n+// forces the browser to respect setting selected\n+// on the option\n+// The getter ensures a default option is selected\n+// when in an optgroup\n+// eslint rule \"no-unused-expressions\" is disabled for this code\n+// since it considers such accessions noop\n+if ( !support.optSelected ) {\n+\tjQuery.propHooks.selected = {\n+\t\tget: function( elem ) {\n+\n+\t\t\t/* eslint no-unused-expressions: \"off\" */\n+\n+\t\t\tvar parent = elem.parentNode;\n+\t\t\tif ( parent && parent.parentNode ) {\n+\t\t\t\tparent.parentNode.selectedIndex;\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t},\n+\t\tset: function( elem ) {\n+\n+\t\t\t/* eslint no-unused-expressions: \"off\" */\n+\n+\t\t\tvar parent = elem.parentNode;\n+\t\t\tif ( parent ) {\n+\t\t\t\tparent.selectedIndex;\n+\n+\t\t\t\tif ( parent.parentNode ) {\n+\t\t\t\t\tparent.parentNode.selectedIndex;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t};\n+}\n+\n+jQuery.each( [\n+\t\"tabIndex\",\n+\t\"readOnly\",\n+\t\"maxLength\",\n+\t\"cellSpacing\",\n+\t\"cellPadding\",\n+\t\"rowSpan\",\n+\t\"colSpan\",\n+\t\"useMap\",\n+\t\"frameBorder\",\n+\t\"contentEditable\"\n+], function() {\n+\tjQuery.propFix[ this.toLowerCase() ] = this;\n+} );\n+\n+\n+\n+\n+\t// Strip and collapse whitespace according to HTML spec\n+\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n+\tfunction stripAndCollapse( value ) {\n+\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n+\t\treturn tokens.join( \" \" );\n+\t}\n+\n+\n+function getClass( elem ) {\n+\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n+}\n+\n+function classesToArray( value ) {\n+\tif ( Array.isArray( value ) ) {\n+\t\treturn value;\n+\t}\n+\tif ( typeof value === \"string\" ) {\n+\t\treturn value.match( rnothtmlwhite ) || [];\n+\t}\n+\treturn [];\n+}\n+\n+jQuery.fn.extend( {\n+\taddClass: function( value ) {\n+\t\tvar classNames, cur, curValue, className, i, finalValue;\n+\n+\t\tif ( isFunction( value ) ) {\n+\t\t\treturn this.each( function( j ) {\n+\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n+\t\t\t} );\n+\t\t}\n+\n+\t\tclassNames = classesToArray( value );\n+\n+\t\tif ( classNames.length ) {\n+\t\t\treturn this.each( function() {\n+\t\t\t\tcurValue = getClass( this );\n+\t\t\t\tcur = this.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n+\n+\t\t\t\tif ( cur ) {\n+\t\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n+\t\t\t\t\t\tclassName = classNames[ i ];\n+\t\t\t\t\t\tif ( cur.indexOf( \" \" + className + \" \" ) < 0 ) {\n+\t\t\t\t\t\t\tcur += className + \" \";\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n+\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n+\t\t\t\t\tif ( curValue !== finalValue ) {\n+\t\t\t\t\t\tthis.setAttribute( \"class\", finalValue );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} );\n+\t\t}\n+\n+\t\treturn this;\n+\t},\n+\n+\tremoveClass: function( value ) {\n+\t\tvar classNames, cur, curValue, className, i, finalValue;\n+\n+\t\tif ( isFunction( value ) ) {\n+\t\t\treturn this.each( function( j ) {\n+\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n+\t\t\t} );\n+\t\t}\n+\n+\t\tif ( !arguments.length ) {\n+\t\t\treturn this.attr( \"class\", \"\" );\n+\t\t}\n+\n+\t\tclassNames = classesToArray( value );\n+\n+\t\tif ( classNames.length ) {\n+\t\t\treturn this.each( function() {\n+\t\t\t\tcurValue = getClass( this );\n+\n+\t\t\t\t// This expression is here for better compressibility (see addClass)\n+\t\t\t\tcur = this.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n+\n+\t\t\t\tif ( cur ) {\n+\t\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n+\t\t\t\t\t\tclassName = classNames[ i ];\n+\n+\t\t\t\t\t\t// Remove *all* instances\n+\t\t\t\t\t\twhile ( cur.indexOf( \" \" + className + \" \" ) > -1 ) {\n+\t\t\t\t\t\t\tcur = cur.replace( \" \" + className + \" \", \" \" );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n+\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n+\t\t\t\t\tif ( curValue !== finalValue ) {\n+\t\t\t\t\t\tthis.setAttribute( \"class\", finalValue );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} );\n+\t\t}\n+\n+\t\treturn this;\n+\t},\n+\n+\ttoggleClass: function( value, stateVal ) {\n+\t\tvar classNames, className, i, self,\n+\t\t\ttype = typeof value,\n+\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n+\n+\t\tif ( isFunction( value ) ) {\n+\t\t\treturn this.each( function( i ) {\n+\t\t\t\tjQuery( this ).toggleClass(\n+\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n+\t\t\t\t\tstateVal\n+\t\t\t\t);\n+\t\t\t} );\n+\t\t}\n+\n+\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n+\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n+\t\t}\n+\n+\t\tclassNames = classesToArray( value );\n+\n+\t\treturn this.each( function() {\n+\t\t\tif ( isValidValue ) {\n+\n+\t\t\t\t// Toggle individual class names\n+\t\t\t\tself = jQuery( this );\n+\n+\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n+\t\t\t\t\tclassName = classNames[ i ];\n+\n+\t\t\t\t\t// Check each className given, space separated list\n+\t\t\t\t\tif ( self.hasClass( className ) ) {\n+\t\t\t\t\t\tself.removeClass( className );\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tself.addClass( className );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t// Toggle whole class name\n+\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n+\t\t\t\tclassName = getClass( this );\n+\t\t\t\tif ( className ) {\n+\n+\t\t\t\t\t// Store className if set\n+\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n+\t\t\t\t}\n+\n+\t\t\t\t// If the element has a class name or if we're passed `false`,\n+\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n+\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n+\t\t\t\t// falling back to the empty string if nothing was stored.\n+\t\t\t\tif ( this.setAttribute ) {\n+\t\t\t\t\tthis.setAttribute( \"class\",\n+\t\t\t\t\t\tclassName || value === false ?\n+\t\t\t\t\t\t\t\"\" :\n+\t\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\thasClass: function( selector ) {\n+\t\tvar className, elem,\n+\t\t\ti = 0;\n+\n+\t\tclassName = \" \" + selector + \" \";\n+\t\twhile ( ( elem = this[ i++ ] ) ) {\n+\t\t\tif ( elem.nodeType === 1 &&\n+\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+} );\n+\n+\n+\n+\n+var rreturn = /\\r/g;\n+\n+jQuery.fn.extend( {\n+\tval: function( value ) {\n+\t\tvar hooks, ret, valueIsFunction,\n+\t\t\telem = this[ 0 ];\n+\n+\t\tif ( !arguments.length ) {\n+\t\t\tif ( elem ) {\n+\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n+\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n+\n+\t\t\t\tif ( hooks &&\n+\t\t\t\t\t\"get\" in hooks &&\n+\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n+\t\t\t\t) {\n+\t\t\t\t\treturn ret;\n+\t\t\t\t}\n+\n+\t\t\t\tret = elem.value;\n+\n+\t\t\t\t// Handle most common string cases\n+\t\t\t\tif ( typeof ret === \"string\" ) {\n+\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n+\t\t\t\t}\n+\n+\t\t\t\t// Handle cases where value is null/undef or number\n+\t\t\t\treturn ret == null ? \"\" : ret;\n+\t\t\t}\n+\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tvalueIsFunction = isFunction( value );\n+\n+\t\treturn this.each( function( i ) {\n+\t\t\tvar val;\n+\n+\t\t\tif ( this.nodeType !== 1 ) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tif ( valueIsFunction ) {\n+\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n+\t\t\t} else {\n+\t\t\t\tval = value;\n+\t\t\t}\n+\n+\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n+\t\t\tif ( val == null ) {\n+\t\t\t\tval = \"\";\n+\n+\t\t\t} else if ( typeof val === \"number\" ) {\n+\t\t\t\tval += \"\";\n+\n+\t\t\t} else if ( Array.isArray( val ) ) {\n+\t\t\t\tval = jQuery.map( val, function( value ) {\n+\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n+\t\t\t\t} );\n+\t\t\t}\n+\n+\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n+\n+\t\t\t// If set returns undefined, fall back to normal setting\n+\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n+\t\t\t\tthis.value = val;\n+\t\t\t}\n+\t\t} );\n+\t}\n+} );\n+\n+jQuery.extend( {\n+\tvalHooks: {\n+\t\toption: {\n+\t\t\tget: function( elem ) {\n+\n+\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n+\t\t\t\treturn val != null ?\n+\t\t\t\t\tval :\n+\n+\t\t\t\t\t// Support: IE <=10 - 11 only\n+\t\t\t\t\t// option.text throws exceptions (trac-14686, trac-14858)\n+\t\t\t\t\t// Strip and collapse whitespace\n+\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n+\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n+\t\t\t}\n+\t\t},\n+\t\tselect: {\n+\t\t\tget: function( elem ) {\n+\t\t\t\tvar value, option, i,\n+\t\t\t\t\toptions = elem.options,\n+\t\t\t\t\tindex = elem.selectedIndex,\n+\t\t\t\t\tone = elem.type === \"select-one\",\n+\t\t\t\t\tvalues = one ? null : [],\n+\t\t\t\t\tmax = one ? index + 1 : options.length;\n+\n+\t\t\t\tif ( index < 0 ) {\n+\t\t\t\t\ti = max;\n+\n+\t\t\t\t} else {\n+\t\t\t\t\ti = one ? index : 0;\n+\t\t\t\t}\n+\n+\t\t\t\t// Loop through all the selected options\n+\t\t\t\tfor ( ; i < max; i++ ) {\n+\t\t\t\t\toption = options[ i ];\n+\n+\t\t\t\t\t// Support: IE <=9 only\n+\t\t\t\t\t// IE8-9 doesn't update selected after form reset (trac-2551)\n+\t\t\t\t\tif ( ( option.selected || i === index ) &&\n+\n+\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n+\t\t\t\t\t\t\t!option.disabled &&\n+\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n+\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n+\n+\t\t\t\t\t\t// Get the specific value for the option\n+\t\t\t\t\t\tvalue = jQuery( option ).val();\n+\n+\t\t\t\t\t\t// We don't need an array for one selects\n+\t\t\t\t\t\tif ( one ) {\n+\t\t\t\t\t\t\treturn value;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Multi-Selects return an array\n+\t\t\t\t\t\tvalues.push( value );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn values;\n+\t\t\t},\n+\n+\t\t\tset: function( elem, value ) {\n+\t\t\t\tvar optionSet, option,\n+\t\t\t\t\toptions = elem.options,\n+\t\t\t\t\tvalues = jQuery.makeArray( value ),\n+\t\t\t\t\ti = options.length;\n+\n+\t\t\t\twhile ( i-- ) {\n+\t\t\t\t\toption = options[ i ];\n+\n+\t\t\t\t\t/* eslint-disable no-cond-assign */\n+\n+\t\t\t\t\tif ( option.selected =\n+\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n+\t\t\t\t\t) {\n+\t\t\t\t\t\toptionSet = true;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* eslint-enable no-cond-assign */\n+\t\t\t\t}\n+\n+\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n+\t\t\t\tif ( !optionSet ) {\n+\t\t\t\t\telem.selectedIndex = -1;\n+\t\t\t\t}\n+\t\t\t\treturn values;\n+\t\t\t}\n+\t\t}\n+\t}\n+} );\n+\n+// Radios and checkboxes getter/setter\n+jQuery.each( [ \"radio\", \"checkbox\" ], function() {\n+\tjQuery.valHooks[ this ] = {\n+\t\tset: function( elem, value ) {\n+\t\t\tif ( Array.isArray( value ) ) {\n+\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n+\t\t\t}\n+\t\t}\n+\t};\n+\tif ( !support.checkOn ) {\n+\t\tjQuery.valHooks[ this ].get = function( elem ) {\n+\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n+\t\t};\n+\t}\n+} );\n+\n+\n+\n+\n+// Return jQuery for attributes-only inclusion\n+\n+\n+support.focusin = \"onfocusin\" in window;\n+\n+\n+var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n+\tstopPropagationCallback = function( e ) {\n+\t\te.stopPropagation();\n+\t};\n+\n+jQuery.extend( jQuery.event, {\n+\n+\ttrigger: function( event, data, elem, onlyHandlers ) {\n+\n+\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n+\t\t\teventPath = [ elem || document ],\n+\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n+\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n+\n+\t\tcur = lastElement = tmp = elem = elem || document;\n+\n+\t\t// Don't do events on text and comment nodes\n+\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n+\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif ( type.indexOf( \".\" ) > -1 ) {\n+\n+\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n+\t\t\tnamespaces = type.split( \".\" );\n+\t\t\ttype = namespaces.shift();\n+\t\t\tnamespaces.sort();\n+\t\t}\n+\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n+\n+\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n+\t\tevent = event[ jQuery.expando ] ?\n+\t\t\tevent :\n+\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n+\n+\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n+\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n+\t\tevent.namespace = namespaces.join( \".\" );\n+\t\tevent.rnamespace = event.namespace ?\n+\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n+\t\t\tnull;\n+\n+\t\t// Clean up the event in case it is being reused\n+\t\tevent.result = undefined;\n+\t\tif ( !event.target ) {\n+\t\t\tevent.target = elem;\n+\t\t}\n+\n+\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n+\t\tdata = data == null ?\n+\t\t\t[ event ] :\n+\t\t\tjQuery.makeArray( data, [ event ] );\n+\n+\t\t// Allow special events to draw outside the lines\n+\t\tspecial = jQuery.event.special[ type ] || {};\n+\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Determine event propagation path in advance, per W3C events spec (trac-9951)\n+\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)\n+\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n+\n+\t\t\tbubbleType = special.delegateType || type;\n+\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n+\t\t\t\tcur = cur.parentNode;\n+\t\t\t}\n+\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n+\t\t\t\teventPath.push( cur );\n+\t\t\t\ttmp = cur;\n+\t\t\t}\n+\n+\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n+\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n+\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Fire handlers on the event path\n+\t\ti = 0;\n+\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n+\t\t\tlastElement = cur;\n+\t\t\tevent.type = i > 1 ?\n+\t\t\t\tbubbleType :\n+\t\t\t\tspecial.bindType || type;\n+\n+\t\t\t// jQuery handler\n+\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || Object.create( null ) )[ event.type ] &&\n+\t\t\t\tdataPriv.get( cur, \"handle\" );\n+\t\t\tif ( handle ) {\n+\t\t\t\thandle.apply( cur, data );\n+\t\t\t}\n+\n+\t\t\t// Native handler\n+\t\t\thandle = ontype && cur[ ontype ];\n+\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n+\t\t\t\tevent.result = handle.apply( cur, data );\n+\t\t\t\tif ( event.result === false ) {\n+\t\t\t\t\tevent.preventDefault();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tevent.type = type;\n+\n+\t\t// If nobody prevented the default action, do it now\n+\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n+\n+\t\t\tif ( ( !special._default ||\n+\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n+\t\t\t\tacceptData( elem ) ) {\n+\n+\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n+\t\t\t\t// Don't do default actions on window, that's where global variables be (trac-6170)\n+\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n+\n+\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n+\t\t\t\t\ttmp = elem[ ontype ];\n+\n+\t\t\t\t\tif ( tmp ) {\n+\t\t\t\t\t\telem[ ontype ] = null;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n+\t\t\t\t\tjQuery.event.triggered = type;\n+\n+\t\t\t\t\tif ( event.isPropagationStopped() ) {\n+\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n+\t\t\t\t\t}\n+\n+\t\t\t\t\telem[ type ]();\n+\n+\t\t\t\t\tif ( event.isPropagationStopped() ) {\n+\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tjQuery.event.triggered = undefined;\n+\n+\t\t\t\t\tif ( tmp ) {\n+\t\t\t\t\t\telem[ ontype ] = tmp;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn event.result;\n+\t},\n+\n+\t// Piggyback on a donor event to simulate a different one\n+\t// Used only for `focus(in | out)` events\n+\tsimulate: function( type, elem, event ) {\n+\t\tvar e = jQuery.extend(\n+\t\t\tnew jQuery.Event(),\n+\t\t\tevent,\n+\t\t\t{\n+\t\t\t\ttype: type,\n+\t\t\t\tisSimulated: true\n+\t\t\t}\n+\t\t);\n+\n+\t\tjQuery.event.trigger( e, null, elem );\n+\t}\n+\n+} );\n+\n+jQuery.fn.extend( {\n+\n+\ttrigger: function( type, data ) {\n+\t\treturn this.each( function() {\n+\t\t\tjQuery.event.trigger( type, data, this );\n+\t\t} );\n+\t},\n+\ttriggerHandler: function( type, data ) {\n+\t\tvar elem = this[ 0 ];\n+\t\tif ( elem ) {\n+\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n+\t\t}\n+\t}\n+} );\n+\n+\n+// Support: Firefox <=44\n+// Firefox doesn't have focus(in | out) events\n+// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n+//\n+// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n+// focus(in | out) events fire after focus & blur events,\n+// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n+// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n+if ( !support.focusin ) {\n+\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n+\n+\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n+\t\tvar handler = function( event ) {\n+\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n+\t\t};\n+\n+\t\tjQuery.event.special[ fix ] = {\n+\t\t\tsetup: function() {\n+\n+\t\t\t\t// Handle: regular nodes (via `this.ownerDocument`), window\n+\t\t\t\t// (via `this.document`) & document (via `this`).\n+\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n+\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n+\n+\t\t\t\tif ( !attaches ) {\n+\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n+\t\t\t\t}\n+\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n+\t\t\t},\n+\t\t\tteardown: function() {\n+\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n+\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n+\n+\t\t\t\tif ( !attaches ) {\n+\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n+\t\t\t\t\tdataPriv.remove( doc, fix );\n+\n+\t\t\t\t} else {\n+\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t} );\n+}\n+var location = window.location;\n+\n+var nonce = { guid: Date.now() };\n+\n+var rquery = ( /\\?/ );\n+\n+\n+\n+// Cross-browser xml parsing\n+jQuery.parseXML = function( data ) {\n+\tvar xml, parserErrorElem;\n+\tif ( !data || typeof data !== \"string\" ) {\n+\t\treturn null;\n+\t}\n+\n+\t// Support: IE 9 - 11 only\n+\t// IE throws on parseFromString with invalid input.\n+\ttry {\n+\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n+\t} catch ( e ) {}\n+\n+\tparserErrorElem = xml && xml.getElementsByTagName( \"parsererror\" )[ 0 ];\n+\tif ( !xml || parserErrorElem ) {\n+\t\tjQuery.error( \"Invalid XML: \" + (\n+\t\t\tparserErrorElem ?\n+\t\t\t\tjQuery.map( parserErrorElem.childNodes, function( el ) {\n+\t\t\t\t\treturn el.textContent;\n+\t\t\t\t} ).join( \"\\n\" ) :\n+\t\t\t\tdata\n+\t\t) );\n+\t}\n+\treturn xml;\n+};\n+\n+\n+var\n+\trbracket = /\\[\\]$/,\n+\trCRLF = /\\r?\\n/g,\n+\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n+\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n+\n+function buildParams( prefix, obj, traditional, add ) {\n+\tvar name;\n+\n+\tif ( Array.isArray( obj ) ) {\n+\n+\t\t// Serialize array item.\n+\t\tjQuery.each( obj, function( i, v ) {\n+\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n+\n+\t\t\t\t// Treat each array item as a scalar.\n+\t\t\t\tadd( prefix, v );\n+\n+\t\t\t} else {\n+\n+\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n+\t\t\t\tbuildParams(\n+\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n+\t\t\t\t\tv,\n+\t\t\t\t\ttraditional,\n+\t\t\t\t\tadd\n+\t\t\t\t);\n+\t\t\t}\n+\t\t} );\n+\n+\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n+\n+\t\t// Serialize object item.\n+\t\tfor ( name in obj ) {\n+\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n+\t\t}\n+\n+\t} else {\n+\n+\t\t// Serialize scalar item.\n+\t\tadd( prefix, obj );\n+\t}\n+}\n+\n+// Serialize an array of form elements or a set of\n+// key/values into a query string\n+jQuery.param = function( a, traditional ) {\n+\tvar prefix,\n+\t\ts = [],\n+\t\tadd = function( key, valueOrFunction ) {\n+\n+\t\t\t// If value is a function, invoke it and use its return value\n+\t\t\tvar value = isFunction( valueOrFunction ) ?\n+\t\t\t\tvalueOrFunction() :\n+\t\t\t\tvalueOrFunction;\n+\n+\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n+\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n+\t\t};\n+\n+\tif ( a == null ) {\n+\t\treturn \"\";\n+\t}\n+\n+\t// If an array was passed in, assume that it is an array of form elements.\n+\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n+\n+\t\t// Serialize the form elements\n+\t\tjQuery.each( a, function() {\n+\t\t\tadd( this.name, this.value );\n+\t\t} );\n+\n+\t} else {\n+\n+\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n+\t\t// did it), otherwise encode params recursively.\n+\t\tfor ( prefix in a ) {\n+\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n+\t\t}\n+\t}\n+\n+\t// Return the resulting serialization\n+\treturn s.join( \"&\" );\n+};\n+\n+jQuery.fn.extend( {\n+\tserialize: function() {\n+\t\treturn jQuery.param( this.serializeArray() );\n+\t},\n+\tserializeArray: function() {\n+\t\treturn this.map( function() {\n+\n+\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n+\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n+\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n+\t\t} ).filter( function() {\n+\t\t\tvar type = this.type;\n+\n+\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n+\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n+\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n+\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n+\t\t} ).map( function( _i, elem ) {\n+\t\t\tvar val = jQuery( this ).val();\n+\n+\t\t\tif ( val == null ) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tif ( Array.isArray( val ) ) {\n+\t\t\t\treturn jQuery.map( val, function( val ) {\n+\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n+\t\t\t\t} );\n+\t\t\t}\n+\n+\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n+\t\t} ).get();\n+\t}\n+} );\n+\n+\n+var\n+\tr20 = /%20/g,\n+\trhash = /#.*$/,\n+\trantiCache = /([?&])_=[^&]*/,\n+\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n+\n+\t// trac-7653, trac-8125, trac-8152: local protocol detection\n+\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n+\trnoContent = /^(?:GET|HEAD)$/,\n+\trprotocol = /^\\/\\//,\n+\n+\t/* Prefilters\n+\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n+\t * 2) These are called:\n+\t *    - BEFORE asking for a transport\n+\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n+\t * 3) key is the dataType\n+\t * 4) the catchall symbol \"*\" can be used\n+\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n+\t */\n+\tprefilters = {},\n+\n+\t/* Transports bindings\n+\t * 1) key is the dataType\n+\t * 2) the catchall symbol \"*\" can be used\n+\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n+\t */\n+\ttransports = {},\n+\n+\t// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression\n+\tallTypes = \"*/\".concat( \"*\" ),\n+\n+\t// Anchor tag for parsing the document origin\n+\toriginAnchor = document.createElement( \"a\" );\n+\n+originAnchor.href = location.href;\n+\n+// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n+function addToPrefiltersOrTransports( structure ) {\n+\n+\t// dataTypeExpression is optional and defaults to \"*\"\n+\treturn function( dataTypeExpression, func ) {\n+\n+\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n+\t\t\tfunc = dataTypeExpression;\n+\t\t\tdataTypeExpression = \"*\";\n+\t\t}\n+\n+\t\tvar dataType,\n+\t\t\ti = 0,\n+\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n+\n+\t\tif ( isFunction( func ) ) {\n+\n+\t\t\t// For each dataType in the dataTypeExpression\n+\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n+\n+\t\t\t\t// Prepend if requested\n+\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n+\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n+\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n+\n+\t\t\t\t// Otherwise append\n+\t\t\t\t} else {\n+\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t};\n+}\n+\n+// Base inspection function for prefilters and transports\n+function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n+\n+\tvar inspected = {},\n+\t\tseekingTransport = ( structure === transports );\n+\n+\tfunction inspect( dataType ) {\n+\t\tvar selected;\n+\t\tinspected[ dataType ] = true;\n+\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n+\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n+\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n+\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n+\n+\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n+\t\t\t\tinspect( dataTypeOrTransport );\n+\t\t\t\treturn false;\n+\t\t\t} else if ( seekingTransport ) {\n+\t\t\t\treturn !( selected = dataTypeOrTransport );\n+\t\t\t}\n+\t\t} );\n+\t\treturn selected;\n+\t}\n+\n+\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n+}\n+\n+// A special extend for ajax options\n+// that takes \"flat\" options (not to be deep extended)\n+// Fixes trac-9887\n+function ajaxExtend( target, src ) {\n+\tvar key, deep,\n+\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n+\n+\tfor ( key in src ) {\n+\t\tif ( src[ key ] !== undefined ) {\n+\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n+\t\t}\n+\t}\n+\tif ( deep ) {\n+\t\tjQuery.extend( true, target, deep );\n+\t}\n+\n+\treturn target;\n+}\n+\n+/* Handles responses to an ajax request:\n+ * - finds the right dataType (mediates between content-type and expected dataType)\n+ * - returns the corresponding response\n+ */\n+function ajaxHandleResponses( s, jqXHR, responses ) {\n+\n+\tvar ct, type, finalDataType, firstDataType,\n+\t\tcontents = s.contents,\n+\t\tdataTypes = s.dataTypes;\n+\n+\t// Remove auto dataType and get content-type in the process\n+\twhile ( dataTypes[ 0 ] === \"*\" ) {\n+\t\tdataTypes.shift();\n+\t\tif ( ct === undefined ) {\n+\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n+\t\t}\n+\t}\n+\n+\t// Check if we're dealing with a known content-type\n+\tif ( ct ) {\n+\t\tfor ( type in contents ) {\n+\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n+\t\t\t\tdataTypes.unshift( type );\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Check to see if we have a response for the expected dataType\n+\tif ( dataTypes[ 0 ] in responses ) {\n+\t\tfinalDataType = dataTypes[ 0 ];\n+\t} else {\n+\n+\t\t// Try convertible dataTypes\n+\t\tfor ( type in responses ) {\n+\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n+\t\t\t\tfinalDataType = type;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif ( !firstDataType ) {\n+\t\t\t\tfirstDataType = type;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Or just use first one\n+\t\tfinalDataType = finalDataType || firstDataType;\n+\t}\n+\n+\t// If we found a dataType\n+\t// We add the dataType to the list if needed\n+\t// and return the corresponding response\n+\tif ( finalDataType ) {\n+\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n+\t\t\tdataTypes.unshift( finalDataType );\n+\t\t}\n+\t\treturn responses[ finalDataType ];\n+\t}\n+}\n+\n+/* Chain conversions given the request and the original response\n+ * Also sets the responseXXX fields on the jqXHR instance\n+ */\n+function ajaxConvert( s, response, jqXHR, isSuccess ) {\n+\tvar conv2, current, conv, tmp, prev,\n+\t\tconverters = {},\n+\n+\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n+\t\tdataTypes = s.dataTypes.slice();\n+\n+\t// Create converters map with lowercased keys\n+\tif ( dataTypes[ 1 ] ) {\n+\t\tfor ( conv in s.converters ) {\n+\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n+\t\t}\n+\t}\n+\n+\tcurrent = dataTypes.shift();\n+\n+\t// Convert to each sequential dataType\n+\twhile ( current ) {\n+\n+\t\tif ( s.responseFields[ current ] ) {\n+\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n+\t\t}\n+\n+\t\t// Apply the dataFilter if provided\n+\t\tif ( !prev && isSuccess && s.dataFilter ) {\n+\t\t\tresponse = s.dataFilter( response, s.dataType );\n+\t\t}\n+\n+\t\tprev = current;\n+\t\tcurrent = dataTypes.shift();\n+\n+\t\tif ( current ) {\n+\n+\t\t\t// There's only work to do if current dataType is non-auto\n+\t\t\tif ( current === \"*\" ) {\n+\n+\t\t\t\tcurrent = prev;\n+\n+\t\t\t// Convert response if prev dataType is non-auto and differs from current\n+\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n+\n+\t\t\t\t// Seek a direct converter\n+\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n+\n+\t\t\t\t// If none found, seek a pair\n+\t\t\t\tif ( !conv ) {\n+\t\t\t\t\tfor ( conv2 in converters ) {\n+\n+\t\t\t\t\t\t// If conv2 outputs current\n+\t\t\t\t\t\ttmp = conv2.split( \" \" );\n+\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n+\n+\t\t\t\t\t\t\t// If prev can be converted to accepted input\n+\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n+\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n+\t\t\t\t\t\t\tif ( conv ) {\n+\n+\t\t\t\t\t\t\t\t// Condense equivalence converters\n+\t\t\t\t\t\t\t\tif ( conv === true ) {\n+\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n+\n+\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n+\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n+\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n+\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// Apply converter (if not an equivalence)\n+\t\t\t\tif ( conv !== true ) {\n+\n+\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n+\t\t\t\t\tif ( conv && s.throws ) {\n+\t\t\t\t\t\tresponse = conv( response );\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tresponse = conv( response );\n+\t\t\t\t\t\t} catch ( e ) {\n+\t\t\t\t\t\t\treturn {\n+\t\t\t\t\t\t\t\tstate: \"parsererror\",\n+\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n+\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn { state: \"success\", data: response };\n+}\n+\n+jQuery.extend( {\n+\n+\t// Counter for holding the number of active queries\n+\tactive: 0,\n+\n+\t// Last-Modified header cache for next request\n+\tlastModified: {},\n+\tetag: {},\n+\n+\tajaxSettings: {\n+\t\turl: location.href,\n+\t\ttype: \"GET\",\n+\t\tisLocal: rlocalProtocol.test( location.protocol ),\n+\t\tglobal: true,\n+\t\tprocessData: true,\n+\t\tasync: true,\n+\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n+\n+\t\t/*\n+\t\ttimeout: 0,\n+\t\tdata: null,\n+\t\tdataType: null,\n+\t\tusername: null,\n+\t\tpassword: null,\n+\t\tcache: null,\n+\t\tthrows: false,\n+\t\ttraditional: false,\n+\t\theaders: {},\n+\t\t*/\n+\n+\t\taccepts: {\n+\t\t\t\"*\": allTypes,\n+\t\t\ttext: \"text/plain\",\n+\t\t\thtml: \"text/html\",\n+\t\t\txml: \"application/xml, text/xml\",\n+\t\t\tjson: \"application/json, text/javascript\"\n+\t\t},\n+\n+\t\tcontents: {\n+\t\t\txml: /\\bxml\\b/,\n+\t\t\thtml: /\\bhtml/,\n+\t\t\tjson: /\\bjson\\b/\n+\t\t},\n+\n+\t\tresponseFields: {\n+\t\t\txml: \"responseXML\",\n+\t\t\ttext: \"responseText\",\n+\t\t\tjson: \"responseJSON\"\n+\t\t},\n+\n+\t\t// Data converters\n+\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n+\t\tconverters: {\n+\n+\t\t\t// Convert anything to text\n+\t\t\t\"* text\": String,\n+\n+\t\t\t// Text to html (true = no transformation)\n+\t\t\t\"text html\": true,\n+\n+\t\t\t// Evaluate text as a json expression\n+\t\t\t\"text json\": JSON.parse,\n+\n+\t\t\t// Parse text as xml\n+\t\t\t\"text xml\": jQuery.parseXML\n+\t\t},\n+\n+\t\t// For options that shouldn't be deep extended:\n+\t\t// you can add your own custom options here if\n+\t\t// and when you create one that shouldn't be\n+\t\t// deep extended (see ajaxExtend)\n+\t\tflatOptions: {\n+\t\t\turl: true,\n+\t\t\tcontext: true\n+\t\t}\n+\t},\n+\n+\t// Creates a full fledged settings object into target\n+\t// with both ajaxSettings and settings fields.\n+\t// If target is omitted, writes into ajaxSettings.\n+\tajaxSetup: function( target, settings ) {\n+\t\treturn settings ?\n+\n+\t\t\t// Building a settings object\n+\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n+\n+\t\t\t// Extending ajaxSettings\n+\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n+\t},\n+\n+\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n+\tajaxTransport: addToPrefiltersOrTransports( transports ),\n+\n+\t// Main method\n+\tajax: function( url, options ) {\n+\n+\t\t// If url is an object, simulate pre-1.5 signature\n+\t\tif ( typeof url === \"object\" ) {\n+\t\t\toptions = url;\n+\t\t\turl = undefined;\n+\t\t}\n+\n+\t\t// Force options to be an object\n+\t\toptions = options || {};\n+\n+\t\tvar transport,\n+\n+\t\t\t// URL without anti-cache param\n+\t\t\tcacheURL,\n+\n+\t\t\t// Response headers\n+\t\t\tresponseHeadersString,\n+\t\t\tresponseHeaders,\n+\n+\t\t\t// timeout handle\n+\t\t\ttimeoutTimer,\n+\n+\t\t\t// Url cleanup var\n+\t\t\turlAnchor,\n+\n+\t\t\t// Request state (becomes false upon send and true upon completion)\n+\t\t\tcompleted,\n+\n+\t\t\t// To know if global events are to be dispatched\n+\t\t\tfireGlobals,\n+\n+\t\t\t// Loop variable\n+\t\t\ti,\n+\n+\t\t\t// uncached part of the url\n+\t\t\tuncached,\n+\n+\t\t\t// Create the final options object\n+\t\t\ts = jQuery.ajaxSetup( {}, options ),\n+\n+\t\t\t// Callbacks context\n+\t\t\tcallbackContext = s.context || s,\n+\n+\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n+\t\t\tglobalEventContext = s.context &&\n+\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n+\t\t\t\tjQuery( callbackContext ) :\n+\t\t\t\tjQuery.event,\n+\n+\t\t\t// Deferreds\n+\t\t\tdeferred = jQuery.Deferred(),\n+\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n+\n+\t\t\t// Status-dependent callbacks\n+\t\t\tstatusCode = s.statusCode || {},\n+\n+\t\t\t// Headers (they are sent all at once)\n+\t\t\trequestHeaders = {},\n+\t\t\trequestHeadersNames = {},\n+\n+\t\t\t// Default abort message\n+\t\t\tstrAbort = \"canceled\",\n+\n+\t\t\t// Fake xhr\n+\t\t\tjqXHR = {\n+\t\t\t\treadyState: 0,\n+\n+\t\t\t\t// Builds headers hashtable if needed\n+\t\t\t\tgetResponseHeader: function( key ) {\n+\t\t\t\t\tvar match;\n+\t\t\t\t\tif ( completed ) {\n+\t\t\t\t\t\tif ( !responseHeaders ) {\n+\t\t\t\t\t\t\tresponseHeaders = {};\n+\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n+\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + \" \" ] =\n+\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + \" \" ] || [] )\n+\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + \" \" ];\n+\t\t\t\t\t}\n+\t\t\t\t\treturn match == null ? null : match.join( \", \" );\n+\t\t\t\t},\n+\n+\t\t\t\t// Raw string\n+\t\t\t\tgetAllResponseHeaders: function() {\n+\t\t\t\t\treturn completed ? responseHeadersString : null;\n+\t\t\t\t},\n+\n+\t\t\t\t// Caches the header\n+\t\t\t\tsetRequestHeader: function( name, value ) {\n+\t\t\t\t\tif ( completed == null ) {\n+\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n+\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n+\t\t\t\t\t\trequestHeaders[ name ] = value;\n+\t\t\t\t\t}\n+\t\t\t\t\treturn this;\n+\t\t\t\t},\n+\n+\t\t\t\t// Overrides response content-type header\n+\t\t\t\toverrideMimeType: function( type ) {\n+\t\t\t\t\tif ( completed == null ) {\n+\t\t\t\t\t\ts.mimeType = type;\n+\t\t\t\t\t}\n+\t\t\t\t\treturn this;\n+\t\t\t\t},\n+\n+\t\t\t\t// Status-dependent callbacks\n+\t\t\t\tstatusCode: function( map ) {\n+\t\t\t\t\tvar code;\n+\t\t\t\t\tif ( map ) {\n+\t\t\t\t\t\tif ( completed ) {\n+\n+\t\t\t\t\t\t\t// Execute the appropriate callbacks\n+\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n+\t\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n+\t\t\t\t\t\t\tfor ( code in map ) {\n+\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\treturn this;\n+\t\t\t\t},\n+\n+\t\t\t\t// Cancel the request\n+\t\t\t\tabort: function( statusText ) {\n+\t\t\t\t\tvar finalText = statusText || strAbort;\n+\t\t\t\t\tif ( transport ) {\n+\t\t\t\t\t\ttransport.abort( finalText );\n+\t\t\t\t\t}\n+\t\t\t\t\tdone( 0, finalText );\n+\t\t\t\t\treturn this;\n+\t\t\t\t}\n+\t\t\t};\n+\n+\t\t// Attach deferreds\n+\t\tdeferred.promise( jqXHR );\n+\n+\t\t// Add protocol if not provided (prefilters might expect it)\n+\t\t// Handle falsy url in the settings object (trac-10093: consistency with old signature)\n+\t\t// We also use the url parameter if available\n+\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n+\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n+\n+\t\t// Alias method option to type as per ticket trac-12004\n+\t\ts.type = options.method || options.type || s.method || s.type;\n+\n+\t\t// Extract dataTypes list\n+\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n+\n+\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n+\t\tif ( s.crossDomain == null ) {\n+\t\t\turlAnchor = document.createElement( \"a\" );\n+\n+\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n+\t\t\t// IE throws exception on accessing the href property if url is malformed,\n+\t\t\t// e.g. http://example.com:80x/\n+\t\t\ttry {\n+\t\t\t\turlAnchor.href = s.url;\n+\n+\t\t\t\t// Support: IE <=8 - 11 only\n+\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n+\t\t\t\turlAnchor.href = urlAnchor.href;\n+\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n+\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n+\t\t\t} catch ( e ) {\n+\n+\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n+\t\t\t\t// it can be rejected by the transport if it is invalid\n+\t\t\t\ts.crossDomain = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Convert data if not already a string\n+\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n+\t\t\ts.data = jQuery.param( s.data, s.traditional );\n+\t\t}\n+\n+\t\t// Apply prefilters\n+\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n+\n+\t\t// If request was aborted inside a prefilter, stop there\n+\t\tif ( completed ) {\n+\t\t\treturn jqXHR;\n+\t\t}\n+\n+\t\t// We can fire global events as of now if asked to\n+\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)\n+\t\tfireGlobals = jQuery.event && s.global;\n+\n+\t\t// Watch for a new set of requests\n+\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n+\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n+\t\t}\n+\n+\t\t// Uppercase the type\n+\t\ts.type = s.type.toUpperCase();\n+\n+\t\t// Determine if request has content\n+\t\ts.hasContent = !rnoContent.test( s.type );\n+\n+\t\t// Save the URL in case we're toying with the If-Modified-Since\n+\t\t// and/or If-None-Match header later on\n+\t\t// Remove hash to simplify url manipulation\n+\t\tcacheURL = s.url.replace( rhash, \"\" );\n+\n+\t\t// More options handling for requests with no content\n+\t\tif ( !s.hasContent ) {\n+\n+\t\t\t// Remember the hash so we can put it back\n+\t\t\tuncached = s.url.slice( cacheURL.length );\n+\n+\t\t\t// If data is available and should be processed, append data to url\n+\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n+\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n+\n+\t\t\t\t// trac-9682: remove data so that it's not used in an eventual retry\n+\t\t\t\tdelete s.data;\n+\t\t\t}\n+\n+\t\t\t// Add or update anti-cache param if needed\n+\t\t\tif ( s.cache === false ) {\n+\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n+\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce.guid++ ) +\n+\t\t\t\t\tuncached;\n+\t\t\t}\n+\n+\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n+\t\t\ts.url = cacheURL + uncached;\n+\n+\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n+\t\t} else if ( s.data && s.processData &&\n+\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n+\t\t\ts.data = s.data.replace( r20, \"+\" );\n+\t\t}\n+\n+\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n+\t\tif ( s.ifModified ) {\n+\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n+\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n+\t\t\t}\n+\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n+\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Set the correct header, if data is being sent\n+\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n+\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n+\t\t}\n+\n+\t\t// Set the Accepts header for the server, depending on the dataType\n+\t\tjqXHR.setRequestHeader(\n+\t\t\t\"Accept\",\n+\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n+\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n+\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n+\t\t\t\ts.accepts[ \"*\" ]\n+\t\t);\n+\n+\t\t// Check for headers option\n+\t\tfor ( i in s.headers ) {\n+\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n+\t\t}\n+\n+\t\t// Allow custom headers/mimetypes and early abort\n+\t\tif ( s.beforeSend &&\n+\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n+\n+\t\t\t// Abort if not done already and return\n+\t\t\treturn jqXHR.abort();\n+\t\t}\n+\n+\t\t// Aborting is no longer a cancellation\n+\t\tstrAbort = \"abort\";\n+\n+\t\t// Install callbacks on deferreds\n+\t\tcompleteDeferred.add( s.complete );\n+\t\tjqXHR.done( s.success );\n+\t\tjqXHR.fail( s.error );\n+\n+\t\t// Get transport\n+\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n+\n+\t\t// If no transport, we auto-abort\n+\t\tif ( !transport ) {\n+\t\t\tdone( -1, \"No Transport\" );\n+\t\t} else {\n+\t\t\tjqXHR.readyState = 1;\n+\n+\t\t\t// Send global event\n+\t\t\tif ( fireGlobals ) {\n+\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n+\t\t\t}\n+\n+\t\t\t// If request was aborted inside ajaxSend, stop there\n+\t\t\tif ( completed ) {\n+\t\t\t\treturn jqXHR;\n+\t\t\t}\n+\n+\t\t\t// Timeout\n+\t\t\tif ( s.async && s.timeout > 0 ) {\n+\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n+\t\t\t\t\tjqXHR.abort( \"timeout\" );\n+\t\t\t\t}, s.timeout );\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tcompleted = false;\n+\t\t\t\ttransport.send( requestHeaders, done );\n+\t\t\t} catch ( e ) {\n+\n+\t\t\t\t// Rethrow post-completion exceptions\n+\t\t\t\tif ( completed ) {\n+\t\t\t\t\tthrow e;\n+\t\t\t\t}\n+\n+\t\t\t\t// Propagate others as results\n+\t\t\t\tdone( -1, e );\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Callback for when everything is done\n+\t\tfunction done( status, nativeStatusText, responses, headers ) {\n+\t\t\tvar isSuccess, success, error, response, modified,\n+\t\t\t\tstatusText = nativeStatusText;\n+\n+\t\t\t// Ignore repeat invocations\n+\t\t\tif ( completed ) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tcompleted = true;\n+\n+\t\t\t// Clear timeout if it exists\n+\t\t\tif ( timeoutTimer ) {\n+\t\t\t\twindow.clearTimeout( timeoutTimer );\n+\t\t\t}\n+\n+\t\t\t// Dereference transport for early garbage collection\n+\t\t\t// (no matter how long the jqXHR object will be used)\n+\t\t\ttransport = undefined;\n+\n+\t\t\t// Cache response headers\n+\t\t\tresponseHeadersString = headers || \"\";\n+\n+\t\t\t// Set readyState\n+\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n+\n+\t\t\t// Determine if successful\n+\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n+\n+\t\t\t// Get response data\n+\t\t\tif ( responses ) {\n+\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n+\t\t\t}\n+\n+\t\t\t// Use a noop converter for missing script but not if jsonp\n+\t\t\tif ( !isSuccess &&\n+\t\t\t\tjQuery.inArray( \"script\", s.dataTypes ) > -1 &&\n+\t\t\t\tjQuery.inArray( \"json\", s.dataTypes ) < 0 ) {\n+\t\t\t\ts.converters[ \"text script\" ] = function() {};\n+\t\t\t}\n+\n+\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n+\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n+\n+\t\t\t// If successful, handle type chaining\n+\t\t\tif ( isSuccess ) {\n+\n+\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n+\t\t\t\tif ( s.ifModified ) {\n+\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n+\t\t\t\t\tif ( modified ) {\n+\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n+\t\t\t\t\t}\n+\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n+\t\t\t\t\tif ( modified ) {\n+\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// if no content\n+\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n+\t\t\t\t\tstatusText = \"nocontent\";\n+\n+\t\t\t\t// if not modified\n+\t\t\t\t} else if ( status === 304 ) {\n+\t\t\t\t\tstatusText = \"notmodified\";\n+\n+\t\t\t\t// If we have data, let's convert it\n+\t\t\t\t} else {\n+\t\t\t\t\tstatusText = response.state;\n+\t\t\t\t\tsuccess = response.data;\n+\t\t\t\t\terror = response.error;\n+\t\t\t\t\tisSuccess = !error;\n+\t\t\t\t}\n+\t\t\t} else {\n+\n+\t\t\t\t// Extract error from statusText and normalize for non-aborts\n+\t\t\t\terror = statusText;\n+\t\t\t\tif ( status || !statusText ) {\n+\t\t\t\t\tstatusText = \"error\";\n+\t\t\t\t\tif ( status < 0 ) {\n+\t\t\t\t\t\tstatus = 0;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Set data for the fake xhr object\n+\t\t\tjqXHR.status = status;\n+\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n+\n+\t\t\t// Success/Error\n+\t\t\tif ( isSuccess ) {\n+\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n+\t\t\t} else {\n+\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n+\t\t\t}\n+\n+\t\t\t// Status-dependent callbacks\n+\t\t\tjqXHR.statusCode( statusCode );\n+\t\t\tstatusCode = undefined;\n+\n+\t\t\tif ( fireGlobals ) {\n+\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n+\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n+\t\t\t}\n+\n+\t\t\t// Complete\n+\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n+\n+\t\t\tif ( fireGlobals ) {\n+\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n+\n+\t\t\t\t// Handle the global AJAX counter\n+\t\t\t\tif ( !( --jQuery.active ) ) {\n+\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn jqXHR;\n+\t},\n+\n+\tgetJSON: function( url, data, callback ) {\n+\t\treturn jQuery.get( url, data, callback, \"json\" );\n+\t},\n+\n+\tgetScript: function( url, callback ) {\n+\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n+\t}\n+} );\n+\n+jQuery.each( [ \"get\", \"post\" ], function( _i, method ) {\n+\tjQuery[ method ] = function( url, data, callback, type ) {\n+\n+\t\t// Shift arguments if data argument was omitted\n+\t\tif ( isFunction( data ) ) {\n+\t\t\ttype = type || callback;\n+\t\t\tcallback = data;\n+\t\t\tdata = undefined;\n+\t\t}\n+\n+\t\t// The url can be an options object (which then must have .url)\n+\t\treturn jQuery.ajax( jQuery.extend( {\n+\t\t\turl: url,\n+\t\t\ttype: method,\n+\t\t\tdataType: type,\n+\t\t\tdata: data,\n+\t\t\tsuccess: callback\n+\t\t}, jQuery.isPlainObject( url ) && url ) );\n+\t};\n+} );\n+\n+jQuery.ajaxPrefilter( function( s ) {\n+\tvar i;\n+\tfor ( i in s.headers ) {\n+\t\tif ( i.toLowerCase() === \"content-type\" ) {\n+\t\t\ts.contentType = s.headers[ i ] || \"\";\n+\t\t}\n+\t}\n+} );\n+\n+\n+jQuery._evalUrl = function( url, options, doc ) {\n+\treturn jQuery.ajax( {\n+\t\turl: url,\n+\n+\t\t// Make this explicit, since user can override this through ajaxSetup (trac-11264)\n+\t\ttype: \"GET\",\n+\t\tdataType: \"script\",\n+\t\tcache: true,\n+\t\tasync: false,\n+\t\tglobal: false,\n+\n+\t\t// Only evaluate the response if it is successful (gh-4126)\n+\t\t// dataFilter is not invoked for failure responses, so using it instead\n+\t\t// of the default converter is kludgy but it works.\n+\t\tconverters: {\n+\t\t\t\"text script\": function() {}\n+\t\t},\n+\t\tdataFilter: function( response ) {\n+\t\t\tjQuery.globalEval( response, options, doc );\n+\t\t}\n+\t} );\n+};\n+\n+\n+jQuery.fn.extend( {\n+\twrapAll: function( html ) {\n+\t\tvar wrap;\n+\n+\t\tif ( this[ 0 ] ) {\n+\t\t\tif ( isFunction( html ) ) {\n+\t\t\t\thtml = html.call( this[ 0 ] );\n+\t\t\t}\n+\n+\t\t\t// The elements to wrap the target around\n+\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n+\n+\t\t\tif ( this[ 0 ].parentNode ) {\n+\t\t\t\twrap.insertBefore( this[ 0 ] );\n+\t\t\t}\n+\n+\t\t\twrap.map( function() {\n+\t\t\t\tvar elem = this;\n+\n+\t\t\t\twhile ( elem.firstElementChild ) {\n+\t\t\t\t\telem = elem.firstElementChild;\n+\t\t\t\t}\n+\n+\t\t\t\treturn elem;\n+\t\t\t} ).append( this );\n+\t\t}\n+\n+\t\treturn this;\n+\t},\n+\n+\twrapInner: function( html ) {\n+\t\tif ( isFunction( html ) ) {\n+\t\t\treturn this.each( function( i ) {\n+\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n+\t\t\t} );\n+\t\t}\n+\n+\t\treturn this.each( function() {\n+\t\t\tvar self = jQuery( this ),\n+\t\t\t\tcontents = self.contents();\n+\n+\t\t\tif ( contents.length ) {\n+\t\t\t\tcontents.wrapAll( html );\n+\n+\t\t\t} else {\n+\t\t\t\tself.append( html );\n+\t\t\t}\n+\t\t} );\n+\t},\n+\n+\twrap: function( html ) {\n+\t\tvar htmlIsFunction = isFunction( html );\n+\n+\t\treturn this.each( function( i ) {\n+\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n+\t\t} );\n+\t},\n+\n+\tunwrap: function( selector ) {\n+\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n+\t\t\tjQuery( this ).replaceWith( this.childNodes );\n+\t\t} );\n+\t\treturn this;\n+\t}\n+} );\n+\n+\n+jQuery.expr.pseudos.hidden = function( elem ) {\n+\treturn !jQuery.expr.pseudos.visible( elem );\n+};\n+jQuery.expr.pseudos.visible = function( elem ) {\n+\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n+};\n+\n+\n+\n+\n+jQuery.ajaxSettings.xhr = function() {\n+\ttry {\n+\t\treturn new window.XMLHttpRequest();\n+\t} catch ( e ) {}\n+};\n+\n+var xhrSuccessStatus = {\n+\n+\t\t// File protocol always yields status code 0, assume 200\n+\t\t0: 200,\n+\n+\t\t// Support: IE <=9 only\n+\t\t// trac-1450: sometimes IE returns 1223 when it should be 204\n+\t\t1223: 204\n+\t},\n+\txhrSupported = jQuery.ajaxSettings.xhr();\n+\n+support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n+support.ajax = xhrSupported = !!xhrSupported;\n+\n+jQuery.ajaxTransport( function( options ) {\n+\tvar callback, errorCallback;\n+\n+\t// Cross domain only allowed if supported through XMLHttpRequest\n+\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n+\t\treturn {\n+\t\t\tsend: function( headers, complete ) {\n+\t\t\t\tvar i,\n+\t\t\t\t\txhr = options.xhr();\n+\n+\t\t\t\txhr.open(\n+\t\t\t\t\toptions.type,\n+\t\t\t\t\toptions.url,\n+\t\t\t\t\toptions.async,\n+\t\t\t\t\toptions.username,\n+\t\t\t\t\toptions.password\n+\t\t\t\t);\n+\n+\t\t\t\t// Apply custom fields if provided\n+\t\t\t\tif ( options.xhrFields ) {\n+\t\t\t\t\tfor ( i in options.xhrFields ) {\n+\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// Override mime type if needed\n+\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n+\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n+\t\t\t\t}\n+\n+\t\t\t\t// X-Requested-With header\n+\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n+\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n+\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n+\t\t\t\t// For same-domain requests, won't change header if already provided.\n+\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n+\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n+\t\t\t\t}\n+\n+\t\t\t\t// Set headers\n+\t\t\t\tfor ( i in headers ) {\n+\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n+\t\t\t\t}\n+\n+\t\t\t\t// Callback\n+\t\t\t\tcallback = function( type ) {\n+\t\t\t\t\treturn function() {\n+\t\t\t\t\t\tif ( callback ) {\n+\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n+\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n+\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n+\n+\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n+\t\t\t\t\t\t\t\txhr.abort();\n+\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n+\n+\t\t\t\t\t\t\t\t// Support: IE <=9 only\n+\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n+\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n+\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n+\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tcomplete(\n+\n+\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see trac-8605, trac-14207\n+\t\t\t\t\t\t\t\t\t\txhr.status,\n+\t\t\t\t\t\t\t\t\t\txhr.statusText\n+\t\t\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tcomplete(\n+\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n+\t\t\t\t\t\t\t\t\txhr.statusText,\n+\n+\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n+\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n+\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n+\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n+\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n+\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n+\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n+\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n+\t\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t};\n+\t\t\t\t};\n+\n+\t\t\t\t// Listen to events\n+\t\t\t\txhr.onload = callback();\n+\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n+\n+\t\t\t\t// Support: IE 9 only\n+\t\t\t\t// Use onreadystatechange to replace onabort\n+\t\t\t\t// to handle uncaught aborts\n+\t\t\t\tif ( xhr.onabort !== undefined ) {\n+\t\t\t\t\txhr.onabort = errorCallback;\n+\t\t\t\t} else {\n+\t\t\t\t\txhr.onreadystatechange = function() {\n+\n+\t\t\t\t\t\t// Check readyState before timeout as it changes\n+\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n+\n+\t\t\t\t\t\t\t// Allow onerror to be called first,\n+\t\t\t\t\t\t\t// but that will not handle a native abort\n+\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n+\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n+\t\t\t\t\t\t\twindow.setTimeout( function() {\n+\t\t\t\t\t\t\t\tif ( callback ) {\n+\t\t\t\t\t\t\t\t\terrorCallback();\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t} );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t};\n+\t\t\t\t}\n+\n+\t\t\t\t// Create the abort callback\n+\t\t\t\tcallback = callback( \"abort\" );\n+\n+\t\t\t\ttry {\n+\n+\t\t\t\t\t// Do send the request (this may raise an exception)\n+\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n+\t\t\t\t} catch ( e ) {\n+\n+\t\t\t\t\t// trac-14683: Only rethrow if this hasn't been notified as an error yet\n+\t\t\t\t\tif ( callback ) {\n+\t\t\t\t\t\tthrow e;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t},\n+\n+\t\t\tabort: function() {\n+\t\t\t\tif ( callback ) {\n+\t\t\t\t\tcallback();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t}\n+} );\n+\n+\n+\n+\n+// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n+jQuery.ajaxPrefilter( function( s ) {\n+\tif ( s.crossDomain ) {\n+\t\ts.contents.script = false;\n+\t}\n+} );\n+\n+// Install script dataType\n+jQuery.ajaxSetup( {\n+\taccepts: {\n+\t\tscript: \"text/javascript, application/javascript, \" +\n+\t\t\t\"application/ecmascript, application/x-ecmascript\"\n+\t},\n+\tcontents: {\n+\t\tscript: /\\b(?:java|ecma)script\\b/\n+\t},\n+\tconverters: {\n+\t\t\"text script\": function( text ) {\n+\t\t\tjQuery.globalEval( text );\n+\t\t\treturn text;\n+\t\t}\n+\t}\n+} );\n+\n+// Handle cache's special case and crossDomain\n+jQuery.ajaxPrefilter( \"script\", function( s ) {\n+\tif ( s.cache === undefined ) {\n+\t\ts.cache = false;\n+\t}\n+\tif ( s.crossDomain ) {\n+\t\ts.type = \"GET\";\n+\t}\n+} );\n+\n+// Bind script tag hack transport\n+jQuery.ajaxTransport( \"script\", function( s ) {\n+\n+\t// This transport only deals with cross domain or forced-by-attrs requests\n+\tif ( s.crossDomain || s.scriptAttrs ) {\n+\t\tvar script, callback;\n+\t\treturn {\n+\t\t\tsend: function( _, complete ) {\n+\t\t\t\tscript = jQuery( \"<script>\" )\n+\t\t\t\t\t.attr( s.scriptAttrs || {} )\n+\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n+\t\t\t\t\t.on( \"load error\", callback = function( evt ) {\n+\t\t\t\t\t\tscript.remove();\n+\t\t\t\t\t\tcallback = null;\n+\t\t\t\t\t\tif ( evt ) {\n+\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} );\n+\n+\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n+\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n+\t\t\t},\n+\t\t\tabort: function() {\n+\t\t\t\tif ( callback ) {\n+\t\t\t\t\tcallback();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t}\n+} );\n+\n+\n+\n+\n+var oldCallbacks = [],\n+\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n+\n+// Default jsonp settings\n+jQuery.ajaxSetup( {\n+\tjsonp: \"callback\",\n+\tjsonpCallback: function() {\n+\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce.guid++ ) );\n+\t\tthis[ callback ] = true;\n+\t\treturn callback;\n+\t}\n+} );\n+\n+// Detect, normalize options and install callbacks for jsonp requests\n+jQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n+\n+\tvar callbackName, overwritten, responseContainer,\n+\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n+\t\t\t\"url\" :\n+\t\t\ttypeof s.data === \"string\" &&\n+\t\t\t\t( s.contentType || \"\" )\n+\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n+\t\t\t\trjsonp.test( s.data ) && \"data\"\n+\t\t);\n+\n+\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n+\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n+\n+\t\t// Get callback name, remembering preexisting value associated with it\n+\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n+\t\t\ts.jsonpCallback() :\n+\t\t\ts.jsonpCallback;\n+\n+\t\t// Insert callback into url or form data\n+\t\tif ( jsonProp ) {\n+\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n+\t\t} else if ( s.jsonp !== false ) {\n+\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n+\t\t}\n+\n+\t\t// Use data converter to retrieve json after script execution\n+\t\ts.converters[ \"script json\" ] = function() {\n+\t\t\tif ( !responseContainer ) {\n+\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n+\t\t\t}\n+\t\t\treturn responseContainer[ 0 ];\n+\t\t};\n+\n+\t\t// Force json dataType\n+\t\ts.dataTypes[ 0 ] = \"json\";\n+\n+\t\t// Install callback\n+\t\toverwritten = window[ callbackName ];\n+\t\twindow[ callbackName ] = function() {\n+\t\t\tresponseContainer = arguments;\n+\t\t};\n+\n+\t\t// Clean-up function (fires after converters)\n+\t\tjqXHR.always( function() {\n+\n+\t\t\t// If previous value didn't exist - remove it\n+\t\t\tif ( overwritten === undefined ) {\n+\t\t\t\tjQuery( window ).removeProp( callbackName );\n+\n+\t\t\t// Otherwise restore preexisting value\n+\t\t\t} else {\n+\t\t\t\twindow[ callbackName ] = overwritten;\n+\t\t\t}\n+\n+\t\t\t// Save back as free\n+\t\t\tif ( s[ callbackName ] ) {\n+\n+\t\t\t\t// Make sure that re-using the options doesn't screw things around\n+\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n+\n+\t\t\t\t// Save the callback name for future use\n+\t\t\t\toldCallbacks.push( callbackName );\n+\t\t\t}\n+\n+\t\t\t// Call if it was a function and we have a response\n+\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n+\t\t\t\toverwritten( responseContainer[ 0 ] );\n+\t\t\t}\n+\n+\t\t\tresponseContainer = overwritten = undefined;\n+\t\t} );\n+\n+\t\t// Delegate to script\n+\t\treturn \"script\";\n+\t}\n+} );\n+\n+\n+\n+\n+// Support: Safari 8 only\n+// In Safari 8 documents created via document.implementation.createHTMLDocument\n+// collapse sibling forms: the second one becomes a child of the first one.\n+// Because of that, this security measure has to be disabled in Safari 8.\n+// https://bugs.webkit.org/show_bug.cgi?id=137337\n+support.createHTMLDocument = ( function() {\n+\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n+\tbody.innerHTML = \"<form></form><form></form>\";\n+\treturn body.childNodes.length === 2;\n+} )();\n+\n+\n+// Argument \"data\" should be string of html\n+// context (optional): If specified, the fragment will be created in this context,\n+// defaults to document\n+// keepScripts (optional): If true, will include scripts passed in the html string\n+jQuery.parseHTML = function( data, context, keepScripts ) {\n+\tif ( typeof data !== \"string\" ) {\n+\t\treturn [];\n+\t}\n+\tif ( typeof context === \"boolean\" ) {\n+\t\tkeepScripts = context;\n+\t\tcontext = false;\n+\t}\n+\n+\tvar base, parsed, scripts;\n+\n+\tif ( !context ) {\n+\n+\t\t// Stop scripts or inline event handlers from being executed immediately\n+\t\t// by using document.implementation\n+\t\tif ( support.createHTMLDocument ) {\n+\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n+\n+\t\t\t// Set the base href for the created document\n+\t\t\t// so any parsed elements with URLs\n+\t\t\t// are based on the document's URL (gh-2965)\n+\t\t\tbase = context.createElement( \"base\" );\n+\t\t\tbase.href = document.location.href;\n+\t\t\tcontext.head.appendChild( base );\n+\t\t} else {\n+\t\t\tcontext = document;\n+\t\t}\n+\t}\n+\n+\tparsed = rsingleTag.exec( data );\n+\tscripts = !keepScripts && [];\n+\n+\t// Single tag\n+\tif ( parsed ) {\n+\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n+\t}\n+\n+\tparsed = buildFragment( [ data ], context, scripts );\n+\n+\tif ( scripts && scripts.length ) {\n+\t\tjQuery( scripts ).remove();\n+\t}\n+\n+\treturn jQuery.merge( [], parsed.childNodes );\n+};\n+\n+\n+/**\n+ * Load a url into a page\n+ */\n+jQuery.fn.load = function( url, params, callback ) {\n+\tvar selector, type, response,\n+\t\tself = this,\n+\t\toff = url.indexOf( \" \" );\n+\n+\tif ( off > -1 ) {\n+\t\tselector = stripAndCollapse( url.slice( off ) );\n+\t\turl = url.slice( 0, off );\n+\t}\n+\n+\t// If it's a function\n+\tif ( isFunction( params ) ) {\n+\n+\t\t// We assume that it's the callback\n+\t\tcallback = params;\n+\t\tparams = undefined;\n+\n+\t// Otherwise, build a param string\n+\t} else if ( params && typeof params === \"object\" ) {\n+\t\ttype = \"POST\";\n+\t}\n+\n+\t// If we have elements to modify, make the request\n+\tif ( self.length > 0 ) {\n+\t\tjQuery.ajax( {\n+\t\t\turl: url,\n+\n+\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n+\t\t\t// Make value of this field explicit since\n+\t\t\t// user can override it through ajaxSetup method\n+\t\t\ttype: type || \"GET\",\n+\t\t\tdataType: \"html\",\n+\t\t\tdata: params\n+\t\t} ).done( function( responseText ) {\n+\n+\t\t\t// Save response for use in complete callback\n+\t\t\tresponse = arguments;\n+\n+\t\t\tself.html( selector ?\n+\n+\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n+\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n+\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n+\n+\t\t\t\t// Otherwise use the full result\n+\t\t\t\tresponseText );\n+\n+\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n+\t\t// but they are ignored because response was set above.\n+\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n+\t\t} ).always( callback && function( jqXHR, status ) {\n+\t\t\tself.each( function() {\n+\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n+\t\t\t} );\n+\t\t} );\n+\t}\n+\n+\treturn this;\n+};\n+\n+\n+\n+\n+jQuery.expr.pseudos.animated = function( elem ) {\n+\treturn jQuery.grep( jQuery.timers, function( fn ) {\n+\t\treturn elem === fn.elem;\n+\t} ).length;\n+};\n+\n+\n+\n+\n+jQuery.offset = {\n+\tsetOffset: function( elem, options, i ) {\n+\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n+\t\t\tposition = jQuery.css( elem, \"position\" ),\n+\t\t\tcurElem = jQuery( elem ),\n+\t\t\tprops = {};\n+\n+\t\t// Set position first, in-case top/left are set even on static elem\n+\t\tif ( position === \"static\" ) {\n+\t\t\telem.style.position = \"relative\";\n+\t\t}\n+\n+\t\tcurOffset = curElem.offset();\n+\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n+\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n+\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n+\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n+\n+\t\t// Need to be able to calculate position if either\n+\t\t// top or left is auto and position is either absolute or fixed\n+\t\tif ( calculatePosition ) {\n+\t\t\tcurPosition = curElem.position();\n+\t\t\tcurTop = curPosition.top;\n+\t\t\tcurLeft = curPosition.left;\n+\n+\t\t} else {\n+\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n+\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n+\t\t}\n+\n+\t\tif ( isFunction( options ) ) {\n+\n+\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n+\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n+\t\t}\n+\n+\t\tif ( options.top != null ) {\n+\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n+\t\t}\n+\t\tif ( options.left != null ) {\n+\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n+\t\t}\n+\n+\t\tif ( \"using\" in options ) {\n+\t\t\toptions.using.call( elem, props );\n+\n+\t\t} else {\n+\t\t\tcurElem.css( props );\n+\t\t}\n+\t}\n+};\n+\n+jQuery.fn.extend( {\n+\n+\t// offset() relates an element's border box to the document origin\n+\toffset: function( options ) {\n+\n+\t\t// Preserve chaining for setter\n+\t\tif ( arguments.length ) {\n+\t\t\treturn options === undefined ?\n+\t\t\t\tthis :\n+\t\t\t\tthis.each( function( i ) {\n+\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n+\t\t\t\t} );\n+\t\t}\n+\n+\t\tvar rect, win,\n+\t\t\telem = this[ 0 ];\n+\n+\t\tif ( !elem ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n+\t\t// Support: IE <=11 only\n+\t\t// Running getBoundingClientRect on a\n+\t\t// disconnected node in IE throws an error\n+\t\tif ( !elem.getClientRects().length ) {\n+\t\t\treturn { top: 0, left: 0 };\n+\t\t}\n+\n+\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n+\t\trect = elem.getBoundingClientRect();\n+\t\twin = elem.ownerDocument.defaultView;\n+\t\treturn {\n+\t\t\ttop: rect.top + win.pageYOffset,\n+\t\t\tleft: rect.left + win.pageXOffset\n+\t\t};\n+\t},\n+\n+\t// position() relates an element's margin box to its offset parent's padding box\n+\t// This corresponds to the behavior of CSS absolute positioning\n+\tposition: function() {\n+\t\tif ( !this[ 0 ] ) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tvar offsetParent, offset, doc,\n+\t\t\telem = this[ 0 ],\n+\t\t\tparentOffset = { top: 0, left: 0 };\n+\n+\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n+\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n+\n+\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n+\t\t\toffset = elem.getBoundingClientRect();\n+\n+\t\t} else {\n+\t\t\toffset = this.offset();\n+\n+\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n+\t\t\t// when a statically positioned element is identified\n+\t\t\tdoc = elem.ownerDocument;\n+\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n+\t\t\twhile ( offsetParent &&\n+\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n+\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n+\n+\t\t\t\toffsetParent = offsetParent.parentNode;\n+\t\t\t}\n+\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n+\n+\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n+\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n+\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n+\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Subtract parent offsets and element margins\n+\t\treturn {\n+\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n+\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n+\t\t};\n+\t},\n+\n+\t// This method will return documentElement in the following cases:\n+\t// 1) For the element inside the iframe without offsetParent, this method will return\n+\t//    documentElement of the parent window\n+\t// 2) For the hidden or detached element\n+\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n+\t//\n+\t// but those exceptions were never presented as a real life use-cases\n+\t// and might be considered as more preferable results.\n+\t//\n+\t// This logic, however, is not guaranteed and can change at any point in the future\n+\toffsetParent: function() {\n+\t\treturn this.map( function() {\n+\t\t\tvar offsetParent = this.offsetParent;\n+\n+\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n+\t\t\t\toffsetParent = offsetParent.offsetParent;\n+\t\t\t}\n+\n+\t\t\treturn offsetParent || documentElement;\n+\t\t} );\n+\t}\n+} );\n+\n+// Create scrollLeft and scrollTop methods\n+jQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n+\tvar top = \"pageYOffset\" === prop;\n+\n+\tjQuery.fn[ method ] = function( val ) {\n+\t\treturn access( this, function( elem, method, val ) {\n+\n+\t\t\t// Coalesce documents and windows\n+\t\t\tvar win;\n+\t\t\tif ( isWindow( elem ) ) {\n+\t\t\t\twin = elem;\n+\t\t\t} else if ( elem.nodeType === 9 ) {\n+\t\t\t\twin = elem.defaultView;\n+\t\t\t}\n+\n+\t\t\tif ( val === undefined ) {\n+\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n+\t\t\t}\n+\n+\t\t\tif ( win ) {\n+\t\t\t\twin.scrollTo(\n+\t\t\t\t\t!top ? val : win.pageXOffset,\n+\t\t\t\t\ttop ? val : win.pageYOffset\n+\t\t\t\t);\n+\n+\t\t\t} else {\n+\t\t\t\telem[ method ] = val;\n+\t\t\t}\n+\t\t}, method, val, arguments.length );\n+\t};\n+} );\n+\n+// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n+// Add the top/left cssHooks using jQuery.fn.position\n+// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n+// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n+// getComputedStyle returns percent when specified for top/left/bottom/right;\n+// rather than make the css module depend on the offset module, just check for it here\n+jQuery.each( [ \"top\", \"left\" ], function( _i, prop ) {\n+\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n+\t\tfunction( elem, computed ) {\n+\t\t\tif ( computed ) {\n+\t\t\t\tcomputed = curCSS( elem, prop );\n+\n+\t\t\t\t// If curCSS returns percentage, fallback to offset\n+\t\t\t\treturn rnumnonpx.test( computed ) ?\n+\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n+\t\t\t\t\tcomputed;\n+\t\t\t}\n+\t\t}\n+\t);\n+} );\n+\n+\n+// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n+jQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n+\tjQuery.each( {\n+\t\tpadding: \"inner\" + name,\n+\t\tcontent: type,\n+\t\t\"\": \"outer\" + name\n+\t}, function( defaultExtra, funcName ) {\n+\n+\t\t// Margin is only for outerHeight, outerWidth\n+\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n+\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n+\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n+\n+\t\t\treturn access( this, function( elem, type, value ) {\n+\t\t\t\tvar doc;\n+\n+\t\t\t\tif ( isWindow( elem ) ) {\n+\n+\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n+\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n+\t\t\t\t\t\telem[ \"inner\" + name ] :\n+\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n+\t\t\t\t}\n+\n+\t\t\t\t// Get document width or height\n+\t\t\t\tif ( elem.nodeType === 9 ) {\n+\t\t\t\t\tdoc = elem.documentElement;\n+\n+\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n+\t\t\t\t\t// whichever is greatest\n+\t\t\t\t\treturn Math.max(\n+\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n+\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n+\t\t\t\t\t\tdoc[ \"client\" + name ]\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\n+\t\t\t\treturn value === undefined ?\n+\n+\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n+\t\t\t\t\tjQuery.css( elem, type, extra ) :\n+\n+\t\t\t\t\t// Set width or height on the element\n+\t\t\t\t\tjQuery.style( elem, type, value, extra );\n+\t\t\t}, type, chainable ? margin : undefined, chainable );\n+\t\t};\n+\t} );\n+} );\n+\n+\n+jQuery.each( [\n+\t\"ajaxStart\",\n+\t\"ajaxStop\",\n+\t\"ajaxComplete\",\n+\t\"ajaxError\",\n+\t\"ajaxSuccess\",\n+\t\"ajaxSend\"\n+], function( _i, type ) {\n+\tjQuery.fn[ type ] = function( fn ) {\n+\t\treturn this.on( type, fn );\n+\t};\n+} );\n+\n+\n+\n+\n+jQuery.fn.extend( {\n+\n+\tbind: function( types, data, fn ) {\n+\t\treturn this.on( types, null, data, fn );\n+\t},\n+\tunbind: function( types, fn ) {\n+\t\treturn this.off( types, null, fn );\n+\t},\n+\n+\tdelegate: function( selector, types, data, fn ) {\n+\t\treturn this.on( types, selector, data, fn );\n+\t},\n+\tundelegate: function( selector, types, fn ) {\n+\n+\t\t// ( namespace ) or ( selector, types [, fn] )\n+\t\treturn arguments.length === 1 ?\n+\t\t\tthis.off( selector, \"**\" ) :\n+\t\t\tthis.off( types, selector || \"**\", fn );\n+\t},\n+\n+\thover: function( fnOver, fnOut ) {\n+\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n+\t}\n+} );\n+\n+jQuery.each(\n+\t( \"blur focus focusin focusout resize scroll click dblclick \" +\n+\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n+\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n+\tfunction( _i, name ) {\n+\n+\t\t// Handle event binding\n+\t\tjQuery.fn[ name ] = function( data, fn ) {\n+\t\t\treturn arguments.length > 0 ?\n+\t\t\t\tthis.on( name, null, data, fn ) :\n+\t\t\t\tthis.trigger( name );\n+\t\t};\n+\t}\n+);\n+\n+\n+\n+\n+// Support: Android <=4.0 only\n+// Make sure we trim BOM and NBSP\n+// Require that the \"whitespace run\" starts from a non-whitespace\n+// to avoid O(N^2) behavior when the engine would try matching \"\\s+$\" at each space position.\n+var rtrim = /^[\\s\\uFEFF\\xA0]+|([^\\s\\uFEFF\\xA0])[\\s\\uFEFF\\xA0]+$/g;\n+\n+// Bind a function to a context, optionally partially applying any\n+// arguments.\n+// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n+// However, it is not slated for removal any time soon\n+jQuery.proxy = function( fn, context ) {\n+\tvar tmp, args, proxy;\n+\n+\tif ( typeof context === \"string\" ) {\n+\t\ttmp = fn[ context ];\n+\t\tcontext = fn;\n+\t\tfn = tmp;\n+\t}\n+\n+\t// Quick check to determine if target is callable, in the spec\n+\t// this throws a TypeError, but we will just return undefined.\n+\tif ( !isFunction( fn ) ) {\n+\t\treturn undefined;\n+\t}\n+\n+\t// Simulated bind\n+\targs = slice.call( arguments, 2 );\n+\tproxy = function() {\n+\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n+\t};\n+\n+\t// Set the guid of unique handler to the same of original handler, so it can be removed\n+\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n+\n+\treturn proxy;\n+};\n+\n+jQuery.holdReady = function( hold ) {\n+\tif ( hold ) {\n+\t\tjQuery.readyWait++;\n+\t} else {\n+\t\tjQuery.ready( true );\n+\t}\n+};\n+jQuery.isArray = Array.isArray;\n+jQuery.parseJSON = JSON.parse;\n+jQuery.nodeName = nodeName;\n+jQuery.isFunction = isFunction;\n+jQuery.isWindow = isWindow;\n+jQuery.camelCase = camelCase;\n+jQuery.type = toType;\n+\n+jQuery.now = Date.now;\n+\n+jQuery.isNumeric = function( obj ) {\n+\n+\t// As of jQuery 3.0, isNumeric is limited to\n+\t// strings and numbers (primitives or objects)\n+\t// that can be coerced to finite numbers (gh-2662)\n+\tvar type = jQuery.type( obj );\n+\treturn ( type === \"number\" || type === \"string\" ) &&\n+\n+\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n+\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n+\t\t// subtraction forces infinities to NaN\n+\t\t!isNaN( obj - parseFloat( obj ) );\n+};\n+\n+jQuery.trim = function( text ) {\n+\treturn text == null ?\n+\t\t\"\" :\n+\t\t( text + \"\" ).replace( rtrim, \"$1\" );\n+};\n+\n+\n+\n+// Register as a named AMD module, since jQuery can be concatenated with other\n+// files that may use define, but not via a proper concatenation script that\n+// understands anonymous AMD modules. A named AMD is safest and most robust\n+// way to register. Lowercase jquery is used because AMD module names are\n+// derived from file names, and jQuery is normally delivered in a lowercase\n+// file name. Do this after creating the global so that if an AMD module wants\n+// to call noConflict to hide this version of jQuery, it will work.\n+\n+// Note that for maximum portability, libraries that are not jQuery should\n+// declare themselves as anonymous modules, and avoid setting a global if an\n+// AMD loader is present. jQuery is a special case. For more information, see\n+// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n+\n+if ( typeof define === \"function\" && define.amd ) {\n+\tdefine( \"jquery\", [], function() {\n+\t\treturn jQuery;\n+\t} );\n+}\n+\n+\n+\n+\n+var\n+\n+\t// Map over jQuery in case of overwrite\n+\t_jQuery = window.jQuery,\n+\n+\t// Map over the $ in case of overwrite\n+\t_$ = window.$;\n+\n+jQuery.noConflict = function( deep ) {\n+\tif ( window.$ === jQuery ) {\n+\t\twindow.$ = _$;\n+\t}\n+\n+\tif ( deep && window.jQuery === jQuery ) {\n+\t\twindow.jQuery = _jQuery;\n+\t}\n+\n+\treturn jQuery;\n+};\n+\n+// Expose jQuery and $ identifiers, even in AMD\n+// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)\n+// and CommonJS for browser emulators (trac-13566)\n+if ( typeof noGlobal === \"undefined\" ) {\n+\twindow.jQuery = window.$ = jQuery;\n+}\n+\n+\n+\n+\n+return jQuery;\n+} );\n"
                },
                {
                    "date": 1674994777100,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10993 +1,3090 @@\n-/*!\n- * jQuery JavaScript Library v3.6.3\n- * https://jquery.com/\n- *\n- * Includes Sizzle.js\n- * https://sizzlejs.com/\n- *\n- * Copyright OpenJS Foundation and other contributors\n- * Released under the MIT license\n- * https://jquery.org/license\n- *\n- * Date: 2022-12-20T21:28Z\n- */\n-( function( global, factory ) {\n+/*! jQuery v2.1.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */ ! function(a, b) {\n+    \"object\" == typeof module && \"object\" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {\n+        if (!a.document) throw new Error(\"jQuery requires a window with a document\");\n+        return b(a)\n+    } : b(a)\n+}(\"undefined\" != typeof window ? window : this, function(a, b) {\n+    var c = [],\n+        d = c.slice,\n+        e = c.concat,\n+        f = c.push,\n+        g = c.indexOf,\n+        h = {},\n+        i = h.toString,\n+        j = h.hasOwnProperty,\n+        k = \"\".trim,\n+        l = {},\n+        m = a.document,\n+        n = \"2.1.0\",\n+        o = function(a, b) {\n+            return new o.fn.init(a, b)\n+        },\n+        p = /^-ms-/,\n+        q = /-([\\da-z])/gi,\n+        r = function(a, b) {\n+            return b.toUpperCase()\n+        };\n+    o.fn = o.prototype = {\n+        jquery: n,\n+        constructor: o,\n+        selector: \"\",\n+        length: 0,\n+        toArray: function() {\n+            return d.call(this)\n+        },\n+        get: function(a) {\n+            return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this)\n+        },\n+        pushStack: function(a) {\n+            var b = o.merge(this.constructor(), a);\n+            return b.prevObject = this, b.context = this.context, b\n+        },\n+        each: function(a, b) {\n+            return o.each(this, a, b)\n+        },\n+        map: function(a) {\n+            return this.pushStack(o.map(this, function(b, c) {\n+                return a.call(b, c, b)\n+            }))\n+        },\n+        slice: function() {\n+            return this.pushStack(d.apply(this, arguments))\n+        },\n+        first: function() {\n+            return this.eq(0)\n+        },\n+        last: function() {\n+            return this.eq(-1)\n+        },\n+        eq: function(a) {\n+            var b = this.length,\n+                c = +a + (0 > a ? b : 0);\n+            return this.pushStack(c >= 0 && b > c ? [this[c]] : [])\n+        },\n+        end: function() {\n+            return this.prevObject || this.constructor(null)\n+        },\n+        push: f,\n+        sort: c.sort,\n+        splice: c.splice\n+    }, o.extend = o.fn.extend = function() {\n+        var a, b, c, d, e, f, g = arguments[0] || {},\n+            h = 1,\n+            i = arguments.length,\n+            j = !1;\n+        for (\"boolean\" == typeof g && (j = g, g = arguments[h] || {}, h++), \"object\" == typeof g || o.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)\n+            if (null != (a = arguments[h]))\n+                for (b in a) c = g[b], d = a[b], g !== d && (j && d && (o.isPlainObject(d) || (e = o.isArray(d))) ? (e ? (e = !1, f = c && o.isArray(c) ? c : []) : f = c && o.isPlainObject(c) ? c : {}, g[b] = o.extend(j, f, d)) : void 0 !== d && (g[b] = d));\n+        return g\n+    }, o.extend({\n+        expando: \"jQuery\" + (n + Math.random()).replace(/\\D/g, \"\"),\n+        isReady: !0,\n+        error: function(a) {\n+            throw new Error(a)\n+        },\n+        noop: function() {},\n+        isFunction: function(a) {\n+            return \"function\" === o.type(a)\n+        },\n+        isArray: Array.isArray,\n+        isWindow: function(a) {\n+            return null != a && a === a.window\n+        },\n+        isNumeric: function(a) {\n+            return a - parseFloat(a) >= 0\n+        },\n+        isPlainObject: function(a) {\n+            if (\"object\" !== o.type(a) || a.nodeType || o.isWindow(a)) return !1;\n+            try {\n+                if (a.constructor && !j.call(a.constructor.prototype, \"isPrototypeOf\")) return !1\n+            } catch (b) {\n+                return !1\n+            }\n+            return !0\n+        },\n+        isEmptyObject: function(a) {\n+            var b;\n+            for (b in a) return !1;\n+            return !0\n+        },\n+        type: function(a) {\n+            return null == a ? a + \"\" : \"object\" == typeof a || \"function\" == typeof a ? h[i.call(a)] || \"object\" : typeof a\n+        },\n+        globalEval: function(a) {\n+            var b, c = eval;\n+            a = o.trim(a), a && (1 === a.indexOf(\"use strict\") ? (b = m.createElement(\"script\"), b.text = a, m.head.appendChild(b).parentNode.removeChild(b)) : c(a))\n+        },\n+        camelCase: function(a) {\n+            return a.replace(p, \"ms-\").replace(q, r)\n+        },\n+        nodeName: function(a, b) {\n+            return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()\n+        },\n+        each: function(a, b, c) {\n+            var d, e = 0,\n+                f = a.length,\n+                g = s(a);\n+            if (c) {\n+                if (g) {\n+                    for (; f > e; e++)\n+                        if (d = b.apply(a[e], c), d === !1) break\n+                } else\n+                    for (e in a)\n+                        if (d = b.apply(a[e], c), d === !1) break\n+            } else if (g) {\n+                for (; f > e; e++)\n+                    if (d = b.call(a[e], e, a[e]), d === !1) break\n+            } else\n+                for (e in a)\n+                    if (d = b.call(a[e], e, a[e]), d === !1) break;\n+            return a\n+        },\n+        trim: function(a) {\n+            return null == a ? \"\" : k.call(a)\n+        },\n+        makeArray: function(a, b) {\n+            var c = b || [];\n+            return null != a && (s(Object(a)) ? o.merge(c, \"string\" == typeof a ? [a] : a) : f.call(c, a)), c\n+        },\n+        inArray: function(a, b, c) {\n+            return null == b ? -1 : g.call(b, a, c)\n+        },\n+        merge: function(a, b) {\n+            for (var c = +b.length, d = 0, e = a.length; c > d; d++) a[e++] = b[d];\n+            return a.length = e, a\n+        },\n+        grep: function(a, b, c) {\n+            for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);\n+            return e\n+        },\n+        map: function(a, b, c) {\n+            var d, f = 0,\n+                g = a.length,\n+                h = s(a),\n+                i = [];\n+            if (h)\n+                for (; g > f; f++) d = b(a[f], f, c), null != d && i.push(d);\n+            else\n+                for (f in a) d = b(a[f], f, c), null != d && i.push(d);\n+            return e.apply([], i)\n+        },\n+        guid: 1,\n+        proxy: function(a, b) {\n+            var c, e, f;\n+            return \"string\" == typeof b && (c = a[b], b = a, a = c), o.isFunction(a) ? (e = d.call(arguments, 2), f = function() {\n+                return a.apply(b || this, e.concat(d.call(arguments)))\n+            }, f.guid = a.guid = a.guid || o.guid++, f) : void 0\n+        },\n+        now: Date.now,\n+        support: l\n+    }), o.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(a, b) {\n+        h[\"[object \" + b + \"]\"] = b.toLowerCase()\n+    });\n \n-\t\"use strict\";\n+    function s(a) {\n+        var b = a.length,\n+            c = o.type(a);\n+        return \"function\" === c || o.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : \"array\" === c || 0 === b || \"number\" == typeof b && b > 0 && b - 1 in a\n+    }\n+    var t = function(a) {\n+        var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s = \"sizzle\" + -new Date,\n+            t = a.document,\n+            u = 0,\n+            v = 0,\n+            w = eb(),\n+            x = eb(),\n+            y = eb(),\n+            z = function(a, b) {\n+                return a === b && (j = !0), 0\n+            },\n+            A = \"undefined\",\n+            B = 1 << 31,\n+            C = {}.hasOwnProperty,\n+            D = [],\n+            E = D.pop,\n+            F = D.push,\n+            G = D.push,\n+            H = D.slice,\n+            I = D.indexOf || function(a) {\n+                for (var b = 0, c = this.length; c > b; b++)\n+                    if (this[b] === a) return b;\n+                return -1\n+            },\n+            J = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n+            K = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n+            L = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n+            M = L.replace(\"w\", \"w#\"),\n+            N = \"\\\\[\" + K + \"*(\" + L + \")\" + K + \"*(?:([*^$|!~]?=)\" + K + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + M + \")|)|)\" + K + \"*\\\\]\",\n+            O = \":(\" + L + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + N.replace(3, 8) + \")*)|.*)\\\\)|)\",\n+            P = new RegExp(\"^\" + K + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + K + \"+$\", \"g\"),\n+            Q = new RegExp(\"^\" + K + \"*,\" + K + \"*\"),\n+            R = new RegExp(\"^\" + K + \"*([>+~]|\" + K + \")\" + K + \"*\"),\n+            S = new RegExp(\"=\" + K + \"*([^\\\\]'\\\"]*?)\" + K + \"*\\\\]\", \"g\"),\n+            T = new RegExp(O),\n+            U = new RegExp(\"^\" + M + \"$\"),\n+            V = {\n+                ID: new RegExp(\"^#(\" + L + \")\"),\n+                CLASS: new RegExp(\"^\\\\.(\" + L + \")\"),\n+                TAG: new RegExp(\"^(\" + L.replace(\"w\", \"w*\") + \")\"),\n+                ATTR: new RegExp(\"^\" + N),\n+                PSEUDO: new RegExp(\"^\" + O),\n+                CHILD: new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + K + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + K + \"*(?:([+-]|)\" + K + \"*(\\\\d+)|))\" + K + \"*\\\\)|)\", \"i\"),\n+                bool: new RegExp(\"^(?:\" + J + \")$\", \"i\"),\n+                needsContext: new RegExp(\"^\" + K + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + K + \"*((?:-\\\\d)?\\\\d*)\" + K + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n+            },\n+            W = /^(?:input|select|textarea|button)$/i,\n+            X = /^h\\d$/i,\n+            Y = /^[^{]+\\{\\s*\\[native \\w/,\n+            Z = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n+            $ = /[+~]/,\n+            _ = /'|\\\\/g,\n+            ab = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + K + \"?|(\" + K + \")|.)\", \"ig\"),\n+            bb = function(a, b, c) {\n+                var d = \"0x\" + b - 65536;\n+                return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)\n+            };\n+        try {\n+            G.apply(D = H.call(t.childNodes), t.childNodes), D[t.childNodes.length].nodeType\n+        } catch (cb) {\n+            G = {\n+                apply: D.length ? function(a, b) {\n+                    F.apply(a, H.call(b))\n+                } : function(a, b) {\n+                    var c = a.length,\n+                        d = 0;\n+                    while (a[c++] = b[d++]);\n+                    a.length = c - 1\n+                }\n+            }\n+        }\n \n-\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n+        function db(a, b, d, e) {\n+            var f, g, h, i, j, m, p, q, u, v;\n+            if ((b ? b.ownerDocument || b : t) !== l && k(b), b = b || l, d = d || [], !a || \"string\" != typeof a) return d;\n+            if (1 !== (i = b.nodeType) && 9 !== i) return [];\n+            if (n && !e) {\n+                if (f = Z.exec(a))\n+                    if (h = f[1]) {\n+                        if (9 === i) {\n+                            if (g = b.getElementById(h), !g || !g.parentNode) return d;\n+                            if (g.id === h) return d.push(g), d\n+                        } else if (b.ownerDocument && (g = b.ownerDocument.getElementById(h)) && r(b, g) && g.id === h) return d.push(g), d\n+                    } else {\n+                        if (f[2]) return G.apply(d, b.getElementsByTagName(a)), d;\n+                        if ((h = f[3]) && c.getElementsByClassName && b.getElementsByClassName) return G.apply(d, b.getElementsByClassName(h)), d\n+                    }\n+                if (c.qsa && (!o || !o.test(a))) {\n+                    if (q = p = s, u = b, v = 9 === i && a, 1 === i && \"object\" !== b.nodeName.toLowerCase()) {\n+                        m = ob(a), (p = b.getAttribute(\"id\")) ? q = p.replace(_, \"\\\\$&\") : b.setAttribute(\"id\", q), q = \"[id='\" + q + \"'] \", j = m.length;\n+                        while (j--) m[j] = q + pb(m[j]);\n+                        u = $.test(a) && mb(b.parentNode) || b, v = m.join(\",\")\n+                    }\n+                    if (v) try {\n+                        return G.apply(d, u.querySelectorAll(v)), d\n+                    } catch (w) {} finally {\n+                        p || b.removeAttribute(\"id\")\n+                    }\n+                }\n+            }\n+            return xb(a.replace(P, \"$1\"), b, d, e)\n+        }\n \n-\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n-\t\t// is present, execute the factory and get jQuery.\n-\t\t// For environments that do not have a `window` with a `document`\n-\t\t// (such as Node.js), expose a factory as module.exports.\n-\t\t// This accentuates the need for the creation of a real `window`.\n-\t\t// e.g. var jQuery = require(\"jquery\")(window);\n-\t\t// See ticket trac-14549 for more info.\n-\t\tmodule.exports = global.document ?\n-\t\t\tfactory( global, true ) :\n-\t\t\tfunction( w ) {\n-\t\t\t\tif ( !w.document ) {\n-\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n-\t\t\t\t}\n-\t\t\t\treturn factory( w );\n-\t\t\t};\n-\t} else {\n-\t\tfactory( global );\n-\t}\n+        function eb() {\n+            var a = [];\n \n-// Pass this if window is not defined yet\n-} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n+            function b(c, e) {\n+                return a.push(c + \" \") > d.cacheLength && delete b[a.shift()], b[c + \" \"] = e\n+            }\n+            return b\n+        }\n \n-// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n-// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n-// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n-// enough that all such attempts are guarded in a try block.\n-\"use strict\";\n+        function fb(a) {\n+            return a[s] = !0, a\n+        }\n \n-var arr = [];\n+        function gb(a) {\n+            var b = l.createElement(\"div\");\n+            try {\n+                return !!a(b)\n+            } catch (c) {\n+                return !1\n+            } finally {\n+                b.parentNode && b.parentNode.removeChild(b), b = null\n+            }\n+        }\n \n-var getProto = Object.getPrototypeOf;\n+        function hb(a, b) {\n+            var c = a.split(\"|\"),\n+                e = a.length;\n+            while (e--) d.attrHandle[c[e]] = b\n+        }\n \n-var slice = arr.slice;\n+        function ib(a, b) {\n+            var c = b && a,\n+                d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || B) - (~a.sourceIndex || B);\n+            if (d) return d;\n+            if (c)\n+                while (c = c.nextSibling)\n+                    if (c === b) return -1;\n+            return a ? 1 : -1\n+        }\n \n-var flat = arr.flat ? function( array ) {\n-\treturn arr.flat.call( array );\n-} : function( array ) {\n-\treturn arr.concat.apply( [], array );\n-};\n+        function jb(a) {\n+            return function(b) {\n+                var c = b.nodeName.toLowerCase();\n+                return \"input\" === c && b.type === a\n+            }\n+        }\n \n+        function kb(a) {\n+            return function(b) {\n+                var c = b.nodeName.toLowerCase();\n+                return (\"input\" === c || \"button\" === c) && b.type === a\n+            }\n+        }\n \n-var push = arr.push;\n+        function lb(a) {\n+            return fb(function(b) {\n+                return b = +b, fb(function(c, d) {\n+                    var e, f = a([], c.length, b),\n+                        g = f.length;\n+                    while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e]))\n+                })\n+            })\n+        }\n \n-var indexOf = arr.indexOf;\n+        function mb(a) {\n+            return a && typeof a.getElementsByTagName !== A && a\n+        }\n+        c = db.support = {}, f = db.isXML = function(a) {\n+            var b = a && (a.ownerDocument || a).documentElement;\n+            return b ? \"HTML\" !== b.nodeName : !1\n+        }, k = db.setDocument = function(a) {\n+            var b, e = a ? a.ownerDocument || a : t,\n+                g = e.defaultView;\n+            return e !== l && 9 === e.nodeType && e.documentElement ? (l = e, m = e.documentElement, n = !f(e), g && g !== g.top && (g.addEventListener ? g.addEventListener(\"unload\", function() {\n+                k()\n+            }, !1) : g.attachEvent && g.attachEvent(\"onunload\", function() {\n+                k()\n+            })), c.attributes = gb(function(a) {\n+                return a.className = \"i\", !a.getAttribute(\"className\")\n+            }), c.getElementsByTagName = gb(function(a) {\n+                return a.appendChild(e.createComment(\"\")), !a.getElementsByTagName(\"*\").length\n+            }), c.getElementsByClassName = Y.test(e.getElementsByClassName) && gb(function(a) {\n+                return a.innerHTML = \"<div class='a'></div><div class='a i'></div>\", a.firstChild.className = \"i\", 2 === a.getElementsByClassName(\"i\").length\n+            }), c.getById = gb(function(a) {\n+                return m.appendChild(a).id = s, !e.getElementsByName || !e.getElementsByName(s).length\n+            }), c.getById ? (d.find.ID = function(a, b) {\n+                if (typeof b.getElementById !== A && n) {\n+                    var c = b.getElementById(a);\n+                    return c && c.parentNode ? [c] : []\n+                }\n+            }, d.filter.ID = function(a) {\n+                var b = a.replace(ab, bb);\n+                return function(a) {\n+                    return a.getAttribute(\"id\") === b\n+                }\n+            }) : (delete d.find.ID, d.filter.ID = function(a) {\n+                var b = a.replace(ab, bb);\n+                return function(a) {\n+                    var c = typeof a.getAttributeNode !== A && a.getAttributeNode(\"id\");\n+                    return c && c.value === b\n+                }\n+            }), d.find.TAG = c.getElementsByTagName ? function(a, b) {\n+                return typeof b.getElementsByTagName !== A ? b.getElementsByTagName(a) : void 0\n+            } : function(a, b) {\n+                var c, d = [],\n+                    e = 0,\n+                    f = b.getElementsByTagName(a);\n+                if (\"*\" === a) {\n+                    while (c = f[e++]) 1 === c.nodeType && d.push(c);\n+                    return d\n+                }\n+                return f\n+            }, d.find.CLASS = c.getElementsByClassName && function(a, b) {\n+                return typeof b.getElementsByClassName !== A && n ? b.getElementsByClassName(a) : void 0\n+            }, p = [], o = [], (c.qsa = Y.test(e.querySelectorAll)) && (gb(function(a) {\n+                a.innerHTML = \"<select t=''><option selected=''></option></select>\", a.querySelectorAll(\"[t^='']\").length && o.push(\"[*^$]=\" + K + \"*(?:''|\\\"\\\")\"), a.querySelectorAll(\"[selected]\").length || o.push(\"\\\\[\" + K + \"*(?:value|\" + J + \")\"), a.querySelectorAll(\":checked\").length || o.push(\":checked\")\n+            }), gb(function(a) {\n+                var b = e.createElement(\"input\");\n+                b.setAttribute(\"type\", \"hidden\"), a.appendChild(b).setAttribute(\"name\", \"D\"), a.querySelectorAll(\"[name=d]\").length && o.push(\"name\" + K + \"*[*^$|!~]?=\"), a.querySelectorAll(\":enabled\").length || o.push(\":enabled\", \":disabled\"), a.querySelectorAll(\"*,:x\"), o.push(\",.*:\")\n+            })), (c.matchesSelector = Y.test(q = m.webkitMatchesSelector || m.mozMatchesSelector || m.oMatchesSelector || m.msMatchesSelector)) && gb(function(a) {\n+                c.disconnectedMatch = q.call(a, \"div\"), q.call(a, \"[s!='']:x\"), p.push(\"!=\", O)\n+            }), o = o.length && new RegExp(o.join(\"|\")), p = p.length && new RegExp(p.join(\"|\")), b = Y.test(m.compareDocumentPosition), r = b || Y.test(m.contains) ? function(a, b) {\n+                var c = 9 === a.nodeType ? a.documentElement : a,\n+                    d = b && b.parentNode;\n+                return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))\n+            } : function(a, b) {\n+                if (b)\n+                    while (b = b.parentNode)\n+                        if (b === a) return !0;\n+                return !1\n+            }, z = b ? function(a, b) {\n+                if (a === b) return j = !0, 0;\n+                var d = !a.compareDocumentPosition - !b.compareDocumentPosition;\n+                return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === e || a.ownerDocument === t && r(t, a) ? -1 : b === e || b.ownerDocument === t && r(t, b) ? 1 : i ? I.call(i, a) - I.call(i, b) : 0 : 4 & d ? -1 : 1)\n+            } : function(a, b) {\n+                if (a === b) return j = !0, 0;\n+                var c, d = 0,\n+                    f = a.parentNode,\n+                    g = b.parentNode,\n+                    h = [a],\n+                    k = [b];\n+                if (!f || !g) return a === e ? -1 : b === e ? 1 : f ? -1 : g ? 1 : i ? I.call(i, a) - I.call(i, b) : 0;\n+                if (f === g) return ib(a, b);\n+                c = a;\n+                while (c = c.parentNode) h.unshift(c);\n+                c = b;\n+                while (c = c.parentNode) k.unshift(c);\n+                while (h[d] === k[d]) d++;\n+                return d ? ib(h[d], k[d]) : h[d] === t ? -1 : k[d] === t ? 1 : 0\n+            }, e) : l\n+        }, db.matches = function(a, b) {\n+            return db(a, null, null, b)\n+        }, db.matchesSelector = function(a, b) {\n+            if ((a.ownerDocument || a) !== l && k(a), b = b.replace(S, \"='$1']\"), !(!c.matchesSelector || !n || p && p.test(b) || o && o.test(b))) try {\n+                var d = q.call(a, b);\n+                if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d\n+            } catch (e) {}\n+            return db(b, l, null, [a]).length > 0\n+        }, db.contains = function(a, b) {\n+            return (a.ownerDocument || a) !== l && k(a), r(a, b)\n+        }, db.attr = function(a, b) {\n+            (a.ownerDocument || a) !== l && k(a);\n+            var e = d.attrHandle[b.toLowerCase()],\n+                f = e && C.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !n) : void 0;\n+            return void 0 !== f ? f : c.attributes || !n ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null\n+        }, db.error = function(a) {\n+            throw new Error(\"Syntax error, unrecognized expression: \" + a)\n+        }, db.uniqueSort = function(a) {\n+            var b, d = [],\n+                e = 0,\n+                f = 0;\n+            if (j = !c.detectDuplicates, i = !c.sortStable && a.slice(0), a.sort(z), j) {\n+                while (b = a[f++]) b === a[f] && (e = d.push(f));\n+                while (e--) a.splice(d[e], 1)\n+            }\n+            return i = null, a\n+        }, e = db.getText = function(a) {\n+            var b, c = \"\",\n+                d = 0,\n+                f = a.nodeType;\n+            if (f) {\n+                if (1 === f || 9 === f || 11 === f) {\n+                    if (\"string\" == typeof a.textContent) return a.textContent;\n+                    for (a = a.firstChild; a; a = a.nextSibling) c += e(a)\n+                } else if (3 === f || 4 === f) return a.nodeValue\n+            } else\n+                while (b = a[d++]) c += e(b);\n+            return c\n+        }, d = db.selectors = {\n+            cacheLength: 50,\n+            createPseudo: fb,\n+            match: V,\n+            attrHandle: {},\n+            find: {},\n+            relative: {\n+                \">\": {\n+                    dir: \"parentNode\",\n+                    first: !0\n+                },\n+                \" \": {\n+                    dir: \"parentNode\"\n+                },\n+                \"+\": {\n+                    dir: \"previousSibling\",\n+                    first: !0\n+                },\n+                \"~\": {\n+                    dir: \"previousSibling\"\n+                }\n+            },\n+            preFilter: {\n+                ATTR: function(a) {\n+                    return a[1] = a[1].replace(ab, bb), a[3] = (a[4] || a[5] || \"\").replace(ab, bb), \"~=\" === a[2] && (a[3] = \" \" + a[3] + \" \"), a.slice(0, 4)\n+                },\n+                CHILD: function(a) {\n+                    return a[1] = a[1].toLowerCase(), \"nth\" === a[1].slice(0, 3) ? (a[3] || db.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * (\"even\" === a[3] || \"odd\" === a[3])), a[5] = +(a[7] + a[8] || \"odd\" === a[3])) : a[3] && db.error(a[0]), a\n+                },\n+                PSEUDO: function(a) {\n+                    var b, c = !a[5] && a[2];\n+                    return V.CHILD.test(a[0]) ? null : (a[3] && void 0 !== a[4] ? a[2] = a[4] : c && T.test(c) && (b = ob(c, !0)) && (b = c.indexOf(\")\", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))\n+                }\n+            },\n+            filter: {\n+                TAG: function(a) {\n+                    var b = a.replace(ab, bb).toLowerCase();\n+                    return \"*\" === a ? function() {\n+                        return !0\n+                    } : function(a) {\n+                        return a.nodeName && a.nodeName.toLowerCase() === b\n+                    }\n+                },\n+                CLASS: function(a) {\n+                    var b = w[a + \" \"];\n+                    return b || (b = new RegExp(\"(^|\" + K + \")\" + a + \"(\" + K + \"|$)\")) && w(a, function(a) {\n+                        return b.test(\"string\" == typeof a.className && a.className || typeof a.getAttribute !== A && a.getAttribute(\"class\") || \"\")\n+                    })\n+                },\n+                ATTR: function(a, b, c) {\n+                    return function(d) {\n+                        var e = db.attr(d, a);\n+                        return null == e ? \"!=\" === b : b ? (e += \"\", \"=\" === b ? e === c : \"!=\" === b ? e !== c : \"^=\" === b ? c && 0 === e.indexOf(c) : \"*=\" === b ? c && e.indexOf(c) > -1 : \"$=\" === b ? c && e.slice(-c.length) === c : \"~=\" === b ? (\" \" + e + \" \").indexOf(c) > -1 : \"|=\" === b ? e === c || e.slice(0, c.length + 1) === c + \"-\" : !1) : !0\n+                    }\n+                },\n+                CHILD: function(a, b, c, d, e) {\n+                    var f = \"nth\" !== a.slice(0, 3),\n+                        g = \"last\" !== a.slice(-4),\n+                        h = \"of-type\" === b;\n+                    return 1 === d && 0 === e ? function(a) {\n+                        return !!a.parentNode\n+                    } : function(b, c, i) {\n+                        var j, k, l, m, n, o, p = f !== g ? \"nextSibling\" : \"previousSibling\",\n+                            q = b.parentNode,\n+                            r = h && b.nodeName.toLowerCase(),\n+                            t = !i && !h;\n+                        if (q) {\n+                            if (f) {\n+                                while (p) {\n+                                    l = b;\n+                                    while (l = l[p])\n+                                        if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;\n+                                    o = p = \"only\" === a && !o && \"nextSibling\"\n+                                }\n+                                return !0\n+                            }\n+                            if (o = [g ? q.firstChild : q.lastChild], g && t) {\n+                                k = q[s] || (q[s] = {}), j = k[a] || [], n = j[0] === u && j[1], m = j[0] === u && j[2], l = n && q.childNodes[n];\n+                                while (l = ++n && l && l[p] || (m = n = 0) || o.pop())\n+                                    if (1 === l.nodeType && ++m && l === b) {\n+                                        k[a] = [u, n, m];\n+                                        break\n+                                    }\n+                            } else if (t && (j = (b[s] || (b[s] = {}))[a]) && j[0] === u) m = j[1];\n+                            else\n+                                while (l = ++n && l && l[p] || (m = n = 0) || o.pop())\n+                                    if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) && ++m && (t && ((l[s] || (l[s] = {}))[a] = [u, m]), l === b)) break;\n+                            return m -= e, m === d || m % d === 0 && m / d >= 0\n+                        }\n+                    }\n+                },\n+                PSEUDO: function(a, b) {\n+                    var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || db.error(\"unsupported pseudo: \" + a);\n+                    return e[s] ? e(b) : e.length > 1 ? (c = [a, a, \"\", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? fb(function(a, c) {\n+                        var d, f = e(a, b),\n+                            g = f.length;\n+                        while (g--) d = I.call(a, f[g]), a[d] = !(c[d] = f[g])\n+                    }) : function(a) {\n+                        return e(a, 0, c)\n+                    }) : e\n+                }\n+            },\n+            pseudos: {\n+                not: fb(function(a) {\n+                    var b = [],\n+                        c = [],\n+                        d = g(a.replace(P, \"$1\"));\n+                    return d[s] ? fb(function(a, b, c, e) {\n+                        var f, g = d(a, null, e, []),\n+                            h = a.length;\n+                        while (h--)(f = g[h]) && (a[h] = !(b[h] = f))\n+                    }) : function(a, e, f) {\n+                        return b[0] = a, d(b, null, f, c), !c.pop()\n+                    }\n+                }),\n+                has: fb(function(a) {\n+                    return function(b) {\n+                        return db(a, b).length > 0\n+                    }\n+                }),\n+                contains: fb(function(a) {\n+                    return function(b) {\n+                        return (b.textContent || b.innerText || e(b)).indexOf(a) > -1\n+                    }\n+                }),\n+                lang: fb(function(a) {\n+                    return U.test(a || \"\") || db.error(\"unsupported lang: \" + a), a = a.replace(ab, bb).toLowerCase(),\n+                        function(b) {\n+                            var c;\n+                            do\n+                                if (c = n ? b.lang : b.getAttribute(\"xml:lang\") || b.getAttribute(\"lang\")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + \"-\"); while ((b = b.parentNode) && 1 === b.nodeType);\n+                            return !1\n+                        }\n+                }),\n+                target: function(b) {\n+                    var c = a.location && a.location.hash;\n+                    return c && c.slice(1) === b.id\n+                },\n+                root: function(a) {\n+                    return a === m\n+                },\n+                focus: function(a) {\n+                    return a === l.activeElement && (!l.hasFocus || l.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)\n+                },\n+                enabled: function(a) {\n+                    return a.disabled === !1\n+                },\n+                disabled: function(a) {\n+                    return a.disabled === !0\n+                },\n+                checked: function(a) {\n+                    var b = a.nodeName.toLowerCase();\n+                    return \"input\" === b && !!a.checked || \"option\" === b && !!a.selected\n+                },\n+                selected: function(a) {\n+                    return a.parentNode && a.parentNode.selectedIndex, a.selected === !0\n+                },\n+                empty: function(a) {\n+                    for (a = a.firstChild; a; a = a.nextSibling)\n+                        if (a.nodeType < 6) return !1;\n+                    return !0\n+                },\n+                parent: function(a) {\n+                    return !d.pseudos.empty(a)\n+                },\n+                header: function(a) {\n+                    return X.test(a.nodeName)\n+                },\n+                input: function(a) {\n+                    return W.test(a.nodeName)\n+                },\n+                button: function(a) {\n+                    var b = a.nodeName.toLowerCase();\n+                    return \"input\" === b && \"button\" === a.type || \"button\" === b\n+                },\n+                text: function(a) {\n+                    var b;\n+                    return \"input\" === a.nodeName.toLowerCase() && \"text\" === a.type && (null == (b = a.getAttribute(\"type\")) || \"text\" === b.toLowerCase())\n+                },\n+                first: lb(function() {\n+                    return [0]\n+                }),\n+                last: lb(function(a, b) {\n+                    return [b - 1]\n+                }),\n+                eq: lb(function(a, b, c) {\n+                    return [0 > c ? c + b : c]\n+                }),\n+                even: lb(function(a, b) {\n+                    for (var c = 0; b > c; c += 2) a.push(c);\n+                    return a\n+                }),\n+                odd: lb(function(a, b) {\n+                    for (var c = 1; b > c; c += 2) a.push(c);\n+                    return a\n+                }),\n+                lt: lb(function(a, b, c) {\n+                    for (var d = 0 > c ? c + b : c; --d >= 0;) a.push(d);\n+                    return a\n+                }),\n+                gt: lb(function(a, b, c) {\n+                    for (var d = 0 > c ? c + b : c; ++d < b;) a.push(d);\n+                    return a\n+                })\n+            }\n+        }, d.pseudos.nth = d.pseudos.eq;\n+        for (b in {\n+                radio: !0,\n+                checkbox: !0,\n+                file: !0,\n+                password: !0,\n+                image: !0\n+            }) d.pseudos[b] = jb(b);\n+        for (b in {\n+                submit: !0,\n+                reset: !0\n+            }) d.pseudos[b] = kb(b);\n \n-var class2type = {};\n+        function nb() {}\n+        nb.prototype = d.filters = d.pseudos, d.setFilters = new nb;\n \n-var toString = class2type.toString;\n+        function ob(a, b) {\n+            var c, e, f, g, h, i, j, k = x[a + \" \"];\n+            if (k) return b ? 0 : k.slice(0);\n+            h = a, i = [], j = d.preFilter;\n+            while (h) {\n+                (!c || (e = Q.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = R.exec(h)) && (c = e.shift(), f.push({\n+                    value: c,\n+                    type: e[0].replace(P, \" \")\n+                }), h = h.slice(c.length));\n+                for (g in d.filter) !(e = V[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({\n+                    value: c,\n+                    type: g,\n+                    matches: e\n+                }), h = h.slice(c.length));\n+                if (!c) break\n+            }\n+            return b ? h.length : h ? db.error(a) : x(a, i).slice(0)\n+        }\n \n-var hasOwn = class2type.hasOwnProperty;\n+        function pb(a) {\n+            for (var b = 0, c = a.length, d = \"\"; c > b; b++) d += a[b].value;\n+            return d\n+        }\n \n-var fnToString = hasOwn.toString;\n+        function qb(a, b, c) {\n+            var d = b.dir,\n+                e = c && \"parentNode\" === d,\n+                f = v++;\n+            return b.first ? function(b, c, f) {\n+                while (b = b[d])\n+                    if (1 === b.nodeType || e) return a(b, c, f)\n+            } : function(b, c, g) {\n+                var h, i, j = [u, f];\n+                if (g) {\n+                    while (b = b[d])\n+                        if ((1 === b.nodeType || e) && a(b, c, g)) return !0\n+                } else\n+                    while (b = b[d])\n+                        if (1 === b.nodeType || e) {\n+                            if (i = b[s] || (b[s] = {}), (h = i[d]) && h[0] === u && h[1] === f) return j[2] = h[2];\n+                            if (i[d] = j, j[2] = a(b, c, g)) return !0\n+                        }\n+            }\n+        }\n \n-var ObjectFunctionString = fnToString.call( Object );\n+        function rb(a) {\n+            return a.length > 1 ? function(b, c, d) {\n+                var e = a.length;\n+                while (e--)\n+                    if (!a[e](b, c, d)) return !1;\n+                return !0\n+            } : a[0]\n+        }\n \n-var support = {};\n+        function sb(a, b, c, d, e) {\n+            for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)(f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h));\n+            return g\n+        }\n \n-var isFunction = function isFunction( obj ) {\n+        function tb(a, b, c, d, e, f) {\n+            return d && !d[s] && (d = tb(d)), e && !e[s] && (e = tb(e, f)), fb(function(f, g, h, i) {\n+                var j, k, l, m = [],\n+                    n = [],\n+                    o = g.length,\n+                    p = f || wb(b || \"*\", h.nodeType ? [h] : h, []),\n+                    q = !a || !f && b ? p : sb(p, m, a, h, i),\n+                    r = c ? e || (f ? a : o || d) ? [] : g : q;\n+                if (c && c(q, r, h, i), d) {\n+                    j = sb(r, n), d(j, [], h, i), k = j.length;\n+                    while (k--)(l = j[k]) && (r[n[k]] = !(q[n[k]] = l))\n+                }\n+                if (f) {\n+                    if (e || a) {\n+                        if (e) {\n+                            j = [], k = r.length;\n+                            while (k--)(l = r[k]) && j.push(q[k] = l);\n+                            e(null, r = [], j, i)\n+                        }\n+                        k = r.length;\n+                        while (k--)(l = r[k]) && (j = e ? I.call(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l))\n+                    }\n+                } else r = sb(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : G.apply(g, r)\n+            })\n+        }\n \n-\t\t// Support: Chrome <=57, Firefox <=52\n-\t\t// In some browsers, typeof returns \"function\" for HTML <object> elements\n-\t\t// (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n-\t\t// We don't want to classify *any* DOM node as a function.\n-\t\t// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n-\t\t// Plus for old WebKit, typeof returns \"function\" for HTML collections\n-\t\t// (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\n-\t\treturn typeof obj === \"function\" && typeof obj.nodeType !== \"number\" &&\n-\t\t\ttypeof obj.item !== \"function\";\n-\t};\n+        function ub(a) {\n+            for (var b, c, e, f = a.length, g = d.relative[a[0].type], i = g || d.relative[\" \"], j = g ? 1 : 0, k = qb(function(a) {\n+                    return a === b\n+                }, i, !0), l = qb(function(a) {\n+                    return I.call(b, a) > -1\n+                }, i, !0), m = [function(a, c, d) {\n+                    return !g && (d || c !== h) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d))\n+                }]; f > j; j++)\n+                if (c = d.relative[a[j].type]) m = [qb(rb(m), c)];\n+                else {\n+                    if (c = d.filter[a[j].type].apply(null, a[j].matches), c[s]) {\n+                        for (e = ++j; f > e; e++)\n+                            if (d.relative[a[e].type]) break;\n+                        return tb(j > 1 && rb(m), j > 1 && pb(a.slice(0, j - 1).concat({\n+                            value: \" \" === a[j - 2].type ? \"*\" : \"\"\n+                        })).replace(P, \"$1\"), c, e > j && ub(a.slice(j, e)), f > e && ub(a = a.slice(e)), f > e && pb(a))\n+                    }\n+                    m.push(c)\n+                }\n+            return rb(m)\n+        }\n \n+        function vb(a, b) {\n+            var c = b.length > 0,\n+                e = a.length > 0,\n+                f = function(f, g, i, j, k) {\n+                    var m, n, o, p = 0,\n+                        q = \"0\",\n+                        r = f && [],\n+                        s = [],\n+                        t = h,\n+                        v = f || e && d.find.TAG(\"*\", k),\n+                        w = u += null == t ? 1 : Math.random() || .1,\n+                        x = v.length;\n+                    for (k && (h = g !== l && g); q !== x && null != (m = v[q]); q++) {\n+                        if (e && m) {\n+                            n = 0;\n+                            while (o = a[n++])\n+                                if (o(m, g, i)) {\n+                                    j.push(m);\n+                                    break\n+                                }\n+                            k && (u = w)\n+                        }\n+                        c && ((m = !o && m) && p--, f && r.push(m))\n+                    }\n+                    if (p += q, c && q !== p) {\n+                        n = 0;\n+                        while (o = b[n++]) o(r, s, g, i);\n+                        if (f) {\n+                            if (p > 0)\n+                                while (q--) r[q] || s[q] || (s[q] = E.call(j));\n+                            s = sb(s)\n+                        }\n+                        G.apply(j, s), k && !f && s.length > 0 && p + b.length > 1 && db.uniqueSort(j)\n+                    }\n+                    return k && (u = w, h = t), r\n+                };\n+            return c ? fb(f) : f\n+        }\n+        g = db.compile = function(a, b) {\n+            var c, d = [],\n+                e = [],\n+                f = y[a + \" \"];\n+            if (!f) {\n+                b || (b = ob(a)), c = b.length;\n+                while (c--) f = ub(b[c]), f[s] ? d.push(f) : e.push(f);\n+                f = y(a, vb(e, d))\n+            }\n+            return f\n+        };\n \n-var isWindow = function isWindow( obj ) {\n-\t\treturn obj != null && obj === obj.window;\n-\t};\n+        function wb(a, b, c) {\n+            for (var d = 0, e = b.length; e > d; d++) db(a, b[d], c);\n+            return c\n+        }\n \n+        function xb(a, b, e, f) {\n+            var h, i, j, k, l, m = ob(a);\n+            if (!f && 1 === m.length) {\n+                if (i = m[0] = m[0].slice(0), i.length > 2 && \"ID\" === (j = i[0]).type && c.getById && 9 === b.nodeType && n && d.relative[i[1].type]) {\n+                    if (b = (d.find.ID(j.matches[0].replace(ab, bb), b) || [])[0], !b) return e;\n+                    a = a.slice(i.shift().value.length)\n+                }\n+                h = V.needsContext.test(a) ? 0 : i.length;\n+                while (h--) {\n+                    if (j = i[h], d.relative[k = j.type]) break;\n+                    if ((l = d.find[k]) && (f = l(j.matches[0].replace(ab, bb), $.test(i[0].type) && mb(b.parentNode) || b))) {\n+                        if (i.splice(h, 1), a = f.length && pb(i), !a) return G.apply(e, f), e;\n+                        break\n+                    }\n+                }\n+            }\n+            return g(a, m)(f, b, !n, e, $.test(a) && mb(b.parentNode) || b), e\n+        }\n+        return c.sortStable = s.split(\"\").sort(z).join(\"\") === s, c.detectDuplicates = !!j, k(), c.sortDetached = gb(function(a) {\n+            return 1 & a.compareDocumentPosition(l.createElement(\"div\"))\n+        }), gb(function(a) {\n+            return a.innerHTML = \"<a href='#'></a>\", \"#\" === a.firstChild.getAttribute(\"href\")\n+        }) || hb(\"type|href|height|width\", function(a, b, c) {\n+            return c ? void 0 : a.getAttribute(b, \"type\" === b.toLowerCase() ? 1 : 2)\n+        }), c.attributes && gb(function(a) {\n+            return a.innerHTML = \"<input/>\", a.firstChild.setAttribute(\"value\", \"\"), \"\" === a.firstChild.getAttribute(\"value\")\n+        }) || hb(\"value\", function(a, b, c) {\n+            return c || \"input\" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue\n+        }), gb(function(a) {\n+            return null == a.getAttribute(\"disabled\")\n+        }) || hb(J, function(a, b, c) {\n+            var d;\n+            return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null\n+        }), db\n+    }(a);\n+    o.find = t, o.expr = t.selectors, o.expr[\":\"] = o.expr.pseudos, o.unique = t.uniqueSort, o.text = t.getText, o.isXMLDoc = t.isXML, o.contains = t.contains;\n+    var u = o.expr.match.needsContext,\n+        v = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n+        w = /^.[^:#\\[\\.,]*$/;\n \n-var document = window.document;\n+    function x(a, b, c) {\n+        if (o.isFunction(b)) return o.grep(a, function(a, d) {\n+            return !!b.call(a, d, a) !== c\n+        });\n+        if (b.nodeType) return o.grep(a, function(a) {\n+            return a === b !== c\n+        });\n+        if (\"string\" == typeof b) {\n+            if (w.test(b)) return o.filter(b, a, c);\n+            b = o.filter(b, a)\n+        }\n+        return o.grep(a, function(a) {\n+            return g.call(b, a) >= 0 !== c\n+        })\n+    }\n+    o.filter = function(a, b, c) {\n+        var d = b[0];\n+        return c && (a = \":not(\" + a + \")\"), 1 === b.length && 1 === d.nodeType ? o.find.matchesSelector(d, a) ? [d] : [] : o.find.matches(a, o.grep(b, function(a) {\n+            return 1 === a.nodeType\n+        }))\n+    }, o.fn.extend({\n+        find: function(a) {\n+            var b, c = this.length,\n+                d = [],\n+                e = this;\n+            if (\"string\" != typeof a) return this.pushStack(o(a).filter(function() {\n+                for (b = 0; c > b; b++)\n+                    if (o.contains(e[b], this)) return !0\n+            }));\n+            for (b = 0; c > b; b++) o.find(a, e[b], d);\n+            return d = this.pushStack(c > 1 ? o.unique(d) : d), d.selector = this.selector ? this.selector + \" \" + a : a, d\n+        },\n+        filter: function(a) {\n+            return this.pushStack(x(this, a || [], !1))\n+        },\n+        not: function(a) {\n+            return this.pushStack(x(this, a || [], !0))\n+        },\n+        is: function(a) {\n+            return !!x(this, \"string\" == typeof a && u.test(a) ? o(a) : a || [], !1).length\n+        }\n+    });\n+    var y, z = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n+        A = o.fn.init = function(a, b) {\n+            var c, d;\n+            if (!a) return this;\n+            if (\"string\" == typeof a) {\n+                if (c = \"<\" === a[0] && \">\" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : z.exec(a), !c || !c[1] && b) return !b || b.jquery ? (b || y).find(a) : this.constructor(b).find(a);\n+                if (c[1]) {\n+                    if (b = b instanceof o ? b[0] : b, o.merge(this, o.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : m, !0)), v.test(c[1]) && o.isPlainObject(b))\n+                        for (c in b) o.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);\n+                    return this\n+                }\n+                return d = m.getElementById(c[2]), d && d.parentNode && (this.length = 1, this[0] = d), this.context = m, this.selector = a, this\n+            }\n+            return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : o.isFunction(a) ? \"undefined\" != typeof y.ready ? y.ready(a) : a(o) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), o.makeArray(a, this))\n+        };\n+    A.prototype = o.fn, y = o(m);\n+    var B = /^(?:parents|prev(?:Until|All))/,\n+        C = {\n+            children: !0,\n+            contents: !0,\n+            next: !0,\n+            prev: !0\n+        };\n+    o.extend({\n+        dir: function(a, b, c) {\n+            var d = [],\n+                e = void 0 !== c;\n+            while ((a = a[b]) && 9 !== a.nodeType)\n+                if (1 === a.nodeType) {\n+                    if (e && o(a).is(c)) break;\n+                    d.push(a)\n+                }\n+            return d\n+        },\n+        sibling: function(a, b) {\n+            for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);\n+            return c\n+        }\n+    }), o.fn.extend({\n+        has: function(a) {\n+            var b = o(a, this),\n+                c = b.length;\n+            return this.filter(function() {\n+                for (var a = 0; c > a; a++)\n+                    if (o.contains(this, b[a])) return !0\n+            })\n+        },\n+        closest: function(a, b) {\n+            for (var c, d = 0, e = this.length, f = [], g = u.test(a) || \"string\" != typeof a ? o(a, b || this.context) : 0; e > d; d++)\n+                for (c = this[d]; c && c !== b; c = c.parentNode)\n+                    if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && o.find.matchesSelector(c, a))) {\n+                        f.push(c);\n+                        break\n+                    }\n+            return this.pushStack(f.length > 1 ? o.unique(f) : f)\n+        },\n+        index: function(a) {\n+            return a ? \"string\" == typeof a ? g.call(o(a), this[0]) : g.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1\n+        },\n+        add: function(a, b) {\n+            return this.pushStack(o.unique(o.merge(this.get(), o(a, b))))\n+        },\n+        addBack: function(a) {\n+            return this.add(null == a ? this.prevObject : this.prevObject.filter(a))\n+        }\n+    });\n \n+    function D(a, b) {\n+        while ((a = a[b]) && 1 !== a.nodeType);\n+        return a\n+    }\n+    o.each({\n+        parent: function(a) {\n+            var b = a.parentNode;\n+            return b && 11 !== b.nodeType ? b : null\n+        },\n+        parents: function(a) {\n+            return o.dir(a, \"parentNode\")\n+        },\n+        parentsUntil: function(a, b, c) {\n+            return o.dir(a, \"parentNode\", c)\n+        },\n+        next: function(a) {\n+            return D(a, \"nextSibling\")\n+        },\n+        prev: function(a) {\n+            return D(a, \"previousSibling\")\n+        },\n+        nextAll: function(a) {\n+            return o.dir(a, \"nextSibling\")\n+        },\n+        prevAll: function(a) {\n+            return o.dir(a, \"previousSibling\")\n+        },\n+        nextUntil: function(a, b, c) {\n+            return o.dir(a, \"nextSibling\", c)\n+        },\n+        prevUntil: function(a, b, c) {\n+            return o.dir(a, \"previousSibling\", c)\n+        },\n+        siblings: function(a) {\n+            return o.sibling((a.parentNode || {}).firstChild, a)\n+        },\n+        children: function(a) {\n+            return o.sibling(a.firstChild)\n+        },\n+        contents: function(a) {\n+            return a.contentDocument || o.merge([], a.childNodes)\n+        }\n+    }, function(a, b) {\n+        o.fn[a] = function(c, d) {\n+            var e = o.map(this, b, c);\n+            return \"Until\" !== a.slice(-5) && (d = c), d && \"string\" == typeof d && (e = o.filter(d, e)), this.length > 1 && (C[a] || o.unique(e), B.test(a) && e.reverse()), this.pushStack(e)\n+        }\n+    });\n+    var E = /\\S+/g,\n+        F = {};\n \n+    function G(a) {\n+        var b = F[a] = {};\n+        return o.each(a.match(E) || [], function(a, c) {\n+            b[c] = !0\n+        }), b\n+    }\n+    o.Callbacks = function(a) {\n+        a = \"string\" == typeof a ? F[a] || G(a) : o.extend({}, a);\n+        var b, c, d, e, f, g, h = [],\n+            i = !a.once && [],\n+            j = function(l) {\n+                for (b = a.memory && l, c = !0, g = e || 0, e = 0, f = h.length, d = !0; h && f > g; g++)\n+                    if (h[g].apply(l[0], l[1]) === !1 && a.stopOnFalse) {\n+                        b = !1;\n+                        break\n+                    }\n+                d = !1, h && (i ? i.length && j(i.shift()) : b ? h = [] : k.disable())\n+            },\n+            k = {\n+                add: function() {\n+                    if (h) {\n+                        var c = h.length;\n+                        ! function g(b) {\n+                            o.each(b, function(b, c) {\n+                                var d = o.type(c);\n+                                \"function\" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && \"string\" !== d && g(c)\n+                            })\n+                        }(arguments), d ? f = h.length : b && (e = c, j(b))\n+                    }\n+                    return this\n+                },\n+                remove: function() {\n+                    return h && o.each(arguments, function(a, b) {\n+                        var c;\n+                        while ((c = o.inArray(b, h, c)) > -1) h.splice(c, 1), d && (f >= c && f--, g >= c && g--)\n+                    }), this\n+                },\n+                has: function(a) {\n+                    return a ? o.inArray(a, h) > -1 : !(!h || !h.length)\n+                },\n+                empty: function() {\n+                    return h = [], f = 0, this\n+                },\n+                disable: function() {\n+                    return h = i = b = void 0, this\n+                },\n+                disabled: function() {\n+                    return !h\n+                },\n+                lock: function() {\n+                    return i = void 0, b || k.disable(), this\n+                },\n+                locked: function() {\n+                    return !i\n+                },\n+                fireWith: function(a, b) {\n+                    return !h || c && !i || (b = b || [], b = [a, b.slice ? b.slice() : b], d ? i.push(b) : j(b)), this\n+                },\n+                fire: function() {\n+                    return k.fireWith(this, arguments), this\n+                },\n+                fired: function() {\n+                    return !!c\n+                }\n+            };\n+        return k\n+    }, o.extend({\n+        Deferred: function(a) {\n+            var b = [\n+                    [\"resolve\", \"done\", o.Callbacks(\"once memory\"), \"resolved\"],\n+                    [\"reject\", \"fail\", o.Callbacks(\"once memory\"), \"rejected\"],\n+                    [\"notify\", \"progress\", o.Callbacks(\"memory\")]\n+                ],\n+                c = \"pending\",\n+                d = {\n+                    state: function() {\n+                        return c\n+                    },\n+                    always: function() {\n+                        return e.done(arguments).fail(arguments), this\n+                    },\n+                    then: function() {\n+                        var a = arguments;\n+                        return o.Deferred(function(c) {\n+                            o.each(b, function(b, f) {\n+                                var g = o.isFunction(a[b]) && a[b];\n+                                e[f[1]](function() {\n+                                    var a = g && g.apply(this, arguments);\n+                                    a && o.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + \"With\"](this === d ? c.promise() : this, g ? [a] : arguments)\n+                                })\n+                            }), a = null\n+                        }).promise()\n+                    },\n+                    promise: function(a) {\n+                        return null != a ? o.extend(a, d) : d\n+                    }\n+                },\n+                e = {};\n+            return d.pipe = d.then, o.each(b, function(a, f) {\n+                var g = f[2],\n+                    h = f[3];\n+                d[f[1]] = g.add, h && g.add(function() {\n+                    c = h\n+                }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {\n+                    return e[f[0] + \"With\"](this === e ? d : this, arguments), this\n+                }, e[f[0] + \"With\"] = g.fireWith\n+            }), d.promise(e), a && a.call(e, e), e\n+        },\n+        when: function(a) {\n+            var b = 0,\n+                c = d.call(arguments),\n+                e = c.length,\n+                f = 1 !== e || a && o.isFunction(a.promise) ? e : 0,\n+                g = 1 === f ? a : o.Deferred(),\n+                h = function(a, b, c) {\n+                    return function(e) {\n+                        b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c)\n+                    }\n+                },\n+                i, j, k;\n+            if (e > 1)\n+                for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++) c[b] && o.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;\n+            return f || g.resolveWith(k, c), g.promise()\n+        }\n+    });\n+    var H;\n+    o.fn.ready = function(a) {\n+        return o.ready.promise().done(a), this\n+    }, o.extend({\n+        isReady: !1,\n+        readyWait: 1,\n+        holdReady: function(a) {\n+            a ? o.readyWait++ : o.ready(!0)\n+        },\n+        ready: function(a) {\n+            (a === !0 ? --o.readyWait : o.isReady) || (o.isReady = !0, a !== !0 && --o.readyWait > 0 || (H.resolveWith(m, [o]), o.fn.trigger && o(m).trigger(\"ready\").off(\"ready\")))\n+        }\n+    });\n \n-\tvar preservedScriptAttributes = {\n-\t\ttype: true,\n-\t\tsrc: true,\n-\t\tnonce: true,\n-\t\tnoModule: true\n-\t};\n+    function I() {\n+        m.removeEventListener(\"DOMContentLoaded\", I, !1), a.removeEventListener(\"load\", I, !1), o.ready()\n+    }\n+    o.ready.promise = function(b) {\n+        return H || (H = o.Deferred(), \"complete\" === m.readyState ? setTimeout(o.ready) : (m.addEventListener(\"DOMContentLoaded\", I, !1), a.addEventListener(\"load\", I, !1))), H.promise(b)\n+    }, o.ready.promise();\n+    var J = o.access = function(a, b, c, d, e, f, g) {\n+        var h = 0,\n+            i = a.length,\n+            j = null == c;\n+        if (\"object\" === o.type(c)) {\n+            e = !0;\n+            for (h in c) o.access(a, b, h, c[h], !0, f, g)\n+        } else if (void 0 !== d && (e = !0, o.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {\n+                return j.call(o(a), c)\n+            })), b))\n+            for (; i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));\n+        return e ? a : j ? b.call(a) : i ? b(a[0], c) : f\n+    };\n+    o.acceptData = function(a) {\n+        return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType\n+    };\n \n-\tfunction DOMEval( code, node, doc ) {\n-\t\tdoc = doc || document;\n+    function K() {\n+        Object.defineProperty(this.cache = {}, 0, {\n+            get: function() {\n+                return {}\n+            }\n+        }), this.expando = o.expando + Math.random()\n+    }\n+    K.uid = 1, K.accepts = o.acceptData, K.prototype = {\n+        key: function(a) {\n+            if (!K.accepts(a)) return 0;\n+            var b = {},\n+                c = a[this.expando];\n+            if (!c) {\n+                c = K.uid++;\n+                try {\n+                    b[this.expando] = {\n+                        value: c\n+                    }, Object.defineProperties(a, b)\n+                } catch (d) {\n+                    b[this.expando] = c, o.extend(a, b)\n+                }\n+            }\n+            return this.cache[c] || (this.cache[c] = {}), c\n+        },\n+        set: function(a, b, c) {\n+            var d, e = this.key(a),\n+                f = this.cache[e];\n+            if (\"string\" == typeof b) f[b] = c;\n+            else if (o.isEmptyObject(f)) o.extend(this.cache[e], b);\n+            else\n+                for (d in b) f[d] = b[d];\n+            return f\n+        },\n+        get: function(a, b) {\n+            var c = this.cache[this.key(a)];\n+            return void 0 === b ? c : c[b]\n+        },\n+        access: function(a, b, c) {\n+            var d;\n+            return void 0 === b || b && \"string\" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, o.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b)\n+        },\n+        remove: function(a, b) {\n+            var c, d, e, f = this.key(a),\n+                g = this.cache[f];\n+            if (void 0 === b) this.cache[f] = {};\n+            else {\n+                o.isArray(b) ? d = b.concat(b.map(o.camelCase)) : (e = o.camelCase(b), b in g ? d = [b, e] : (d = e, d = d in g ? [d] : d.match(E) || [])), c = d.length;\n+                while (c--) delete g[d[c]]\n+            }\n+        },\n+        hasData: function(a) {\n+            return !o.isEmptyObject(this.cache[a[this.expando]] || {})\n+        },\n+        discard: function(a) {\n+            a[this.expando] && delete this.cache[a[this.expando]]\n+        }\n+    };\n+    var L = new K,\n+        M = new K,\n+        N = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n+        O = /([A-Z])/g;\n \n-\t\tvar i, val,\n-\t\t\tscript = doc.createElement( \"script\" );\n+    function P(a, b, c) {\n+        var d;\n+        if (void 0 === c && 1 === a.nodeType)\n+            if (d = \"data-\" + b.replace(O, \"-$1\").toLowerCase(), c = a.getAttribute(d), \"string\" == typeof c) {\n+                try {\n+                    c = \"true\" === c ? !0 : \"false\" === c ? !1 : \"null\" === c ? null : +c + \"\" === c ? +c : N.test(c) ? o.parseJSON(c) : c\n+                } catch (e) {}\n+                M.set(a, b, c)\n+            } else c = void 0;\n+        return c\n+    }\n+    o.extend({\n+        hasData: function(a) {\n+            return M.hasData(a) || L.hasData(a)\n+        },\n+        data: function(a, b, c) {\n+            return M.access(a, b, c)\n+        },\n+        removeData: function(a, b) {\n+            M.remove(a, b)\n+        },\n+        _data: function(a, b, c) {\n+            return L.access(a, b, c)\n+        },\n+        _removeData: function(a, b) {\n+            L.remove(a, b)\n+        }\n+    }), o.fn.extend({\n+        data: function(a, b) {\n+            var c, d, e, f = this[0],\n+                g = f && f.attributes;\n+            if (void 0 === a) {\n+                if (this.length && (e = M.get(f), 1 === f.nodeType && !L.get(f, \"hasDataAttrs\"))) {\n+                    c = g.length;\n+                    while (c--) d = g[c].name, 0 === d.indexOf(\"data-\") && (d = o.camelCase(d.slice(5)), P(f, d, e[d]));\n+                    L.set(f, \"hasDataAttrs\", !0)\n+                }\n+                return e\n+            }\n+            return \"object\" == typeof a ? this.each(function() {\n+                M.set(this, a)\n+            }) : J(this, function(b) {\n+                var c, d = o.camelCase(a);\n+                if (f && void 0 === b) {\n+                    if (c = M.get(f, a), void 0 !== c) return c;\n+                    if (c = M.get(f, d), void 0 !== c) return c;\n+                    if (c = P(f, d, void 0), void 0 !== c) return c\n+                } else this.each(function() {\n+                    var c = M.get(this, d);\n+                    M.set(this, d, b), -1 !== a.indexOf(\"-\") && void 0 !== c && M.set(this, a, b)\n+                })\n+            }, null, b, arguments.length > 1, null, !0)\n+        },\n+        removeData: function(a) {\n+            return this.each(function() {\n+                M.remove(this, a)\n+            })\n+        }\n+    }), o.extend({\n+        queue: function(a, b, c) {\n+            var d;\n+            return a ? (b = (b || \"fx\") + \"queue\", d = L.get(a, b), c && (!d || o.isArray(c) ? d = L.access(a, b, o.makeArray(c)) : d.push(c)), d || []) : void 0\n+        },\n+        dequeue: function(a, b) {\n+            b = b || \"fx\";\n+            var c = o.queue(a, b),\n+                d = c.length,\n+                e = c.shift(),\n+                f = o._queueHooks(a, b),\n+                g = function() {\n+                    o.dequeue(a, b)\n+                };\n+            \"inprogress\" === e && (e = c.shift(), d--), e && (\"fx\" === b && c.unshift(\"inprogress\"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()\n+        },\n+        _queueHooks: function(a, b) {\n+            var c = b + \"queueHooks\";\n+            return L.get(a, c) || L.access(a, c, {\n+                empty: o.Callbacks(\"once memory\").add(function() {\n+                    L.remove(a, [b + \"queue\", c])\n+                })\n+            })\n+        }\n+    }), o.fn.extend({\n+        queue: function(a, b) {\n+            var c = 2;\n+            return \"string\" != typeof a && (b = a, a = \"fx\", c--), arguments.length < c ? o.queue(this[0], a) : void 0 === b ? this : this.each(function() {\n+                var c = o.queue(this, a, b);\n+                o._queueHooks(this, a), \"fx\" === a && \"inprogress\" !== c[0] && o.dequeue(this, a)\n+            })\n+        },\n+        dequeue: function(a) {\n+            return this.each(function() {\n+                o.dequeue(this, a)\n+            })\n+        },\n+        clearQueue: function(a) {\n+            return this.queue(a || \"fx\", [])\n+        },\n+        promise: function(a, b) {\n+            var c, d = 1,\n+                e = o.Deferred(),\n+                f = this,\n+                g = this.length,\n+                h = function() {\n+                    --d || e.resolveWith(f, [f])\n+                };\n+            \"string\" != typeof a && (b = a, a = void 0), a = a || \"fx\";\n+            while (g--) c = L.get(f[g], a + \"queueHooks\"), c && c.empty && (d++, c.empty.add(h));\n+            return h(), e.promise(b)\n+        }\n+    });\n+    var Q = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n+        R = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n+        S = function(a, b) {\n+            return a = b || a, \"none\" === o.css(a, \"display\") || !o.contains(a.ownerDocument, a)\n+        },\n+        T = /^(?:checkbox|radio)$/i;\n+    ! function() {\n+        var a = m.createDocumentFragment(),\n+            b = a.appendChild(m.createElement(\"div\"));\n+        b.innerHTML = \"<input type='radio' checked='checked' name='t'/>\", l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = \"<textarea>x</textarea>\", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue\n+    }();\n+    var U = \"undefined\";\n+    l.focusinBubbles = \"onfocusin\" in a;\n+    var V = /^key/,\n+        W = /^(?:mouse|contextmenu)|click/,\n+        X = /^(?:focusinfocus|focusoutblur)$/,\n+        Y = /^([^.]*)(?:\\.(.+)|)$/;\n \n-\t\tscript.text = code;\n-\t\tif ( node ) {\n-\t\t\tfor ( i in preservedScriptAttributes ) {\n+    function Z() {\n+        return !0\n+    }\n \n-\t\t\t\t// Support: Firefox 64+, Edge 18+\n-\t\t\t\t// Some browsers don't support the \"nonce\" property on scripts.\n-\t\t\t\t// On the other hand, just using `getAttribute` is not enough as\n-\t\t\t\t// the `nonce` attribute is reset to an empty string whenever it\n-\t\t\t\t// becomes browsing-context connected.\n-\t\t\t\t// See https://github.com/whatwg/html/issues/2369\n-\t\t\t\t// See https://html.spec.whatwg.org/#nonce-attributes\n-\t\t\t\t// The `node.getAttribute` check was added for the sake of\n-\t\t\t\t// `jQuery.globalEval` so that it can fake a nonce-containing node\n-\t\t\t\t// via an object.\n-\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n-\t\t\t\tif ( val ) {\n-\t\t\t\t\tscript.setAttribute( i, val );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n-\t}\n+    function $() {\n+        return !1\n+    }\n \n+    function _() {\n+        try {\n+            return m.activeElement\n+        } catch (a) {}\n+    }\n+    o.event = {\n+        global: {},\n+        add: function(a, b, c, d, e) {\n+            var f, g, h, i, j, k, l, m, n, p, q, r = L.get(a);\n+            if (r) {\n+                c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = o.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function(b) {\n+                    return typeof o !== U && o.event.triggered !== b.type ? o.event.dispatch.apply(a, arguments) : void 0\n+                }), b = (b || \"\").match(E) || [\"\"], j = b.length;\n+                while (j--) h = Y.exec(b[j]) || [], n = q = h[1], p = (h[2] || \"\").split(\".\").sort(), n && (l = o.event.special[n] || {}, n = (e ? l.delegateType : l.bindType) || n, l = o.event.special[n] || {}, k = o.extend({\n+                    type: n,\n+                    origType: q,\n+                    data: d,\n+                    handler: c,\n+                    guid: c.guid,\n+                    selector: e,\n+                    needsContext: e && o.expr.match.needsContext.test(e),\n+                    namespace: p.join(\".\")\n+                }, f), (m = i[n]) || (m = i[n] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(n, g, !1)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), o.event.global[n] = !0)\n+            }\n+        },\n+        remove: function(a, b, c, d, e) {\n+            var f, g, h, i, j, k, l, m, n, p, q, r = L.hasData(a) && L.get(a);\n+            if (r && (i = r.events)) {\n+                b = (b || \"\").match(E) || [\"\"], j = b.length;\n+                while (j--)\n+                    if (h = Y.exec(b[j]) || [], n = q = h[1], p = (h[2] || \"\").split(\".\").sort(), n) {\n+                        l = o.event.special[n] || {}, n = (d ? l.delegateType : l.bindType) || n, m = i[n] || [], h = h[2] && new RegExp(\"(^|\\\\.)\" + p.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"), g = f = m.length;\n+                        while (f--) k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && (\"**\" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));\n+                        g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || o.removeEvent(a, n, r.handle), delete i[n])\n+                    } else\n+                        for (n in i) o.event.remove(a, n + b[j], c, d, !0);\n+                o.isEmptyObject(i) && (delete r.handle, L.remove(a, \"events\"))\n+            }\n+        },\n+        trigger: function(b, c, d, e) {\n+            var f, g, h, i, k, l, n, p = [d || m],\n+                q = j.call(b, \"type\") ? b.type : b,\n+                r = j.call(b, \"namespace\") ? b.namespace.split(\".\") : [];\n+            if (g = h = d = d || m, 3 !== d.nodeType && 8 !== d.nodeType && !X.test(q + o.event.triggered) && (q.indexOf(\".\") >= 0 && (r = q.split(\".\"), q = r.shift(), r.sort()), k = q.indexOf(\":\") < 0 && \"on\" + q, b = b[o.expando] ? b : new o.Event(q, \"object\" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = r.join(\".\"), b.namespace_re = b.namespace ? new RegExp(\"(^|\\\\.)\" + r.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : o.makeArray(c, [b]), n = o.event.special[q] || {}, e || !n.trigger || n.trigger.apply(d, c) !== !1)) {\n+                if (!e && !n.noBubble && !o.isWindow(d)) {\n+                    for (i = n.delegateType || q, X.test(i + q) || (g = g.parentNode); g; g = g.parentNode) p.push(g), h = g;\n+                    h === (d.ownerDocument || m) && p.push(h.defaultView || h.parentWindow || a)\n+                }\n+                f = 0;\n+                while ((g = p[f++]) && !b.isPropagationStopped()) b.type = f > 1 ? i : n.bindType || q, l = (L.get(g, \"events\") || {})[b.type] && L.get(g, \"handle\"), l && l.apply(g, c), l = k && g[k], l && l.apply && o.acceptData(g) && (b.result = l.apply(g, c), b.result === !1 && b.preventDefault());\n+                return b.type = q, e || b.isDefaultPrevented() || n._default && n._default.apply(p.pop(), c) !== !1 || !o.acceptData(d) || k && o.isFunction(d[q]) && !o.isWindow(d) && (h = d[k], h && (d[k] = null), o.event.triggered = q, d[q](), o.event.triggered = void 0, h && (d[k] = h)), b.result\n+            }\n+        },\n+        dispatch: function(a) {\n+            a = o.event.fix(a);\n+            var b, c, e, f, g, h = [],\n+                i = d.call(arguments),\n+                j = (L.get(this, \"events\") || {})[a.type] || [],\n+                k = o.event.special[a.type] || {};\n+            if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {\n+                h = o.event.handlers.call(this, a, j), b = 0;\n+                while ((f = h[b++]) && !a.isPropagationStopped()) {\n+                    a.currentTarget = f.elem, c = 0;\n+                    while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped())(!a.namespace_re || a.namespace_re.test(g.namespace)) && (a.handleObj = g, a.data = g.data, e = ((o.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== e && (a.result = e) === !1 && (a.preventDefault(), a.stopPropagation()))\n+                }\n+                return k.postDispatch && k.postDispatch.call(this, a), a.result\n+            }\n+        },\n+        handlers: function(a, b) {\n+            var c, d, e, f, g = [],\n+                h = b.delegateCount,\n+                i = a.target;\n+            if (h && i.nodeType && (!a.button || \"click\" !== a.type))\n+                for (; i !== this; i = i.parentNode || this)\n+                    if (i.disabled !== !0 || \"click\" !== a.type) {\n+                        for (d = [], c = 0; h > c; c++) f = b[c], e = f.selector + \" \", void 0 === d[e] && (d[e] = f.needsContext ? o(e, this).index(i) >= 0 : o.find(e, this, null, [i]).length), d[e] && d.push(f);\n+                        d.length && g.push({\n+                            elem: i,\n+                            handlers: d\n+                        })\n+                    }\n+            return h < b.length && g.push({\n+                elem: this,\n+                handlers: b.slice(h)\n+            }), g\n+        },\n+        props: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n+        fixHooks: {},\n+        keyHooks: {\n+            props: \"char charCode key keyCode\".split(\" \"),\n+            filter: function(a, b) {\n+                return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a\n+            }\n+        },\n+        mouseHooks: {\n+            props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n+            filter: function(a, b) {\n+                var c, d, e, f = b.button;\n+                return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || m, d = c.documentElement, e = c.body, a.pageX = b.clientX + (d && d.scrollLeft || e && e.scrollLeft || 0) - (d && d.clientLeft || e && e.clientLeft || 0), a.pageY = b.clientY + (d && d.scrollTop || e && e.scrollTop || 0) - (d && d.clientTop || e && e.clientTop || 0)), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a\n+            }\n+        },\n+        fix: function(a) {\n+            if (a[o.expando]) return a;\n+            var b, c, d, e = a.type,\n+                f = a,\n+                g = this.fixHooks[e];\n+            g || (this.fixHooks[e] = g = W.test(e) ? this.mouseHooks : V.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new o.Event(f), b = d.length;\n+            while (b--) c = d[b], a[c] = f[c];\n+            return a.target || (a.target = m), 3 === a.target.nodeType && (a.target = a.target.parentNode), g.filter ? g.filter(a, f) : a\n+        },\n+        special: {\n+            load: {\n+                noBubble: !0\n+            },\n+            focus: {\n+                trigger: function() {\n+                    return this !== _() && this.focus ? (this.focus(), !1) : void 0\n+                },\n+                delegateType: \"focusin\"\n+            },\n+            blur: {\n+                trigger: function() {\n+                    return this === _() && this.blur ? (this.blur(), !1) : void 0\n+                },\n+                delegateType: \"focusout\"\n+            },\n+            click: {\n+                trigger: function() {\n+                    return \"checkbox\" === this.type && this.click && o.nodeName(this, \"input\") ? (this.click(), !1) : void 0\n+                },\n+                _default: function(a) {\n+                    return o.nodeName(a.target, \"a\")\n+                }\n+            },\n+            beforeunload: {\n+                postDispatch: function(a) {\n+                    void 0 !== a.result && (a.originalEvent.returnValue = a.result)\n+                }\n+            }\n+        },\n+        simulate: function(a, b, c, d) {\n+            var e = o.extend(new o.Event, c, {\n+                type: a,\n+                isSimulated: !0,\n+                originalEvent: {}\n+            });\n+            d ? o.event.trigger(e, null, b) : o.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault()\n+        }\n+    }, o.removeEvent = function(a, b, c) {\n+        a.removeEventListener && a.removeEventListener(b, c, !1)\n+    }, o.Event = function(a, b) {\n+        return this instanceof o.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.getPreventDefault && a.getPreventDefault() ? Z : $) : this.type = a, b && o.extend(this, b), this.timeStamp = a && a.timeStamp || o.now(), void(this[o.expando] = !0)) : new o.Event(a, b)\n+    }, o.Event.prototype = {\n+        isDefaultPrevented: $,\n+        isPropagationStopped: $,\n+        isImmediatePropagationStopped: $,\n+        preventDefault: function() {\n+            var a = this.originalEvent;\n+            this.isDefaultPrevented = Z, a && a.preventDefault && a.preventDefault()\n+        },\n+        stopPropagation: function() {\n+            var a = this.originalEvent;\n+            this.isPropagationStopped = Z, a && a.stopPropagation && a.stopPropagation()\n+        },\n+        stopImmediatePropagation: function() {\n+            this.isImmediatePropagationStopped = Z, this.stopPropagation()\n+        }\n+    }, o.each({\n+        mouseenter: \"mouseover\",\n+        mouseleave: \"mouseout\"\n+    }, function(a, b) {\n+        o.event.special[a] = {\n+            delegateType: b,\n+            bindType: b,\n+            handle: function(a) {\n+                var c, d = this,\n+                    e = a.relatedTarget,\n+                    f = a.handleObj;\n+                return (!e || e !== d && !o.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c\n+            }\n+        }\n+    }), l.focusinBubbles || o.each({\n+        focus: \"focusin\",\n+        blur: \"focusout\"\n+    }, function(a, b) {\n+        var c = function(a) {\n+            o.event.simulate(b, a.target, o.event.fix(a), !0)\n+        };\n+        o.event.special[b] = {\n+            setup: function() {\n+                var d = this.ownerDocument || this,\n+                    e = L.access(d, b);\n+                e || d.addEventListener(a, c, !0), L.access(d, b, (e || 0) + 1)\n+            },\n+            teardown: function() {\n+                var d = this.ownerDocument || this,\n+                    e = L.access(d, b) - 1;\n+                e ? L.access(d, b, e) : (d.removeEventListener(a, c, !0), L.remove(d, b))\n+            }\n+        }\n+    }), o.fn.extend({\n+        on: function(a, b, c, d, e) {\n+            var f, g;\n+            if (\"object\" == typeof a) {\n+                \"string\" != typeof b && (c = c || b, b = void 0);\n+                for (g in a) this.on(g, b, c, a[g], e);\n+                return this\n+            }\n+            if (null == c && null == d ? (d = b, c = b = void 0) : null == d && (\"string\" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = $;\n+            else if (!d) return this;\n+            return 1 === e && (f = d, d = function(a) {\n+                return o().off(a), f.apply(this, arguments)\n+            }, d.guid = f.guid || (f.guid = o.guid++)), this.each(function() {\n+                o.event.add(this, a, d, c, b)\n+            })\n+        },\n+        one: function(a, b, c, d) {\n+            return this.on(a, b, c, d, 1)\n+        },\n+        off: function(a, b, c) {\n+            var d, e;\n+            if (a && a.preventDefault && a.handleObj) return d = a.handleObj, o(a.delegateTarget).off(d.namespace ? d.origType + \".\" + d.namespace : d.origType, d.selector, d.handler), this;\n+            if (\"object\" == typeof a) {\n+                for (e in a) this.off(e, b, a[e]);\n+                return this\n+            }\n+            return (b === !1 || \"function\" == typeof b) && (c = b, b = void 0), c === !1 && (c = $), this.each(function() {\n+                o.event.remove(this, a, c, b)\n+            })\n+        },\n+        trigger: function(a, b) {\n+            return this.each(function() {\n+                o.event.trigger(a, b, this)\n+            })\n+        },\n+        triggerHandler: function(a, b) {\n+            var c = this[0];\n+            return c ? o.event.trigger(a, b, c, !0) : void 0\n+        }\n+    });\n+    var ab = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n+        bb = /<([\\w:]+)/,\n+        cb = /<|&#?\\w+;/,\n+        db = /<(?:script|style|link)/i,\n+        eb = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n+        fb = /^$|\\/(?:java|ecma)script/i,\n+        gb = /^true\\/(.*)/,\n+        hb = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n+        ib = {\n+            option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n+            thead: [1, \"<table>\", \"</table>\"],\n+            col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n+            tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n+            td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n+            _default: [0, \"\", \"\"]\n+        };\n+    ib.optgroup = ib.option, ib.tbody = ib.tfoot = ib.colgroup = ib.caption = ib.thead, ib.th = ib.td;\n \n-function toType( obj ) {\n-\tif ( obj == null ) {\n-\t\treturn obj + \"\";\n-\t}\n+    function jb(a, b) {\n+        return o.nodeName(a, \"table\") && o.nodeName(11 !== b.nodeType ? b : b.firstChild, \"tr\") ? a.getElementsByTagName(\"tbody\")[0] || a.appendChild(a.ownerDocument.createElement(\"tbody\")) : a\n+    }\n \n-\t// Support: Android <=2.3 only (functionish RegExp)\n-\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n-\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n-\t\ttypeof obj;\n-}\n-/* global Symbol */\n-// Defining this global in .eslintrc.json would create a danger of using the global\n-// unguarded in another place, it seems safer to define global only for this module\n+    function kb(a) {\n+        return a.type = (null !== a.getAttribute(\"type\")) + \"/\" + a.type, a\n+    }\n \n+    function lb(a) {\n+        var b = gb.exec(a.type);\n+        return b ? a.type = b[1] : a.removeAttribute(\"type\"), a\n+    }\n \n+    function mb(a, b) {\n+        for (var c = 0, d = a.length; d > c; c++) L.set(a[c], \"globalEval\", !b || L.get(b[c], \"globalEval\"))\n+    }\n \n-var\n-\tversion = \"3.6.3\",\n+    function nb(a, b) {\n+        var c, d, e, f, g, h, i, j;\n+        if (1 === b.nodeType) {\n+            if (L.hasData(a) && (f = L.access(a), g = L.set(b, f), j = f.events)) {\n+                delete g.handle, g.events = {};\n+                for (e in j)\n+                    for (c = 0, d = j[e].length; d > c; c++) o.event.add(b, e, j[e][c])\n+            }\n+            M.hasData(a) && (h = M.access(a), i = o.extend({}, h), M.set(b, i))\n+        }\n+    }\n \n-\t// Define a local copy of jQuery\n-\tjQuery = function( selector, context ) {\n+    function ob(a, b) {\n+        var c = a.getElementsByTagName ? a.getElementsByTagName(b || \"*\") : a.querySelectorAll ? a.querySelectorAll(b || \"*\") : [];\n+        return void 0 === b || b && o.nodeName(a, b) ? o.merge([a], c) : c\n+    }\n \n-\t\t// The jQuery object is actually just the init constructor 'enhanced'\n-\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n-\t\treturn new jQuery.fn.init( selector, context );\n-\t};\n+    function pb(a, b) {\n+        var c = b.nodeName.toLowerCase();\n+        \"input\" === c && T.test(a.type) ? b.checked = a.checked : (\"input\" === c || \"textarea\" === c) && (b.defaultValue = a.defaultValue)\n+    }\n+    o.extend({\n+        clone: function(a, b, c) {\n+            var d, e, f, g, h = a.cloneNode(!0),\n+                i = o.contains(a.ownerDocument, a);\n+            if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || o.isXMLDoc(a)))\n+                for (g = ob(h), f = ob(a), d = 0, e = f.length; e > d; d++) pb(f[d], g[d]);\n+            if (b)\n+                if (c)\n+                    for (f = f || ob(a), g = g || ob(h), d = 0, e = f.length; e > d; d++) nb(f[d], g[d]);\n+                else nb(a, h);\n+            return g = ob(h, \"script\"), g.length > 0 && mb(g, !i && ob(a, \"script\")), h\n+        },\n+        buildFragment: function(a, b, c, d) {\n+            for (var e, f, g, h, i, j, k = b.createDocumentFragment(), l = [], m = 0, n = a.length; n > m; m++)\n+                if (e = a[m], e || 0 === e)\n+                    if (\"object\" === o.type(e)) o.merge(l, e.nodeType ? [e] : e);\n+                    else if (cb.test(e)) {\n+                f = f || k.appendChild(b.createElement(\"div\")), g = (bb.exec(e) || [\"\", \"\"])[1].toLowerCase(), h = ib[g] || ib._default, f.innerHTML = h[1] + e.replace(ab, \"<$1></$2>\") + h[2], j = h[0];\n+                while (j--) f = f.lastChild;\n+                o.merge(l, f.childNodes), f = k.firstChild, f.textContent = \"\"\n+            } else l.push(b.createTextNode(e));\n+            k.textContent = \"\", m = 0;\n+            while (e = l[m++])\n+                if ((!d || -1 === o.inArray(e, d)) && (i = o.contains(e.ownerDocument, e), f = ob(k.appendChild(e), \"script\"), i && mb(f), c)) {\n+                    j = 0;\n+                    while (e = f[j++]) fb.test(e.type || \"\") && c.push(e)\n+                }\n+            return k\n+        },\n+        cleanData: function(a) {\n+            for (var b, c, d, e, f, g, h = o.event.special, i = 0; void 0 !== (c = a[i]); i++) {\n+                if (o.acceptData(c) && (f = c[L.expando], f && (b = L.cache[f]))) {\n+                    if (d = Object.keys(b.events || {}), d.length)\n+                        for (g = 0; void 0 !== (e = d[g]); g++) h[e] ? o.event.remove(c, e) : o.removeEvent(c, e, b.handle);\n+                    L.cache[f] && delete L.cache[f]\n+                }\n+                delete M.cache[c[M.expando]]\n+            }\n+        }\n+    }), o.fn.extend({\n+        text: function(a) {\n+            return J(this, function(a) {\n+                return void 0 === a ? o.text(this) : this.empty().each(function() {\n+                    (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = a)\n+                })\n+            }, null, a, arguments.length)\n+        },\n+        append: function() {\n+            return this.domManip(arguments, function(a) {\n+                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n+                    var b = jb(this, a);\n+                    b.appendChild(a)\n+                }\n+            })\n+        },\n+        prepend: function() {\n+            return this.domManip(arguments, function(a) {\n+                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n+                    var b = jb(this, a);\n+                    b.insertBefore(a, b.firstChild)\n+                }\n+            })\n+        },\n+        before: function() {\n+            return this.domManip(arguments, function(a) {\n+                this.parentNode && this.parentNode.insertBefore(a, this)\n+            })\n+        },\n+        after: function() {\n+            return this.domManip(arguments, function(a) {\n+                this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)\n+            })\n+        },\n+        remove: function(a, b) {\n+            for (var c, d = a ? o.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || o.cleanData(ob(c)), c.parentNode && (b && o.contains(c.ownerDocument, c) && mb(ob(c, \"script\")), c.parentNode.removeChild(c));\n+            return this\n+        },\n+        empty: function() {\n+            for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (o.cleanData(ob(a, !1)), a.textContent = \"\");\n+            return this\n+        },\n+        clone: function(a, b) {\n+            return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function() {\n+                return o.clone(this, a, b)\n+            })\n+        },\n+        html: function(a) {\n+            return J(this, function(a) {\n+                var b = this[0] || {},\n+                    c = 0,\n+                    d = this.length;\n+                if (void 0 === a && 1 === b.nodeType) return b.innerHTML;\n+                if (\"string\" == typeof a && !db.test(a) && !ib[(bb.exec(a) || [\"\", \"\"])[1].toLowerCase()]) {\n+                    a = a.replace(ab, \"<$1></$2>\");\n+                    try {\n+                        for (; d > c; c++) b = this[c] || {}, 1 === b.nodeType && (o.cleanData(ob(b, !1)), b.innerHTML = a);\n+                        b = 0\n+                    } catch (e) {}\n+                }\n+                b && this.empty().append(a)\n+            }, null, a, arguments.length)\n+        },\n+        replaceWith: function() {\n+            var a = arguments[0];\n+            return this.domManip(arguments, function(b) {\n+                a = this.parentNode, o.cleanData(ob(this)), a && a.replaceChild(b, this)\n+            }), a && (a.length || a.nodeType) ? this : this.remove()\n+        },\n+        detach: function(a) {\n+            return this.remove(a, !0)\n+        },\n+        domManip: function(a, b) {\n+            a = e.apply([], a);\n+            var c, d, f, g, h, i, j = 0,\n+                k = this.length,\n+                m = this,\n+                n = k - 1,\n+                p = a[0],\n+                q = o.isFunction(p);\n+            if (q || k > 1 && \"string\" == typeof p && !l.checkClone && eb.test(p)) return this.each(function(c) {\n+                var d = m.eq(c);\n+                q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b)\n+            });\n+            if (k && (c = o.buildFragment(a, this[0].ownerDocument, !1, this), d = c.firstChild, 1 === c.childNodes.length && (c = d), d)) {\n+                for (f = o.map(ob(c, \"script\"), kb), g = f.length; k > j; j++) h = c, j !== n && (h = o.clone(h, !0, !0), g && o.merge(f, ob(h, \"script\"))), b.call(this[j], h, j);\n+                if (g)\n+                    for (i = f[f.length - 1].ownerDocument, o.map(f, lb), j = 0; g > j; j++) h = f[j], fb.test(h.type || \"\") && !L.access(h, \"globalEval\") && o.contains(i, h) && (h.src ? o._evalUrl && o._evalUrl(h.src) : o.globalEval(h.textContent.replace(hb, \"\")))\n+            }\n+            return this\n+        }\n+    }), o.each({\n+        appendTo: \"append\",\n+        prependTo: \"prepend\",\n+        insertBefore: \"before\",\n+        insertAfter: \"after\",\n+        replaceAll: \"replaceWith\"\n+    }, function(a, b) {\n+        o.fn[a] = function(a) {\n+            for (var c, d = [], e = o(a), g = e.length - 1, h = 0; g >= h; h++) c = h === g ? this : this.clone(!0), o(e[h])[b](c), f.apply(d, c.get());\n+            return this.pushStack(d)\n+        }\n+    });\n+    var qb, rb = {};\n \n-jQuery.fn = jQuery.prototype = {\n+    function sb(b, c) {\n+        var d = o(c.createElement(b)).appendTo(c.body),\n+            e = a.getDefaultComputedStyle ? a.getDefaultComputedStyle(d[0]).display : o.css(d[0], \"display\");\n+        return d.detach(), e\n+    }\n \n-\t// The current version of jQuery being used\n-\tjquery: version,\n+    function tb(a) {\n+        var b = m,\n+            c = rb[a];\n+        return c || (c = sb(a, b), \"none\" !== c && c || (qb = (qb || o(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement), b = qb[0].contentDocument, b.write(), b.close(), c = sb(a, b), qb.detach()), rb[a] = c), c\n+    }\n+    var ub = /^margin/,\n+        vb = new RegExp(\"^(\" + Q + \")(?!px)[a-z%]+$\", \"i\"),\n+        wb = function(a) {\n+            return a.ownerDocument.defaultView.getComputedStyle(a, null)\n+        };\n \n-\tconstructor: jQuery,\n+    function xb(a, b, c) {\n+        var d, e, f, g, h = a.style;\n+        return c = c || wb(a), c && (g = c.getPropertyValue(b) || c[b]), c && (\"\" !== g || o.contains(a.ownerDocument, a) || (g = o.style(a, b)), vb.test(g) && ub.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + \"\" : g\n+    }\n \n-\t// The default length of a jQuery object is 0\n-\tlength: 0,\n+    function yb(a, b) {\n+        return {\n+            get: function() {\n+                return a() ? void delete this.get : (this.get = b).apply(this, arguments)\n+            }\n+        }\n+    }! function() {\n+        var b, c, d = \"padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box\",\n+            e = m.documentElement,\n+            f = m.createElement(\"div\"),\n+            g = m.createElement(\"div\");\n+        g.style.backgroundClip = \"content-box\", g.cloneNode(!0).style.backgroundClip = \"\", l.clearCloneStyle = \"content-box\" === g.style.backgroundClip, f.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\", f.appendChild(g);\n \n-\ttoArray: function() {\n-\t\treturn slice.call( this );\n-\t},\n+        function h() {\n+            g.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%\", e.appendChild(f);\n+            var d = a.getComputedStyle(g, null);\n+            b = \"1%\" !== d.top, c = \"4px\" === d.width, e.removeChild(f)\n+        }\n+        a.getComputedStyle && o.extend(l, {\n+            pixelPosition: function() {\n+                return h(), b\n+            },\n+            boxSizingReliable: function() {\n+                return null == c && h(), c\n+            },\n+            reliableMarginRight: function() {\n+                var b, c = g.appendChild(m.createElement(\"div\"));\n+                return c.style.cssText = g.style.cssText = d, c.style.marginRight = c.style.width = \"0\", g.style.width = \"1px\", e.appendChild(f), b = !parseFloat(a.getComputedStyle(c, null).marginRight), e.removeChild(f), g.innerHTML = \"\", b\n+            }\n+        })\n+    }(), o.swap = function(a, b, c, d) {\n+        var e, f, g = {};\n+        for (f in b) g[f] = a.style[f], a.style[f] = b[f];\n+        e = c.apply(a, d || []);\n+        for (f in b) a.style[f] = g[f];\n+        return e\n+    };\n+    var zb = /^(none|table(?!-c[ea]).+)/,\n+        Ab = new RegExp(\"^(\" + Q + \")(.*)$\", \"i\"),\n+        Bb = new RegExp(\"^([+-])=(\" + Q + \")\", \"i\"),\n+        Cb = {\n+            position: \"absolute\",\n+            visibility: \"hidden\",\n+            display: \"block\"\n+        },\n+        Db = {\n+            letterSpacing: 0,\n+            fontWeight: 400\n+        },\n+        Eb = [\"Webkit\", \"O\", \"Moz\", \"ms\"];\n \n-\t// Get the Nth element in the matched element set OR\n-\t// Get the whole matched element set as a clean array\n-\tget: function( num ) {\n+    function Fb(a, b) {\n+        if (b in a) return b;\n+        var c = b[0].toUpperCase() + b.slice(1),\n+            d = b,\n+            e = Eb.length;\n+        while (e--)\n+            if (b = Eb[e] + c, b in a) return b;\n+        return d\n+    }\n \n-\t\t// Return all the elements in a clean array\n-\t\tif ( num == null ) {\n-\t\t\treturn slice.call( this );\n-\t\t}\n+    function Gb(a, b, c) {\n+        var d = Ab.exec(b);\n+        return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || \"px\") : b\n+    }\n \n-\t\t// Return just the one element from the set\n-\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n-\t},\n+    function Hb(a, b, c, d, e) {\n+        for (var f = c === (d ? \"border\" : \"content\") ? 4 : \"width\" === b ? 1 : 0, g = 0; 4 > f; f += 2) \"margin\" === c && (g += o.css(a, c + R[f], !0, e)), d ? (\"content\" === c && (g -= o.css(a, \"padding\" + R[f], !0, e)), \"margin\" !== c && (g -= o.css(a, \"border\" + R[f] + \"Width\", !0, e))) : (g += o.css(a, \"padding\" + R[f], !0, e), \"padding\" !== c && (g += o.css(a, \"border\" + R[f] + \"Width\", !0, e)));\n+        return g\n+    }\n \n-\t// Take an array of elements and push it onto the stack\n-\t// (returning the new matched element set)\n-\tpushStack: function( elems ) {\n+    function Ib(a, b, c) {\n+        var d = !0,\n+            e = \"width\" === b ? a.offsetWidth : a.offsetHeight,\n+            f = wb(a),\n+            g = \"border-box\" === o.css(a, \"boxSizing\", !1, f);\n+        if (0 >= e || null == e) {\n+            if (e = xb(a, b, f), (0 > e || null == e) && (e = a.style[b]), vb.test(e)) return e;\n+            d = g && (l.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0\n+        }\n+        return e + Hb(a, b, c || (g ? \"border\" : \"content\"), d, f) + \"px\"\n+    }\n \n-\t\t// Build a new jQuery matched element set\n-\t\tvar ret = jQuery.merge( this.constructor(), elems );\n+    function Jb(a, b) {\n+        for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = L.get(d, \"olddisplay\"), c = d.style.display, b ? (f[g] || \"none\" !== c || (d.style.display = \"\"), \"\" === d.style.display && S(d) && (f[g] = L.access(d, \"olddisplay\", tb(d.nodeName)))) : f[g] || (e = S(d), (c && \"none\" !== c || !e) && L.set(d, \"olddisplay\", e ? c : o.css(d, \"display\"))));\n+        for (g = 0; h > g; g++) d = a[g], d.style && (b && \"none\" !== d.style.display && \"\" !== d.style.display || (d.style.display = b ? f[g] || \"\" : \"none\"));\n+        return a\n+    }\n+    o.extend({\n+        cssHooks: {\n+            opacity: {\n+                get: function(a, b) {\n+                    if (b) {\n+                        var c = xb(a, \"opacity\");\n+                        return \"\" === c ? \"1\" : c\n+                    }\n+                }\n+            }\n+        },\n+        cssNumber: {\n+            columnCount: !0,\n+            fillOpacity: !0,\n+            fontWeight: !0,\n+            lineHeight: !0,\n+            opacity: !0,\n+            order: !0,\n+            orphans: !0,\n+            widows: !0,\n+            zIndex: !0,\n+            zoom: !0\n+        },\n+        cssProps: {\n+            \"float\": \"cssFloat\"\n+        },\n+        style: function(a, b, c, d) {\n+            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {\n+                var e, f, g, h = o.camelCase(b),\n+                    i = a.style;\n+                return b = o.cssProps[h] || (o.cssProps[h] = Fb(i, h)), g = o.cssHooks[b] || o.cssHooks[h], void 0 === c ? g && \"get\" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c, \"string\" === f && (e = Bb.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(o.css(a, b)), f = \"number\"), null != c && c === c && (\"number\" !== f || o.cssNumber[h] || (c += \"px\"), l.clearCloneStyle || \"\" !== c || 0 !== b.indexOf(\"background\") || (i[b] = \"inherit\"), g && \"set\" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = \"\", i[b] = c)), void 0)\n+            }\n+        },\n+        css: function(a, b, c, d) {\n+            var e, f, g, h = o.camelCase(b);\n+            return b = o.cssProps[h] || (o.cssProps[h] = Fb(a.style, h)), g = o.cssHooks[b] || o.cssHooks[h], g && \"get\" in g && (e = g.get(a, !0, c)), void 0 === e && (e = xb(a, b, d)), \"normal\" === e && b in Db && (e = Db[b]), \"\" === c || c ? (f = parseFloat(e), c === !0 || o.isNumeric(f) ? f || 0 : e) : e\n+        }\n+    }), o.each([\"height\", \"width\"], function(a, b) {\n+        o.cssHooks[b] = {\n+            get: function(a, c, d) {\n+                return c ? 0 === a.offsetWidth && zb.test(o.css(a, \"display\")) ? o.swap(a, Cb, function() {\n+                    return Ib(a, b, d)\n+                }) : Ib(a, b, d) : void 0\n+            },\n+            set: function(a, c, d) {\n+                var e = d && wb(a);\n+                return Gb(a, c, d ? Hb(a, b, d, \"border-box\" === o.css(a, \"boxSizing\", !1, e), e) : 0)\n+            }\n+        }\n+    }), o.cssHooks.marginRight = yb(l.reliableMarginRight, function(a, b) {\n+        return b ? o.swap(a, {\n+            display: \"inline-block\"\n+        }, xb, [a, \"marginRight\"]) : void 0\n+    }), o.each({\n+        margin: \"\",\n+        padding: \"\",\n+        border: \"Width\"\n+    }, function(a, b) {\n+        o.cssHooks[a + b] = {\n+            expand: function(c) {\n+                for (var d = 0, e = {}, f = \"string\" == typeof c ? c.split(\" \") : [c]; 4 > d; d++) e[a + R[d] + b] = f[d] || f[d - 2] || f[0];\n+                return e\n+            }\n+        }, ub.test(a) || (o.cssHooks[a + b].set = Gb)\n+    }), o.fn.extend({\n+        css: function(a, b) {\n+            return J(this, function(a, b, c) {\n+                var d, e, f = {},\n+                    g = 0;\n+                if (o.isArray(b)) {\n+                    for (d = wb(a), e = b.length; e > g; g++) f[b[g]] = o.css(a, b[g], !1, d);\n+                    return f\n+                }\n+                return void 0 !== c ? o.style(a, b, c) : o.css(a, b)\n+            }, a, b, arguments.length > 1)\n+        },\n+        show: function() {\n+            return Jb(this, !0)\n+        },\n+        hide: function() {\n+            return Jb(this)\n+        },\n+        toggle: function(a) {\n+            return \"boolean\" == typeof a ? a ? this.show() : this.hide() : this.each(function() {\n+                S(this) ? o(this).show() : o(this).hide()\n+            })\n+        }\n+    });\n \n-\t\t// Add the old object onto the stack (as a reference)\n-\t\tret.prevObject = this;\n+    function Kb(a, b, c, d, e) {\n+        return new Kb.prototype.init(a, b, c, d, e)\n+    }\n+    o.Tween = Kb, Kb.prototype = {\n+        constructor: Kb,\n+        init: function(a, b, c, d, e, f) {\n+            this.elem = a, this.prop = c, this.easing = e || \"swing\", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (o.cssNumber[c] ? \"\" : \"px\")\n+        },\n+        cur: function() {\n+            var a = Kb.propHooks[this.prop];\n+            return a && a.get ? a.get(this) : Kb.propHooks._default.get(this)\n+        },\n+        run: function(a) {\n+            var b, c = Kb.propHooks[this.prop];\n+            return this.pos = b = this.options.duration ? o.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Kb.propHooks._default.set(this), this\n+        }\n+    }, Kb.prototype.init.prototype = Kb.prototype, Kb.propHooks = {\n+        _default: {\n+            get: function(a) {\n+                var b;\n+                return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = o.css(a.elem, a.prop, \"\"), b && \"auto\" !== b ? b : 0) : a.elem[a.prop]\n+            },\n+            set: function(a) {\n+                o.fx.step[a.prop] ? o.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[o.cssProps[a.prop]] || o.cssHooks[a.prop]) ? o.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now\n+            }\n+        }\n+    }, Kb.propHooks.scrollTop = Kb.propHooks.scrollLeft = {\n+        set: function(a) {\n+            a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)\n+        }\n+    }, o.easing = {\n+        linear: function(a) {\n+            return a\n+        },\n+        swing: function(a) {\n+            return .5 - Math.cos(a * Math.PI) / 2\n+        }\n+    }, o.fx = Kb.prototype.init, o.fx.step = {};\n+    var Lb, Mb, Nb = /^(?:toggle|show|hide)$/,\n+        Ob = new RegExp(\"^(?:([+-])=|)(\" + Q + \")([a-z%]*)$\", \"i\"),\n+        Pb = /queueHooks$/,\n+        Qb = [Vb],\n+        Rb = {\n+            \"*\": [function(a, b) {\n+                var c = this.createTween(a, b),\n+                    d = c.cur(),\n+                    e = Ob.exec(b),\n+                    f = e && e[3] || (o.cssNumber[a] ? \"\" : \"px\"),\n+                    g = (o.cssNumber[a] || \"px\" !== f && +d) && Ob.exec(o.css(c.elem, a)),\n+                    h = 1,\n+                    i = 20;\n+                if (g && g[3] !== f) {\n+                    f = f || g[3], e = e || [], g = +d || 1;\n+                    do h = h || \".5\", g /= h, o.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) && 1 !== h && --i)\n+                }\n+                return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c\n+            }]\n+        };\n \n-\t\t// Return the newly-formed element set\n-\t\treturn ret;\n-\t},\n+    function Sb() {\n+        return setTimeout(function() {\n+            Lb = void 0\n+        }), Lb = o.now()\n+    }\n \n-\t// Execute a callback for every element in the matched set.\n-\teach: function( callback ) {\n-\t\treturn jQuery.each( this, callback );\n-\t},\n+    function Tb(a, b) {\n+        var c, d = 0,\n+            e = {\n+                height: a\n+            };\n+        for (b = b ? 1 : 0; 4 > d; d += 2 - b) c = R[d], e[\"margin\" + c] = e[\"padding\" + c] = a;\n+        return b && (e.opacity = e.width = a), e\n+    }\n \n-\tmap: function( callback ) {\n-\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n-\t\t\treturn callback.call( elem, i, elem );\n-\t\t} ) );\n-\t},\n+    function Ub(a, b, c) {\n+        for (var d, e = (Rb[b] || []).concat(Rb[\"*\"]), f = 0, g = e.length; g > f; f++)\n+            if (d = e[f].call(c, b, a)) return d\n+    }\n \n-\tslice: function() {\n-\t\treturn this.pushStack( slice.apply( this, arguments ) );\n-\t},\n+    function Vb(a, b, c) {\n+        var d, e, f, g, h, i, j, k = this,\n+            l = {},\n+            m = a.style,\n+            n = a.nodeType && S(a),\n+            p = L.get(a, \"fxshow\");\n+        c.queue || (h = o._queueHooks(a, \"fx\"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function() {\n+            h.unqueued || i()\n+        }), h.unqueued++, k.always(function() {\n+            k.always(function() {\n+                h.unqueued--, o.queue(a, \"fx\").length || h.empty.fire()\n+            })\n+        })), 1 === a.nodeType && (\"height\" in b || \"width\" in b) && (c.overflow = [m.overflow, m.overflowX, m.overflowY], j = o.css(a, \"display\"), \"none\" === j && (j = tb(a.nodeName)), \"inline\" === j && \"none\" === o.css(a, \"float\") && (m.display = \"inline-block\")), c.overflow && (m.overflow = \"hidden\", k.always(function() {\n+            m.overflow = c.overflow[0], m.overflowX = c.overflow[1], m.overflowY = c.overflow[2]\n+        }));\n+        for (d in b)\n+            if (e = b[d], Nb.exec(e)) {\n+                if (delete b[d], f = f || \"toggle\" === e, e === (n ? \"hide\" : \"show\")) {\n+                    if (\"show\" !== e || !p || void 0 === p[d]) continue;\n+                    n = !0\n+                }\n+                l[d] = p && p[d] || o.style(a, d)\n+            }\n+        if (!o.isEmptyObject(l)) {\n+            p ? \"hidden\" in p && (n = p.hidden) : p = L.access(a, \"fxshow\", {}), f && (p.hidden = !n), n ? o(a).show() : k.done(function() {\n+                o(a).hide()\n+            }), k.done(function() {\n+                var b;\n+                L.remove(a, \"fxshow\");\n+                for (b in l) o.style(a, b, l[b])\n+            });\n+            for (d in l) g = Ub(n ? p[d] : 0, d, k), d in p || (p[d] = g.start, n && (g.end = g.start, g.start = \"width\" === d || \"height\" === d ? 1 : 0))\n+        }\n+    }\n \n-\tfirst: function() {\n-\t\treturn this.eq( 0 );\n-\t},\n+    function Wb(a, b) {\n+        var c, d, e, f, g;\n+        for (c in a)\n+            if (d = o.camelCase(c), e = b[d], f = a[c], o.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = o.cssHooks[d], g && \"expand\" in g) {\n+                f = g.expand(f), delete a[d];\n+                for (c in f) c in a || (a[c] = f[c], b[c] = e)\n+            } else b[d] = e\n+    }\n \n-\tlast: function() {\n-\t\treturn this.eq( -1 );\n-\t},\n+    function Xb(a, b, c) {\n+        var d, e, f = 0,\n+            g = Qb.length,\n+            h = o.Deferred().always(function() {\n+                delete i.elem\n+            }),\n+            i = function() {\n+                if (e) return !1;\n+                for (var b = Lb || Sb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);\n+                return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1)\n+            },\n+            j = h.promise({\n+                elem: a,\n+                props: o.extend({}, b),\n+                opts: o.extend(!0, {\n+                    specialEasing: {}\n+                }, c),\n+                originalProperties: b,\n+                originalOptions: c,\n+                startTime: Lb || Sb(),\n+                duration: c.duration,\n+                tweens: [],\n+                createTween: function(b, c) {\n+                    var d = o.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);\n+                    return j.tweens.push(d), d\n+                },\n+                stop: function(b) {\n+                    var c = 0,\n+                        d = b ? j.tweens.length : 0;\n+                    if (e) return this;\n+                    for (e = !0; d > c; c++) j.tweens[c].run(1);\n+                    return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this\n+                }\n+            }),\n+            k = j.props;\n+        for (Wb(k, j.opts.specialEasing); g > f; f++)\n+            if (d = Qb[f].call(j, a, k, j.opts)) return d;\n+        return o.map(k, Ub, j), o.isFunction(j.opts.start) && j.opts.start.call(a, j), o.fx.timer(o.extend(i, {\n+            elem: a,\n+            anim: j,\n+            queue: j.opts.queue\n+        })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)\n+    }\n+    o.Animation = o.extend(Xb, {\n+            tweener: function(a, b) {\n+                o.isFunction(a) ? (b = a, a = [\"*\"]) : a = a.split(\" \");\n+                for (var c, d = 0, e = a.length; e > d; d++) c = a[d], Rb[c] = Rb[c] || [], Rb[c].unshift(b)\n+            },\n+            prefilter: function(a, b) {\n+                b ? Qb.unshift(a) : Qb.push(a)\n+            }\n+        }), o.speed = function(a, b, c) {\n+            var d = a && \"object\" == typeof a ? o.extend({}, a) : {\n+                complete: c || !c && b || o.isFunction(a) && a,\n+                duration: a,\n+                easing: c && b || b && !o.isFunction(b) && b\n+            };\n+            return d.duration = o.fx.off ? 0 : \"number\" == typeof d.duration ? d.duration : d.duration in o.fx.speeds ? o.fx.speeds[d.duration] : o.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = \"fx\"), d.old = d.complete, d.complete = function() {\n+                o.isFunction(d.old) && d.old.call(this), d.queue && o.dequeue(this, d.queue)\n+            }, d\n+        }, o.fn.extend({\n+            fadeTo: function(a, b, c, d) {\n+                return this.filter(S).css(\"opacity\", 0).show().end().animate({\n+                    opacity: b\n+                }, a, c, d)\n+            },\n+            animate: function(a, b, c, d) {\n+                var e = o.isEmptyObject(a),\n+                    f = o.speed(b, c, d),\n+                    g = function() {\n+                        var b = Xb(this, o.extend({}, a), f);\n+                        (e || L.get(this, \"finish\")) && b.stop(!0)\n+                    };\n+                return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)\n+            },\n+            stop: function(a, b, c) {\n+                var d = function(a) {\n+                    var b = a.stop;\n+                    delete a.stop, b(c)\n+                };\n+                return \"string\" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || \"fx\", []), this.each(function() {\n+                    var b = !0,\n+                        e = null != a && a + \"queueHooks\",\n+                        f = o.timers,\n+                        g = L.get(this);\n+                    if (e) g[e] && g[e].stop && d(g[e]);\n+                    else\n+                        for (e in g) g[e] && g[e].stop && Pb.test(e) && d(g[e]);\n+                    for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));\n+                    (b || !c) && o.dequeue(this, a)\n+                })\n+            },\n+            finish: function(a) {\n+                return a !== !1 && (a = a || \"fx\"), this.each(function() {\n+                    var b, c = L.get(this),\n+                        d = c[a + \"queue\"],\n+                        e = c[a + \"queueHooks\"],\n+                        f = o.timers,\n+                        g = d ? d.length : 0;\n+                    for (c.finish = !0, o.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));\n+                    for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);\n+                    delete c.finish\n+                })\n+            }\n+        }), o.each([\"toggle\", \"show\", \"hide\"], function(a, b) {\n+            var c = o.fn[b];\n+            o.fn[b] = function(a, d, e) {\n+                return null == a || \"boolean\" == typeof a ? c.apply(this, arguments) : this.animate(Tb(b, !0), a, d, e)\n+            }\n+        }), o.each({\n+            slideDown: Tb(\"show\"),\n+            slideUp: Tb(\"hide\"),\n+            slideToggle: Tb(\"toggle\"),\n+            fadeIn: {\n+                opacity: \"show\"\n+            },\n+            fadeOut: {\n+                opacity: \"hide\"\n+            },\n+            fadeToggle: {\n+                opacity: \"toggle\"\n+            }\n+        }, function(a, b) {\n+            o.fn[a] = function(a, c, d) {\n+                return this.animate(b, a, c, d)\n+            }\n+        }), o.timers = [], o.fx.tick = function() {\n+            var a, b = 0,\n+                c = o.timers;\n+            for (Lb = o.now(); b < c.length; b++) a = c[b], a() || c[b] !== a || c.splice(b--, 1);\n+            c.length || o.fx.stop(), Lb = void 0\n+        }, o.fx.timer = function(a) {\n+            o.timers.push(a), a() ? o.fx.start() : o.timers.pop()\n+        }, o.fx.interval = 13, o.fx.start = function() {\n+            Mb || (Mb = setInterval(o.fx.tick, o.fx.interval))\n+        }, o.fx.stop = function() {\n+            clearInterval(Mb), Mb = null\n+        }, o.fx.speeds = {\n+            slow: 600,\n+            fast: 200,\n+            _default: 400\n+        }, o.fn.delay = function(a, b) {\n+            return a = o.fx ? o.fx.speeds[a] || a : a, b = b || \"fx\", this.queue(b, function(b, c) {\n+                var d = setTimeout(b, a);\n+                c.stop = function() {\n+                    clearTimeout(d)\n+                }\n+            })\n+        },\n+        function() {\n+            var a = m.createElement(\"input\"),\n+                b = m.createElement(\"select\"),\n+                c = b.appendChild(m.createElement(\"option\"));\n+            a.type = \"checkbox\", l.checkOn = \"\" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = m.createElement(\"input\"), a.value = \"t\", a.type = \"radio\", l.radioValue = \"t\" === a.value\n+        }();\n+    var Yb, Zb, $b = o.expr.attrHandle;\n+    o.fn.extend({\n+        attr: function(a, b) {\n+            return J(this, o.attr, a, b, arguments.length > 1)\n+        },\n+        removeAttr: function(a) {\n+            return this.each(function() {\n+                o.removeAttr(this, a)\n+            })\n+        }\n+    }), o.extend({\n+        attr: function(a, b, c) {\n+            var d, e, f = a.nodeType;\n+            if (a && 3 !== f && 8 !== f && 2 !== f) return typeof a.getAttribute === U ? o.prop(a, b, c) : (1 === f && o.isXMLDoc(a) || (b = b.toLowerCase(), d = o.attrHooks[b] || (o.expr.match.bool.test(b) ? Zb : Yb)), void 0 === c ? d && \"get\" in d && null !== (e = d.get(a, b)) ? e : (e = o.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d && \"set\" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + \"\"), c) : void o.removeAttr(a, b))\n+        },\n+        removeAttr: function(a, b) {\n+            var c, d, e = 0,\n+                f = b && b.match(E);\n+            if (f && 1 === a.nodeType)\n+                while (c = f[e++]) d = o.propFix[c] || c, o.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c)\n+        },\n+        attrHooks: {\n+            type: {\n+                set: function(a, b) {\n+                    if (!l.radioValue && \"radio\" === b && o.nodeName(a, \"input\")) {\n+                        var c = a.value;\n+                        return a.setAttribute(\"type\", b), c && (a.value = c), b\n+                    }\n+                }\n+            }\n+        }\n+    }), Zb = {\n+        set: function(a, b, c) {\n+            return b === !1 ? o.removeAttr(a, c) : a.setAttribute(c, c), c\n+        }\n+    }, o.each(o.expr.match.bool.source.match(/\\w+/g), function(a, b) {\n+        var c = $b[b] || o.find.attr;\n+        $b[b] = function(a, b, d) {\n+            var e, f;\n+            return d || (f = $b[b], $b[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, $b[b] = f), e\n+        }\n+    });\n+    var _b = /^(?:input|select|textarea|button)$/i;\n+    o.fn.extend({\n+        prop: function(a, b) {\n+            return J(this, o.prop, a, b, arguments.length > 1)\n+        },\n+        removeProp: function(a) {\n+            return this.each(function() {\n+                delete this[o.propFix[a] || a]\n+            })\n+        }\n+    }), o.extend({\n+        propFix: {\n+            \"for\": \"htmlFor\",\n+            \"class\": \"className\"\n+        },\n+        prop: function(a, b, c) {\n+            var d, e, f, g = a.nodeType;\n+            if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !o.isXMLDoc(a), f && (b = o.propFix[b] || b, e = o.propHooks[b]), void 0 !== c ? e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : a[b]\n+        },\n+        propHooks: {\n+            tabIndex: {\n+                get: function(a) {\n+                    return a.hasAttribute(\"tabindex\") || _b.test(a.nodeName) || a.href ? a.tabIndex : -1\n+                }\n+            }\n+        }\n+    }), l.optSelected || (o.propHooks.selected = {\n+        get: function(a) {\n+            var b = a.parentNode;\n+            return b && b.parentNode && b.parentNode.selectedIndex, null\n+        }\n+    }), o.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function() {\n+        o.propFix[this.toLowerCase()] = this\n+    });\n+    var ac = /[\\t\\r\\n\\f]/g;\n+    o.fn.extend({\n+        addClass: function(a) {\n+            var b, c, d, e, f, g, h = \"string\" == typeof a && a,\n+                i = 0,\n+                j = this.length;\n+            if (o.isFunction(a)) return this.each(function(b) {\n+                o(this).addClass(a.call(this, b, this.className))\n+            });\n+            if (h)\n+                for (b = (a || \"\").match(E) || []; j > i; i++)\n+                    if (c = this[i], d = 1 === c.nodeType && (c.className ? (\" \" + c.className + \" \").replace(ac, \" \") : \" \")) {\n+                        f = 0;\n+                        while (e = b[f++]) d.indexOf(\" \" + e + \" \") < 0 && (d += e + \" \");\n+                        g = o.trim(d), c.className !== g && (c.className = g)\n+                    }\n+            return this\n+        },\n+        removeClass: function(a) {\n+            var b, c, d, e, f, g, h = 0 === arguments.length || \"string\" == typeof a && a,\n+                i = 0,\n+                j = this.length;\n+            if (o.isFunction(a)) return this.each(function(b) {\n+                o(this).removeClass(a.call(this, b, this.className))\n+            });\n+            if (h)\n+                for (b = (a || \"\").match(E) || []; j > i; i++)\n+                    if (c = this[i], d = 1 === c.nodeType && (c.className ? (\" \" + c.className + \" \").replace(ac, \" \") : \"\")) {\n+                        f = 0;\n+                        while (e = b[f++])\n+                            while (d.indexOf(\" \" + e + \" \") >= 0) d = d.replace(\" \" + e + \" \", \" \");\n+                        g = a ? o.trim(d) : \"\", c.className !== g && (c.className = g)\n+                    }\n+            return this\n+        },\n+        toggleClass: function(a, b) {\n+            var c = typeof a;\n+            return \"boolean\" == typeof b && \"string\" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(o.isFunction(a) ? function(c) {\n+                o(this).toggleClass(a.call(this, c, this.className, b), b)\n+            } : function() {\n+                if (\"string\" === c) {\n+                    var b, d = 0,\n+                        e = o(this),\n+                        f = a.match(E) || [];\n+                    while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b)\n+                } else(c === U || \"boolean\" === c) && (this.className && L.set(this, \"__className__\", this.className), this.className = this.className || a === !1 ? \"\" : L.get(this, \"__className__\") || \"\")\n+            })\n+        },\n+        hasClass: function(a) {\n+            for (var b = \" \" + a + \" \", c = 0, d = this.length; d > c; c++)\n+                if (1 === this[c].nodeType && (\" \" + this[c].className + \" \").replace(ac, \" \").indexOf(b) >= 0) return !0;\n+            return !1\n+        }\n+    });\n+    var bc = /\\r/g;\n+    o.fn.extend({\n+        val: function(a) {\n+            var b, c, d, e = this[0]; {\n+                if (arguments.length) return d = o.isFunction(a), this.each(function(c) {\n+                    var e;\n+                    1 === this.nodeType && (e = d ? a.call(this, c, o(this).val()) : a, null == e ? e = \"\" : \"number\" == typeof e ? e += \"\" : o.isArray(e) && (e = o.map(e, function(a) {\n+                        return null == a ? \"\" : a + \"\"\n+                    })), b = o.valHooks[this.type] || o.valHooks[this.nodeName.toLowerCase()], b && \"set\" in b && void 0 !== b.set(this, e, \"value\") || (this.value = e))\n+                });\n+                if (e) return b = o.valHooks[e.type] || o.valHooks[e.nodeName.toLowerCase()], b && \"get\" in b && void 0 !== (c = b.get(e, \"value\")) ? c : (c = e.value, \"string\" == typeof c ? c.replace(bc, \"\") : null == c ? \"\" : c)\n+            }\n+        }\n+    }), o.extend({\n+        valHooks: {\n+            select: {\n+                get: function(a) {\n+                    for (var b, c, d = a.options, e = a.selectedIndex, f = \"select-one\" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)\n+                        if (c = d[i], !(!c.selected && i !== e || (l.optDisabled ? c.disabled : null !== c.getAttribute(\"disabled\")) || c.parentNode.disabled && o.nodeName(c.parentNode, \"optgroup\"))) {\n+                            if (b = o(c).val(), f) return b;\n+                            g.push(b)\n+                        }\n+                    return g\n+                },\n+                set: function(a, b) {\n+                    var c, d, e = a.options,\n+                        f = o.makeArray(b),\n+                        g = e.length;\n+                    while (g--) d = e[g], (d.selected = o.inArray(o(d).val(), f) >= 0) && (c = !0);\n+                    return c || (a.selectedIndex = -1), f\n+                }\n+            }\n+        }\n+    }), o.each([\"radio\", \"checkbox\"], function() {\n+        o.valHooks[this] = {\n+            set: function(a, b) {\n+                return o.isArray(b) ? a.checked = o.inArray(o(a).val(), b) >= 0 : void 0\n+            }\n+        }, l.checkOn || (o.valHooks[this].get = function(a) {\n+            return null === a.getAttribute(\"value\") ? \"on\" : a.value\n+        })\n+    }), o.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function(a, b) {\n+        o.fn[b] = function(a, c) {\n+            return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)\n+        }\n+    }), o.fn.extend({\n+        hover: function(a, b) {\n+            return this.mouseenter(a).mouseleave(b || a)\n+        },\n+        bind: function(a, b, c) {\n+            return this.on(a, null, b, c)\n+        },\n+        unbind: function(a, b) {\n+            return this.off(a, null, b)\n+        },\n+        delegate: function(a, b, c, d) {\n+            return this.on(b, a, c, d)\n+        },\n+        undelegate: function(a, b, c) {\n+            return 1 === arguments.length ? this.off(a, \"**\") : this.off(b, a || \"**\", c)\n+        }\n+    });\n+    var cc = o.now(),\n+        dc = /\\?/;\n+    o.parseJSON = function(a) {\n+        return JSON.parse(a + \"\")\n+    }, o.parseXML = function(a) {\n+        var b, c;\n+        if (!a || \"string\" != typeof a) return null;\n+        try {\n+            c = new DOMParser, b = c.parseFromString(a, \"text/xml\")\n+        } catch (d) {\n+            b = void 0\n+        }\n+        return (!b || b.getElementsByTagName(\"parsererror\").length) && o.error(\"Invalid XML: \" + a), b\n+    };\n+    var ec, fc, gc = /#.*$/,\n+        hc = /([?&])_=[^&]*/,\n+        ic = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n+        jc = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n+        kc = /^(?:GET|HEAD)$/,\n+        lc = /^\\/\\//,\n+        mc = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n+        nc = {},\n+        oc = {},\n+        pc = \"*/\".concat(\"*\");\n+    try {\n+        fc = location.href\n+    } catch (qc) {\n+        fc = m.createElement(\"a\"), fc.href = \"\", fc = fc.href\n+    }\n+    ec = mc.exec(fc.toLowerCase()) || [];\n \n-\teven: function() {\n-\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n-\t\t\treturn ( i + 1 ) % 2;\n-\t\t} ) );\n-\t},\n+    function rc(a) {\n+        return function(b, c) {\n+            \"string\" != typeof b && (c = b, b = \"*\");\n+            var d, e = 0,\n+                f = b.toLowerCase().match(E) || [];\n+            if (o.isFunction(c))\n+                while (d = f[e++]) \"+\" === d[0] ? (d = d.slice(1) || \"*\", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)\n+        }\n+    }\n \n-\todd: function() {\n-\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n-\t\t\treturn i % 2;\n-\t\t} ) );\n-\t},\n+    function sc(a, b, c, d) {\n+        var e = {},\n+            f = a === oc;\n \n-\teq: function( i ) {\n-\t\tvar len = this.length,\n-\t\t\tj = +i + ( i < 0 ? len : 0 );\n-\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n-\t},\n+        function g(h) {\n+            var i;\n+            return e[h] = !0, o.each(a[h] || [], function(a, h) {\n+                var j = h(b, c, d);\n+                return \"string\" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)\n+            }), i\n+        }\n+        return g(b.dataTypes[0]) || !e[\"*\"] && g(\"*\")\n+    }\n \n-\tend: function() {\n-\t\treturn this.prevObject || this.constructor();\n-\t},\n+    function tc(a, b) {\n+        var c, d, e = o.ajaxSettings.flatOptions || {};\n+        for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);\n+        return d && o.extend(!0, a, d), a\n+    }\n \n-\t// For internal use only.\n-\t// Behaves like an Array's method, not like a jQuery method.\n-\tpush: push,\n-\tsort: arr.sort,\n-\tsplice: arr.splice\n-};\n+    function uc(a, b, c) {\n+        var d, e, f, g, h = a.contents,\n+            i = a.dataTypes;\n+        while (\"*\" === i[0]) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader(\"Content-Type\"));\n+        if (d)\n+            for (e in h)\n+                if (h[e] && h[e].test(d)) {\n+                    i.unshift(e);\n+                    break\n+                }\n+        if (i[0] in c) f = i[0];\n+        else {\n+            for (e in c) {\n+                if (!i[0] || a.converters[e + \" \" + i[0]]) {\n+                    f = e;\n+                    break\n+                }\n+                g || (g = e)\n+            }\n+            f = f || g\n+        }\n+        return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0\n+    }\n \n-jQuery.extend = jQuery.fn.extend = function() {\n-\tvar options, name, src, copy, copyIsArray, clone,\n-\t\ttarget = arguments[ 0 ] || {},\n-\t\ti = 1,\n-\t\tlength = arguments.length,\n-\t\tdeep = false;\n+    function vc(a, b, c, d) {\n+        var e, f, g, h, i, j = {},\n+            k = a.dataTypes.slice();\n+        if (k[1])\n+            for (g in a.converters) j[g.toLowerCase()] = a.converters[g];\n+        f = k.shift();\n+        while (f)\n+            if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())\n+                if (\"*\" === f) f = i;\n+                else if (\"*\" !== i && i !== f) {\n+            if (g = j[i + \" \" + f] || j[\"* \" + f], !g)\n+                for (e in j)\n+                    if (h = e.split(\" \"), h[1] === f && (g = j[i + \" \" + h[0]] || j[\"* \" + h[0]])) {\n+                        g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));\n+                        break\n+                    }\n+            if (g !== !0)\n+                if (g && a[\"throws\"]) b = g(b);\n+                else try {\n+                    b = g(b)\n+                } catch (l) {\n+                    return {\n+                        state: \"parsererror\",\n+                        error: g ? l : \"No conversion from \" + i + \" to \" + f\n+                    }\n+                }\n+        }\n+        return {\n+            state: \"success\",\n+            data: b\n+        }\n+    }\n+    o.extend({\n+        active: 0,\n+        lastModified: {},\n+        etag: {},\n+        ajaxSettings: {\n+            url: fc,\n+            type: \"GET\",\n+            isLocal: jc.test(ec[1]),\n+            global: !0,\n+            processData: !0,\n+            async: !0,\n+            contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n+            accepts: {\n+                \"*\": pc,\n+                text: \"text/plain\",\n+                html: \"text/html\",\n+                xml: \"application/xml, text/xml\",\n+                json: \"application/json, text/javascript\"\n+            },\n+            contents: {\n+                xml: /xml/,\n+                html: /html/,\n+                json: /json/\n+            },\n+            responseFields: {\n+                xml: \"responseXML\",\n+                text: \"responseText\",\n+                json: \"responseJSON\"\n+            },\n+            converters: {\n+                \"* text\": String,\n+                \"text html\": !0,\n+                \"text json\": o.parseJSON,\n+                \"text xml\": o.parseXML\n+            },\n+            flatOptions: {\n+                url: !0,\n+                context: !0\n+            }\n+        },\n+        ajaxSetup: function(a, b) {\n+            return b ? tc(tc(a, o.ajaxSettings), b) : tc(o.ajaxSettings, a)\n+        },\n+        ajaxPrefilter: rc(nc),\n+        ajaxTransport: rc(oc),\n+        ajax: function(a, b) {\n+            \"object\" == typeof a && (b = a, a = void 0), b = b || {};\n+            var c, d, e, f, g, h, i, j, k = o.ajaxSetup({}, b),\n+                l = k.context || k,\n+                m = k.context && (l.nodeType || l.jquery) ? o(l) : o.event,\n+                n = o.Deferred(),\n+                p = o.Callbacks(\"once memory\"),\n+                q = k.statusCode || {},\n+                r = {},\n+                s = {},\n+                t = 0,\n+                u = \"canceled\",\n+                v = {\n+                    readyState: 0,\n+                    getResponseHeader: function(a) {\n+                        var b;\n+                        if (2 === t) {\n+                            if (!f) {\n+                                f = {};\n+                                while (b = ic.exec(e)) f[b[1].toLowerCase()] = b[2]\n+                            }\n+                            b = f[a.toLowerCase()]\n+                        }\n+                        return null == b ? null : b\n+                    },\n+                    getAllResponseHeaders: function() {\n+                        return 2 === t ? e : null\n+                    },\n+                    setRequestHeader: function(a, b) {\n+                        var c = a.toLowerCase();\n+                        return t || (a = s[c] = s[c] || a, r[a] = b), this\n+                    },\n+                    overrideMimeType: function(a) {\n+                        return t || (k.mimeType = a), this\n+                    },\n+                    statusCode: function(a) {\n+                        var b;\n+                        if (a)\n+                            if (2 > t)\n+                                for (b in a) q[b] = [q[b], a[b]];\n+                            else v.always(a[v.status]);\n+                        return this\n+                    },\n+                    abort: function(a) {\n+                        var b = a || u;\n+                        return c && c.abort(b), x(0, b), this\n+                    }\n+                };\n+            if (n.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || fc) + \"\").replace(gc, \"\").replace(lc, ec[1] + \"//\"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = o.trim(k.dataType || \"*\").toLowerCase().match(E) || [\"\"], null == k.crossDomain && (h = mc.exec(k.url.toLowerCase()), k.crossDomain = !(!h || h[1] === ec[1] && h[2] === ec[2] && (h[3] || (\"http:\" === h[1] ? \"80\" : \"443\")) === (ec[3] || (\"http:\" === ec[1] ? \"80\" : \"443\")))), k.data && k.processData && \"string\" != typeof k.data && (k.data = o.param(k.data, k.traditional)), sc(nc, k, b, v), 2 === t) return v;\n+            i = k.global, i && 0 === o.active++ && o.event.trigger(\"ajaxStart\"), k.type = k.type.toUpperCase(), k.hasContent = !kc.test(k.type), d = k.url, k.hasContent || (k.data && (d = k.url += (dc.test(d) ? \"&\" : \"?\") + k.data, delete k.data), k.cache === !1 && (k.url = hc.test(d) ? d.replace(hc, \"$1_=\" + cc++) : d + (dc.test(d) ? \"&\" : \"?\") + \"_=\" + cc++)), k.ifModified && (o.lastModified[d] && v.setRequestHeader(\"If-Modified-Since\", o.lastModified[d]), o.etag[d] && v.setRequestHeader(\"If-None-Match\", o.etag[d])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader(\"Content-Type\", k.contentType), v.setRequestHeader(\"Accept\", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + (\"*\" !== k.dataTypes[0] ? \", \" + pc + \"; q=0.01\" : \"\") : k.accepts[\"*\"]);\n+            for (j in k.headers) v.setRequestHeader(j, k.headers[j]);\n+            if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();\n+            u = \"abort\";\n+            for (j in {\n+                    success: 1,\n+                    error: 1,\n+                    complete: 1\n+                }) v[j](k[j]);\n+            if (c = sc(oc, k, b, v)) {\n+                v.readyState = 1, i && m.trigger(\"ajaxSend\", [v, k]), k.async && k.timeout > 0 && (g = setTimeout(function() {\n+                    v.abort(\"timeout\")\n+                }, k.timeout));\n+                try {\n+                    t = 1, c.send(r, x)\n+                } catch (w) {\n+                    if (!(2 > t)) throw w;\n+                    x(-1, w)\n+                }\n+            } else x(-1, \"No Transport\");\n \n-\t// Handle a deep copy situation\n-\tif ( typeof target === \"boolean\" ) {\n-\t\tdeep = target;\n+            function x(a, b, f, h) {\n+                var j, r, s, u, w, x = b;\n+                2 !== t && (t = 2, g && clearTimeout(g), c = void 0, e = h || \"\", v.readyState = a > 0 ? 4 : 0, j = a >= 200 && 300 > a || 304 === a, f && (u = uc(k, v, f)), u = vc(k, u, v, j), j ? (k.ifModified && (w = v.getResponseHeader(\"Last-Modified\"), w && (o.lastModified[d] = w), w = v.getResponseHeader(\"etag\"), w && (o.etag[d] = w)), 204 === a || \"HEAD\" === k.type ? x = \"nocontent\" : 304 === a ? x = \"notmodified\" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = \"error\", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + \"\", j ? n.resolveWith(l, [r, x, v]) : n.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, i && m.trigger(j ? \"ajaxSuccess\" : \"ajaxError\", [v, k, j ? r : s]), p.fireWith(l, [v, x]), i && (m.trigger(\"ajaxComplete\", [v, k]), --o.active || o.event.trigger(\"ajaxStop\")))\n+            }\n+            return v\n+        },\n+        getJSON: function(a, b, c) {\n+            return o.get(a, b, c, \"json\")\n+        },\n+        getScript: function(a, b) {\n+            return o.get(a, void 0, b, \"script\")\n+        }\n+    }), o.each([\"get\", \"post\"], function(a, b) {\n+        o[b] = function(a, c, d, e) {\n+            return o.isFunction(c) && (e = e || d, d = c, c = void 0), o.ajax({\n+                url: a,\n+                type: b,\n+                dataType: e,\n+                data: c,\n+                success: d\n+            })\n+        }\n+    }), o.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function(a, b) {\n+        o.fn[b] = function(a) {\n+            return this.on(b, a)\n+        }\n+    }), o._evalUrl = function(a) {\n+        return o.ajax({\n+            url: a,\n+            type: \"GET\",\n+            dataType: \"script\",\n+            async: !1,\n+            global: !1,\n+            \"throws\": !0\n+        })\n+    }, o.fn.extend({\n+        wrapAll: function(a) {\n+            var b;\n+            return o.isFunction(a) ? this.each(function(b) {\n+                o(this).wrapAll(a.call(this, b))\n+            }) : (this[0] && (b = o(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function() {\n+                var a = this;\n+                while (a.firstElementChild) a = a.firstElementChild;\n+                return a\n+            }).append(this)), this)\n+        },\n+        wrapInner: function(a) {\n+            return this.each(o.isFunction(a) ? function(b) {\n+                o(this).wrapInner(a.call(this, b))\n+            } : function() {\n+                var b = o(this),\n+                    c = b.contents();\n+                c.length ? c.wrapAll(a) : b.append(a)\n+            })\n+        },\n+        wrap: function(a) {\n+            var b = o.isFunction(a);\n+            return this.each(function(c) {\n+                o(this).wrapAll(b ? a.call(this, c) : a)\n+            })\n+        },\n+        unwrap: function() {\n+            return this.parent().each(function() {\n+                o.nodeName(this, \"body\") || o(this).replaceWith(this.childNodes)\n+            }).end()\n+        }\n+    }), o.expr.filters.hidden = function(a) {\n+        return a.offsetWidth <= 0 && a.offsetHeight <= 0\n+    }, o.expr.filters.visible = function(a) {\n+        return !o.expr.filters.hidden(a)\n+    };\n+    var wc = /%20/g,\n+        xc = /\\[\\]$/,\n+        yc = /\\r?\\n/g,\n+        zc = /^(?:submit|button|image|reset|file)$/i,\n+        Ac = /^(?:input|select|textarea|keygen)/i;\n \n-\t\t// Skip the boolean and the target\n-\t\ttarget = arguments[ i ] || {};\n-\t\ti++;\n-\t}\n+    function Bc(a, b, c, d) {\n+        var e;\n+        if (o.isArray(b)) o.each(b, function(b, e) {\n+            c || xc.test(a) ? d(a, e) : Bc(a + \"[\" + (\"object\" == typeof e ? b : \"\") + \"]\", e, c, d)\n+        });\n+        else if (c || \"object\" !== o.type(b)) d(a, b);\n+        else\n+            for (e in b) Bc(a + \"[\" + e + \"]\", b[e], c, d)\n+    }\n+    o.param = function(a, b) {\n+        var c, d = [],\n+            e = function(a, b) {\n+                b = o.isFunction(b) ? b() : null == b ? \"\" : b, d[d.length] = encodeURIComponent(a) + \"=\" + encodeURIComponent(b)\n+            };\n+        if (void 0 === b && (b = o.ajaxSettings && o.ajaxSettings.traditional), o.isArray(a) || a.jquery && !o.isPlainObject(a)) o.each(a, function() {\n+            e(this.name, this.value)\n+        });\n+        else\n+            for (c in a) Bc(c, a[c], b, e);\n+        return d.join(\"&\").replace(wc, \"+\")\n+    }, o.fn.extend({\n+        serialize: function() {\n+            return o.param(this.serializeArray())\n+        },\n+        serializeArray: function() {\n+            return this.map(function() {\n+                var a = o.prop(this, \"elements\");\n+                return a ? o.makeArray(a) : this\n+            }).filter(function() {\n+                var a = this.type;\n+                return this.name && !o(this).is(\":disabled\") && Ac.test(this.nodeName) && !zc.test(a) && (this.checked || !T.test(a))\n+            }).map(function(a, b) {\n+                var c = o(this).val();\n+                return null == c ? null : o.isArray(c) ? o.map(c, function(a) {\n+                    return {\n+                        name: b.name,\n+                        value: a.replace(yc, \"\\r\\n\")\n+                    }\n+                }) : {\n+                    name: b.name,\n+                    value: c.replace(yc, \"\\r\\n\")\n+                }\n+            }).get()\n+        }\n+    }), o.ajaxSettings.xhr = function() {\n+        try {\n+            return new XMLHttpRequest\n+        } catch (a) {}\n+    };\n+    var Cc = 0,\n+        Dc = {},\n+        Ec = {\n+            0: 200,\n+            1223: 204\n+        },\n+        Fc = o.ajaxSettings.xhr();\n+    a.ActiveXObject && o(a).on(\"unload\", function() {\n+        for (var a in Dc) Dc[a]()\n+    }), l.cors = !!Fc && \"withCredentials\" in Fc, l.ajax = Fc = !!Fc, o.ajaxTransport(function(a) {\n+        var b;\n+        return l.cors || Fc && !a.crossDomain ? {\n+            send: function(c, d) {\n+                var e, f = a.xhr(),\n+                    g = ++Cc;\n+                if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields)\n+                    for (e in a.xhrFields) f[e] = a.xhrFields[e];\n+                a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c[\"X-Requested-With\"] || (c[\"X-Requested-With\"] = \"XMLHttpRequest\");\n+                for (e in c) f.setRequestHeader(e, c[e]);\n+                b = function(a) {\n+                    return function() {\n+                        b && (delete Dc[g], b = f.onload = f.onerror = null, \"abort\" === a ? f.abort() : \"error\" === a ? d(f.status, f.statusText) : d(Ec[f.status] || f.status, f.statusText, \"string\" == typeof f.responseText ? {\n+                            text: f.responseText\n+                        } : void 0, f.getAllResponseHeaders()))\n+                    }\n+                }, f.onload = b(), f.onerror = b(\"error\"), b = Dc[g] = b(\"abort\"), f.send(a.hasContent && a.data || null)\n+            },\n+            abort: function() {\n+                b && b()\n+            }\n+        } : void 0\n+    }), o.ajaxSetup({\n+        accepts: {\n+            script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n+        },\n+        contents: {\n+            script: /(?:java|ecma)script/\n+        },\n+        converters: {\n+            \"text script\": function(a) {\n+                return o.globalEval(a), a\n+            }\n+        }\n+    }), o.ajaxPrefilter(\"script\", function(a) {\n+        void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = \"GET\")\n+    }), o.ajaxTransport(\"script\", function(a) {\n+        if (a.crossDomain) {\n+            var b, c;\n+            return {\n+                send: function(d, e) {\n+                    b = o(\"<script>\").prop({\n+                        async: !0,\n+                        charset: a.scriptCharset,\n+                        src: a.url\n+                    }).on(\"load error\", c = function(a) {\n+                        b.remove(), c = null, a && e(\"error\" === a.type ? 404 : 200, a.type)\n+                    }), m.head.appendChild(b[0])\n+                },\n+                abort: function() {\n+                    c && c()\n+                }\n+            }\n+        }\n+    });\n+    var Gc = [],\n+        Hc = /(=)\\?(?=&|$)|\\?\\?/;\n+    o.ajaxSetup({\n+        jsonp: \"callback\",\n+        jsonpCallback: function() {\n+            var a = Gc.pop() || o.expando + \"_\" + cc++;\n+            return this[a] = !0, a\n+        }\n+    }), o.ajaxPrefilter(\"json jsonp\", function(b, c, d) {\n+        var e, f, g, h = b.jsonp !== !1 && (Hc.test(b.url) ? \"url\" : \"string\" == typeof b.data && !(b.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && Hc.test(b.data) && \"data\");\n+        return h || \"jsonp\" === b.dataTypes[0] ? (e = b.jsonpCallback = o.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Hc, \"$1\" + e) : b.jsonp !== !1 && (b.url += (dc.test(b.url) ? \"&\" : \"?\") + b.jsonp + \"=\" + e), b.converters[\"script json\"] = function() {\n+            return g || o.error(e + \" was not called\"), g[0]\n+        }, b.dataTypes[0] = \"json\", f = a[e], a[e] = function() {\n+            g = arguments\n+        }, d.always(function() {\n+            a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Gc.push(e)), g && o.isFunction(f) && f(g[0]), g = f = void 0\n+        }), \"script\") : void 0\n+    }), o.parseHTML = function(a, b, c) {\n+        if (!a || \"string\" != typeof a) return null;\n+        \"boolean\" == typeof b && (c = b, b = !1), b = b || m;\n+        var d = v.exec(a),\n+            e = !c && [];\n+        return d ? [b.createElement(d[1])] : (d = o.buildFragment([a], b, e), e && e.length && o(e).remove(), o.merge([], d.childNodes))\n+    };\n+    var Ic = o.fn.load;\n+    o.fn.load = function(a, b, c) {\n+        if (\"string\" != typeof a && Ic) return Ic.apply(this, arguments);\n+        var d, e, f, g = this,\n+            h = a.indexOf(\" \");\n+        return h >= 0 && (d = a.slice(h), a = a.slice(0, h)), o.isFunction(b) ? (c = b, b = void 0) : b && \"object\" == typeof b && (e = \"POST\"), g.length > 0 && o.ajax({\n+            url: a,\n+            type: e,\n+            dataType: \"html\",\n+            data: b\n+        }).done(function(a) {\n+            f = arguments, g.html(d ? o(\"<div>\").append(o.parseHTML(a)).find(d) : a)\n+        }).complete(c && function(a, b) {\n+            g.each(c, f || [a.responseText, b, a])\n+        }), this\n+    }, o.expr.filters.animated = function(a) {\n+        return o.grep(o.timers, function(b) {\n+            return a === b.elem\n+        }).length\n+    };\n+    var Jc = a.document.documentElement;\n \n-\t// Handle case when target is a string or something (possible in deep copy)\n-\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n-\t\ttarget = {};\n-\t}\n-\n-\t// Extend jQuery itself if only one argument is passed\n-\tif ( i === length ) {\n-\t\ttarget = this;\n-\t\ti--;\n-\t}\n-\n-\tfor ( ; i < length; i++ ) {\n-\n-\t\t// Only deal with non-null/undefined values\n-\t\tif ( ( options = arguments[ i ] ) != null ) {\n-\n-\t\t\t// Extend the base object\n-\t\t\tfor ( name in options ) {\n-\t\t\t\tcopy = options[ name ];\n-\n-\t\t\t\t// Prevent Object.prototype pollution\n-\t\t\t\t// Prevent never-ending loop\n-\t\t\t\tif ( name === \"__proto__\" || target === copy ) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\n-\t\t\t\t// Recurse if we're merging plain objects or arrays\n-\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n-\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n-\t\t\t\t\tsrc = target[ name ];\n-\n-\t\t\t\t\t// Ensure proper type for the source value\n-\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n-\t\t\t\t\t\tclone = [];\n-\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n-\t\t\t\t\t\tclone = {};\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tclone = src;\n-\t\t\t\t\t}\n-\t\t\t\t\tcopyIsArray = false;\n-\n-\t\t\t\t\t// Never move original objects, clone them\n-\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n-\n-\t\t\t\t// Don't bring in undefined values\n-\t\t\t\t} else if ( copy !== undefined ) {\n-\t\t\t\t\ttarget[ name ] = copy;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Return the modified object\n-\treturn target;\n-};\n-\n-jQuery.extend( {\n-\n-\t// Unique for each copy of jQuery on the page\n-\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n-\n-\t// Assume jQuery is ready without the ready module\n-\tisReady: true,\n-\n-\terror: function( msg ) {\n-\t\tthrow new Error( msg );\n-\t},\n-\n-\tnoop: function() {},\n-\n-\tisPlainObject: function( obj ) {\n-\t\tvar proto, Ctor;\n-\n-\t\t// Detect obvious negatives\n-\t\t// Use toString instead of jQuery.type to catch host objects\n-\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tproto = getProto( obj );\n-\n-\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n-\t\tif ( !proto ) {\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n-\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n-\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n-\t},\n-\n-\tisEmptyObject: function( obj ) {\n-\t\tvar name;\n-\n-\t\tfor ( name in obj ) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t},\n-\n-\t// Evaluates a script in a provided context; falls back to the global one\n-\t// if not specified.\n-\tglobalEval: function( code, options, doc ) {\n-\t\tDOMEval( code, { nonce: options && options.nonce }, doc );\n-\t},\n-\n-\teach: function( obj, callback ) {\n-\t\tvar length, i = 0;\n-\n-\t\tif ( isArrayLike( obj ) ) {\n-\t\t\tlength = obj.length;\n-\t\t\tfor ( ; i < length; i++ ) {\n-\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tfor ( i in obj ) {\n-\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn obj;\n-\t},\n-\n-\t// results is for internal usage only\n-\tmakeArray: function( arr, results ) {\n-\t\tvar ret = results || [];\n-\n-\t\tif ( arr != null ) {\n-\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n-\t\t\t\tjQuery.merge( ret,\n-\t\t\t\t\ttypeof arr === \"string\" ?\n-\t\t\t\t\t\t[ arr ] : arr\n-\t\t\t\t);\n-\t\t\t} else {\n-\t\t\t\tpush.call( ret, arr );\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn ret;\n-\t},\n-\n-\tinArray: function( elem, arr, i ) {\n-\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n-\t},\n-\n-\t// Support: Android <=4.0 only, PhantomJS 1 only\n-\t// push.apply(_, arraylike) throws on ancient WebKit\n-\tmerge: function( first, second ) {\n-\t\tvar len = +second.length,\n-\t\t\tj = 0,\n-\t\t\ti = first.length;\n-\n-\t\tfor ( ; j < len; j++ ) {\n-\t\t\tfirst[ i++ ] = second[ j ];\n-\t\t}\n-\n-\t\tfirst.length = i;\n-\n-\t\treturn first;\n-\t},\n-\n-\tgrep: function( elems, callback, invert ) {\n-\t\tvar callbackInverse,\n-\t\t\tmatches = [],\n-\t\t\ti = 0,\n-\t\t\tlength = elems.length,\n-\t\t\tcallbackExpect = !invert;\n-\n-\t\t// Go through the array, only saving the items\n-\t\t// that pass the validator function\n-\t\tfor ( ; i < length; i++ ) {\n-\t\t\tcallbackInverse = !callback( elems[ i ], i );\n-\t\t\tif ( callbackInverse !== callbackExpect ) {\n-\t\t\t\tmatches.push( elems[ i ] );\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn matches;\n-\t},\n-\n-\t// arg is for internal usage only\n-\tmap: function( elems, callback, arg ) {\n-\t\tvar length, value,\n-\t\t\ti = 0,\n-\t\t\tret = [];\n-\n-\t\t// Go through the array, translating each of the items to their new values\n-\t\tif ( isArrayLike( elems ) ) {\n-\t\t\tlength = elems.length;\n-\t\t\tfor ( ; i < length; i++ ) {\n-\t\t\t\tvalue = callback( elems[ i ], i, arg );\n-\n-\t\t\t\tif ( value != null ) {\n-\t\t\t\t\tret.push( value );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t// Go through every key on the object,\n-\t\t} else {\n-\t\t\tfor ( i in elems ) {\n-\t\t\t\tvalue = callback( elems[ i ], i, arg );\n-\n-\t\t\t\tif ( value != null ) {\n-\t\t\t\t\tret.push( value );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Flatten any nested arrays\n-\t\treturn flat( ret );\n-\t},\n-\n-\t// A global GUID counter for objects\n-\tguid: 1,\n-\n-\t// jQuery.support is not used in Core but other projects attach their\n-\t// properties to it so it needs to exist.\n-\tsupport: support\n-} );\n-\n-if ( typeof Symbol === \"function\" ) {\n-\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n-}\n-\n-// Populate the class2type map\n-jQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\n-\tfunction( _i, name ) {\n-\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n-\t} );\n-\n-function isArrayLike( obj ) {\n-\n-\t// Support: real iOS 8.2 only (not reproducible in simulator)\n-\t// `in` check used to prevent JIT error (gh-2145)\n-\t// hasOwn isn't used here due to false negatives\n-\t// regarding Nodelist length in IE\n-\tvar length = !!obj && \"length\" in obj && obj.length,\n-\t\ttype = toType( obj );\n-\n-\tif ( isFunction( obj ) || isWindow( obj ) ) {\n-\t\treturn false;\n-\t}\n-\n-\treturn type === \"array\" || length === 0 ||\n-\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n-}\n-var Sizzle =\n-/*!\n- * Sizzle CSS Selector Engine v2.3.9\n- * https://sizzlejs.com/\n- *\n- * Copyright JS Foundation and other contributors\n- * Released under the MIT license\n- * https://js.foundation/\n- *\n- * Date: 2022-12-19\n- */\n-( function( window ) {\n-var i,\n-\tsupport,\n-\tExpr,\n-\tgetText,\n-\tisXML,\n-\ttokenize,\n-\tcompile,\n-\tselect,\n-\toutermostContext,\n-\tsortInput,\n-\thasDuplicate,\n-\n-\t// Local document vars\n-\tsetDocument,\n-\tdocument,\n-\tdocElem,\n-\tdocumentIsHTML,\n-\trbuggyQSA,\n-\trbuggyMatches,\n-\tmatches,\n-\tcontains,\n-\n-\t// Instance-specific data\n-\texpando = \"sizzle\" + 1 * new Date(),\n-\tpreferredDoc = window.document,\n-\tdirruns = 0,\n-\tdone = 0,\n-\tclassCache = createCache(),\n-\ttokenCache = createCache(),\n-\tcompilerCache = createCache(),\n-\tnonnativeSelectorCache = createCache(),\n-\tsortOrder = function( a, b ) {\n-\t\tif ( a === b ) {\n-\t\t\thasDuplicate = true;\n-\t\t}\n-\t\treturn 0;\n-\t},\n-\n-\t// Instance methods\n-\thasOwn = ( {} ).hasOwnProperty,\n-\tarr = [],\n-\tpop = arr.pop,\n-\tpushNative = arr.push,\n-\tpush = arr.push,\n-\tslice = arr.slice,\n-\n-\t// Use a stripped-down indexOf as it's faster than native\n-\t// https://jsperf.com/thor-indexof-vs-for/5\n-\tindexOf = function( list, elem ) {\n-\t\tvar i = 0,\n-\t\t\tlen = list.length;\n-\t\tfor ( ; i < len; i++ ) {\n-\t\t\tif ( list[ i ] === elem ) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\t\treturn -1;\n-\t},\n-\n-\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" +\n-\t\t\"ismap|loop|multiple|open|readonly|required|scoped\",\n-\n-\t// Regular expressions\n-\n-\t// http://www.w3.org/TR/css3-selectors/#whitespace\n-\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n-\n-\t// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n-\tidentifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace +\n-\t\t\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n-\n-\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n-\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n-\n-\t\t// Operator (capture 2)\n-\t\t\"*([*^$|!~]?=)\" + whitespace +\n-\n-\t\t// \"Attribute values must be CSS identifiers [capture 5]\n-\t\t// or strings [capture 3 or capture 4]\"\n-\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" +\n-\t\twhitespace + \"*\\\\]\",\n-\n-\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n-\n-\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n-\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n-\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n-\n-\t\t// 2. simple (capture 6)\n-\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n-\n-\t\t// 3. anything else (capture 2)\n-\t\t\".*\" +\n-\t\t\")\\\\)|)\",\n-\n-\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n-\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n-\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" +\n-\t\twhitespace + \"+$\", \"g\" ),\n-\n-\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n-\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace +\n-\t\t\"*\" ),\n-\trdescend = new RegExp( whitespace + \"|>\" ),\n-\n-\trpseudo = new RegExp( pseudos ),\n-\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n-\n-\tmatchExpr = {\n-\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n-\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n-\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n-\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n-\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n-\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" +\n-\t\t\twhitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" +\n-\t\t\twhitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n-\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n-\n-\t\t// For use in libraries implementing .is()\n-\t\t// We use this for POS matching in `select`\n-\t\t\"needsContext\": new RegExp( \"^\" + whitespace +\n-\t\t\t\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace +\n-\t\t\t\"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n-\t},\n-\n-\trhtml = /HTML$/i,\n-\trinputs = /^(?:input|select|textarea|button)$/i,\n-\trheader = /^h\\d$/i,\n-\n-\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n-\n-\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n-\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n-\n-\trsibling = /[+~]/,\n-\n-\t// CSS escapes\n-\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n-\trunescape = new RegExp( \"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\" ),\n-\tfunescape = function( escape, nonHex ) {\n-\t\tvar high = \"0x\" + escape.slice( 1 ) - 0x10000;\n-\n-\t\treturn nonHex ?\n-\n-\t\t\t// Strip the backslash prefix from a non-hex escape sequence\n-\t\t\tnonHex :\n-\n-\t\t\t// Replace a hexadecimal escape sequence with the encoded Unicode code point\n-\t\t\t// Support: IE <=11+\n-\t\t\t// For values outside the Basic Multilingual Plane (BMP), manually construct a\n-\t\t\t// surrogate pair\n-\t\t\thigh < 0 ?\n-\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n-\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n-\t},\n-\n-\t// CSS string/identifier serialization\n-\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n-\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n-\tfcssescape = function( ch, asCodePoint ) {\n-\t\tif ( asCodePoint ) {\n-\n-\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n-\t\t\tif ( ch === \"\\0\" ) {\n-\t\t\t\treturn \"\\uFFFD\";\n-\t\t\t}\n-\n-\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n-\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" +\n-\t\t\t\tch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n-\t\t}\n-\n-\t\t// Other potentially-special ASCII characters get backslash-escaped\n-\t\treturn \"\\\\\" + ch;\n-\t},\n-\n-\t// Used for iframes\n-\t// See setDocument()\n-\t// Removing the function wrapper causes a \"Permission Denied\"\n-\t// error in IE\n-\tunloadHandler = function() {\n-\t\tsetDocument();\n-\t},\n-\n-\tinDisabledFieldset = addCombinator(\n-\t\tfunction( elem ) {\n-\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n-\t\t},\n-\t\t{ dir: \"parentNode\", next: \"legend\" }\n-\t);\n-\n-// Optimize for push.apply( _, NodeList )\n-try {\n-\tpush.apply(\n-\t\t( arr = slice.call( preferredDoc.childNodes ) ),\n-\t\tpreferredDoc.childNodes\n-\t);\n-\n-\t// Support: Android<4.0\n-\t// Detect silently failing push.apply\n-\t// eslint-disable-next-line no-unused-expressions\n-\tarr[ preferredDoc.childNodes.length ].nodeType;\n-} catch ( e ) {\n-\tpush = { apply: arr.length ?\n-\n-\t\t// Leverage slice if possible\n-\t\tfunction( target, els ) {\n-\t\t\tpushNative.apply( target, slice.call( els ) );\n-\t\t} :\n-\n-\t\t// Support: IE<9\n-\t\t// Otherwise append directly\n-\t\tfunction( target, els ) {\n-\t\t\tvar j = target.length,\n-\t\t\t\ti = 0;\n-\n-\t\t\t// Can't trust NodeList.length\n-\t\t\twhile ( ( target[ j++ ] = els[ i++ ] ) ) {}\n-\t\t\ttarget.length = j - 1;\n-\t\t}\n-\t};\n-}\n-\n-function Sizzle( selector, context, results, seed ) {\n-\tvar m, i, elem, nid, match, groups, newSelector,\n-\t\tnewContext = context && context.ownerDocument,\n-\n-\t\t// nodeType defaults to 9, since context defaults to document\n-\t\tnodeType = context ? context.nodeType : 9;\n-\n-\tresults = results || [];\n-\n-\t// Return early from calls with invalid selector or context\n-\tif ( typeof selector !== \"string\" || !selector ||\n-\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n-\n-\t\treturn results;\n-\t}\n-\n-\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n-\tif ( !seed ) {\n-\t\tsetDocument( context );\n-\t\tcontext = context || document;\n-\n-\t\tif ( documentIsHTML ) {\n-\n-\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n-\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n-\t\t\tif ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {\n-\n-\t\t\t\t// ID selector\n-\t\t\t\tif ( ( m = match[ 1 ] ) ) {\n-\n-\t\t\t\t\t// Document context\n-\t\t\t\t\tif ( nodeType === 9 ) {\n-\t\t\t\t\t\tif ( ( elem = context.getElementById( m ) ) ) {\n-\n-\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n-\t\t\t\t\t\t\t// TODO: identify versions\n-\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n-\t\t\t\t\t\t\tif ( elem.id === m ) {\n-\t\t\t\t\t\t\t\tresults.push( elem );\n-\t\t\t\t\t\t\t\treturn results;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\treturn results;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t// Element context\n-\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t// Support: IE, Opera, Webkit\n-\t\t\t\t\t\t// TODO: identify versions\n-\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n-\t\t\t\t\t\tif ( newContext && ( elem = newContext.getElementById( m ) ) &&\n-\t\t\t\t\t\t\tcontains( context, elem ) &&\n-\t\t\t\t\t\t\telem.id === m ) {\n-\n-\t\t\t\t\t\t\tresults.push( elem );\n-\t\t\t\t\t\t\treturn results;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t// Type selector\n-\t\t\t\t} else if ( match[ 2 ] ) {\n-\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n-\t\t\t\t\treturn results;\n-\n-\t\t\t\t// Class selector\n-\t\t\t\t} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&\n-\t\t\t\t\tcontext.getElementsByClassName ) {\n-\n-\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n-\t\t\t\t\treturn results;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Take advantage of querySelectorAll\n-\t\t\tif ( support.qsa &&\n-\t\t\t\t!nonnativeSelectorCache[ selector + \" \" ] &&\n-\t\t\t\t( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&\n-\n-\t\t\t\t// Support: IE 8 only\n-\t\t\t\t// Exclude object elements\n-\t\t\t\t( nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\" ) ) {\n-\n-\t\t\t\tnewSelector = selector;\n-\t\t\t\tnewContext = context;\n-\n-\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n-\t\t\t\t// descendant combinators, which is not what we want.\n-\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n-\t\t\t\t// list with an ID selector referencing the scope context.\n-\t\t\t\t// The technique has to be used as well when a leading combinator is used\n-\t\t\t\t// as such selectors are not recognized by querySelectorAll.\n-\t\t\t\t// Thanks to Andrew Dupont for this technique.\n-\t\t\t\tif ( nodeType === 1 &&\n-\t\t\t\t\t( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {\n-\n-\t\t\t\t\t// Expand context for sibling selectors\n-\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n-\t\t\t\t\t\tcontext;\n-\n-\t\t\t\t\t// We can use :scope instead of the ID hack if the browser\n-\t\t\t\t\t// supports it & if we're not changing the context.\n-\t\t\t\t\tif ( newContext !== context || !support.scope ) {\n-\n-\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n-\t\t\t\t\t\tif ( ( nid = context.getAttribute( \"id\" ) ) ) {\n-\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tcontext.setAttribute( \"id\", ( nid = expando ) );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Prefix every selector in the list\n-\t\t\t\t\tgroups = tokenize( selector );\n-\t\t\t\t\ti = groups.length;\n-\t\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\t\tgroups[ i ] = ( nid ? \"#\" + nid : \":scope\" ) + \" \" +\n-\t\t\t\t\t\t\ttoSelector( groups[ i ] );\n-\t\t\t\t\t}\n-\t\t\t\t\tnewSelector = groups.join( \",\" );\n-\t\t\t\t}\n-\n-\t\t\t\ttry {\n-\n-\t\t\t\t\t// `qSA` may not throw for unrecognized parts using forgiving parsing:\n-\t\t\t\t\t// https://drafts.csswg.org/selectors/#forgiving-selector\n-\t\t\t\t\t// like the `:has()` pseudo-class:\n-\t\t\t\t\t// https://drafts.csswg.org/selectors/#relational\n-\t\t\t\t\t// `CSS.supports` is still expected to return `false` then:\n-\t\t\t\t\t// https://drafts.csswg.org/css-conditional-4/#typedef-supports-selector-fn\n-\t\t\t\t\t// https://drafts.csswg.org/css-conditional-4/#dfn-support-selector\n-\t\t\t\t\tif ( support.cssSupportsSelector &&\n-\n-\t\t\t\t\t\t// eslint-disable-next-line no-undef\n-\t\t\t\t\t\t!CSS.supports( \"selector(:is(\" + newSelector + \"))\" ) ) {\n-\n-\t\t\t\t\t\t// Support: IE 11+\n-\t\t\t\t\t\t// Throw to get to the same code path as an error directly in qSA.\n-\t\t\t\t\t\t// Note: once we only support browser supporting\n-\t\t\t\t\t\t// `CSS.supports('selector(...)')`, we can most likely drop\n-\t\t\t\t\t\t// the `try-catch`. IE doesn't implement the API.\n-\t\t\t\t\t\tthrow new Error();\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tpush.apply( results,\n-\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n-\t\t\t\t\t);\n-\t\t\t\t\treturn results;\n-\t\t\t\t} catch ( qsaError ) {\n-\t\t\t\t\tnonnativeSelectorCache( selector, true );\n-\t\t\t\t} finally {\n-\t\t\t\t\tif ( nid === expando ) {\n-\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// All others\n-\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n-}\n-\n-/**\n- * Create key-value caches of limited size\n- * @returns {function(string, object)} Returns the Object data after storing it on itself with\n- *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n- *\tdeleting the oldest entry\n- */\n-function createCache() {\n-\tvar keys = [];\n-\n-\tfunction cache( key, value ) {\n-\n-\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n-\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n-\n-\t\t\t// Only keep the most recent entries\n-\t\t\tdelete cache[ keys.shift() ];\n-\t\t}\n-\t\treturn ( cache[ key + \" \" ] = value );\n-\t}\n-\treturn cache;\n-}\n-\n-/**\n- * Mark a function for special use by Sizzle\n- * @param {Function} fn The function to mark\n- */\n-function markFunction( fn ) {\n-\tfn[ expando ] = true;\n-\treturn fn;\n-}\n-\n-/**\n- * Support testing using an element\n- * @param {Function} fn Passed the created element and returns a boolean result\n- */\n-function assert( fn ) {\n-\tvar el = document.createElement( \"fieldset\" );\n-\n-\ttry {\n-\t\treturn !!fn( el );\n-\t} catch ( e ) {\n-\t\treturn false;\n-\t} finally {\n-\n-\t\t// Remove from its parent by default\n-\t\tif ( el.parentNode ) {\n-\t\t\tel.parentNode.removeChild( el );\n-\t\t}\n-\n-\t\t// release memory in IE\n-\t\tel = null;\n-\t}\n-}\n-\n-/**\n- * Adds the same handler for all of the specified attrs\n- * @param {String} attrs Pipe-separated list of attributes\n- * @param {Function} handler The method that will be applied\n- */\n-function addHandle( attrs, handler ) {\n-\tvar arr = attrs.split( \"|\" ),\n-\t\ti = arr.length;\n-\n-\twhile ( i-- ) {\n-\t\tExpr.attrHandle[ arr[ i ] ] = handler;\n-\t}\n-}\n-\n-/**\n- * Checks document order of two siblings\n- * @param {Element} a\n- * @param {Element} b\n- * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n- */\n-function siblingCheck( a, b ) {\n-\tvar cur = b && a,\n-\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n-\t\t\ta.sourceIndex - b.sourceIndex;\n-\n-\t// Use IE sourceIndex if available on both nodes\n-\tif ( diff ) {\n-\t\treturn diff;\n-\t}\n-\n-\t// Check if b follows a\n-\tif ( cur ) {\n-\t\twhile ( ( cur = cur.nextSibling ) ) {\n-\t\t\tif ( cur === b ) {\n-\t\t\t\treturn -1;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn a ? 1 : -1;\n-}\n-\n-/**\n- * Returns a function to use in pseudos for input types\n- * @param {String} type\n- */\n-function createInputPseudo( type ) {\n-\treturn function( elem ) {\n-\t\tvar name = elem.nodeName.toLowerCase();\n-\t\treturn name === \"input\" && elem.type === type;\n-\t};\n-}\n-\n-/**\n- * Returns a function to use in pseudos for buttons\n- * @param {String} type\n- */\n-function createButtonPseudo( type ) {\n-\treturn function( elem ) {\n-\t\tvar name = elem.nodeName.toLowerCase();\n-\t\treturn ( name === \"input\" || name === \"button\" ) && elem.type === type;\n-\t};\n-}\n-\n-/**\n- * Returns a function to use in pseudos for :enabled/:disabled\n- * @param {Boolean} disabled true for :disabled; false for :enabled\n- */\n-function createDisabledPseudo( disabled ) {\n-\n-\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n-\treturn function( elem ) {\n-\n-\t\t// Only certain elements can match :enabled or :disabled\n-\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n-\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n-\t\tif ( \"form\" in elem ) {\n-\n-\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n-\t\t\t// * listed form-associated elements in a disabled fieldset\n-\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n-\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n-\t\t\t// * option elements in a disabled optgroup\n-\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n-\t\t\t// All such elements have a \"form\" property.\n-\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n-\n-\t\t\t\t// Option elements defer to a parent optgroup if present\n-\t\t\t\tif ( \"label\" in elem ) {\n-\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n-\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\treturn elem.disabled === disabled;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// Support: IE 6 - 11\n-\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n-\t\t\t\treturn elem.isDisabled === disabled ||\n-\n-\t\t\t\t\t// Where there is no isDisabled, check manually\n-\t\t\t\t\t/* jshint -W018 */\n-\t\t\t\t\telem.isDisabled !== !disabled &&\n-\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n-\t\t\t}\n-\n-\t\t\treturn elem.disabled === disabled;\n-\n-\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n-\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n-\t\t// even exist on them, let alone have a boolean value.\n-\t\t} else if ( \"label\" in elem ) {\n-\t\t\treturn elem.disabled === disabled;\n-\t\t}\n-\n-\t\t// Remaining elements are neither :enabled nor :disabled\n-\t\treturn false;\n-\t};\n-}\n-\n-/**\n- * Returns a function to use in pseudos for positionals\n- * @param {Function} fn\n- */\n-function createPositionalPseudo( fn ) {\n-\treturn markFunction( function( argument ) {\n-\t\targument = +argument;\n-\t\treturn markFunction( function( seed, matches ) {\n-\t\t\tvar j,\n-\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n-\t\t\t\ti = matchIndexes.length;\n-\n-\t\t\t// Match elements found at the specified indexes\n-\t\t\twhile ( i-- ) {\n-\t\t\t\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\n-\t\t\t\t\tseed[ j ] = !( matches[ j ] = seed[ j ] );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} );\n-\t} );\n-}\n-\n-/**\n- * Checks a node for validity as a Sizzle context\n- * @param {Element|Object=} context\n- * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n- */\n-function testContext( context ) {\n-\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n-}\n-\n-// Expose support vars for convenience\n-support = Sizzle.support = {};\n-\n-/**\n- * Detects XML nodes\n- * @param {Element|Object} elem An element or a document\n- * @returns {Boolean} True iff elem is a non-HTML XML node\n- */\n-isXML = Sizzle.isXML = function( elem ) {\n-\tvar namespace = elem && elem.namespaceURI,\n-\t\tdocElem = elem && ( elem.ownerDocument || elem ).documentElement;\n-\n-\t// Support: IE <=8\n-\t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n-\t// https://bugs.jquery.com/ticket/4833\n-\treturn !rhtml.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n-};\n-\n-/**\n- * Sets document-related variables once based on the current document\n- * @param {Element|Object} [doc] An element or document object to use to set the document\n- * @returns {Object} Returns the current document\n- */\n-setDocument = Sizzle.setDocument = function( node ) {\n-\tvar hasCompare, subWindow,\n-\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n-\n-\t// Return early if doc is invalid or already selected\n-\t// Support: IE 11+, Edge 17 - 18+\n-\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t// two documents; shallow comparisons work.\n-\t// eslint-disable-next-line eqeqeq\n-\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\n-\t\treturn document;\n-\t}\n-\n-\t// Update global variables\n-\tdocument = doc;\n-\tdocElem = document.documentElement;\n-\tdocumentIsHTML = !isXML( document );\n-\n-\t// Support: IE 9 - 11+, Edge 12 - 18+\n-\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n-\t// Support: IE 11+, Edge 17 - 18+\n-\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t// two documents; shallow comparisons work.\n-\t// eslint-disable-next-line eqeqeq\n-\tif ( preferredDoc != document &&\n-\t\t( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {\n-\n-\t\t// Support: IE 11, Edge\n-\t\tif ( subWindow.addEventListener ) {\n-\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n-\n-\t\t// Support: IE 9 - 10 only\n-\t\t} else if ( subWindow.attachEvent ) {\n-\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n-\t\t}\n-\t}\n-\n-\t// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n-\t// Safari 4 - 5 only, Opera <=11.6 - 12.x only\n-\t// IE/Edge & older browsers don't support the :scope pseudo-class.\n-\t// Support: Safari 6.0 only\n-\t// Safari 6.0 supports :scope but it's an alias of :root there.\n-\tsupport.scope = assert( function( el ) {\n-\t\tdocElem.appendChild( el ).appendChild( document.createElement( \"div\" ) );\n-\t\treturn typeof el.querySelectorAll !== \"undefined\" &&\n-\t\t\t!el.querySelectorAll( \":scope fieldset div\" ).length;\n-\t} );\n-\n-\t// Support: Chrome 105+, Firefox 104+, Safari 15.4+\n-\t// Make sure forgiving mode is not used in `CSS.supports( \"selector(...)\" )`.\n-\t//\n-\t// `:is()` uses a forgiving selector list as an argument and is widely\n-\t// implemented, so it's a good one to test against.\n-\tsupport.cssSupportsSelector = assert( function() {\n-\t\t/* eslint-disable no-undef */\n-\n-\t\treturn CSS.supports( \"selector(*)\" ) &&\n-\n-\t\t\t// Support: Firefox 78-81 only\n-\t\t\t// In old Firefox, `:is()` didn't use forgiving parsing. In that case,\n-\t\t\t// fail this test as there's no selector to test against that.\n-\t\t\t// `CSS.supports` uses unforgiving parsing\n-\t\t\tdocument.querySelectorAll( \":is(:jqfake)\" ) &&\n-\n-\t\t\t// `*` is needed as Safari & newer Chrome implemented something in between\n-\t\t\t// for `:has()` - it throws in `qSA` if it only contains an unsupported\n-\t\t\t// argument but multiple ones, one of which is supported, are fine.\n-\t\t\t// We want to play safe in case `:is()` gets the same treatment.\n-\t\t\t!CSS.supports( \"selector(:is(*,:jqfake))\" );\n-\n-\t\t/* eslint-enable */\n-\t} );\n-\n-\t/* Attributes\n-\t---------------------------------------------------------------------- */\n-\n-\t// Support: IE<8\n-\t// Verify that getAttribute really returns attributes and not properties\n-\t// (excepting IE8 booleans)\n-\tsupport.attributes = assert( function( el ) {\n-\t\tel.className = \"i\";\n-\t\treturn !el.getAttribute( \"className\" );\n-\t} );\n-\n-\t/* getElement(s)By*\n-\t---------------------------------------------------------------------- */\n-\n-\t// Check if getElementsByTagName(\"*\") returns only elements\n-\tsupport.getElementsByTagName = assert( function( el ) {\n-\t\tel.appendChild( document.createComment( \"\" ) );\n-\t\treturn !el.getElementsByTagName( \"*\" ).length;\n-\t} );\n-\n-\t// Support: IE<9\n-\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n-\n-\t// Support: IE<10\n-\t// Check if getElementById returns elements by name\n-\t// The broken getElementById methods don't pick up programmatically-set names,\n-\t// so use a roundabout getElementsByName test\n-\tsupport.getById = assert( function( el ) {\n-\t\tdocElem.appendChild( el ).id = expando;\n-\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n-\t} );\n-\n-\t// ID filter and find\n-\tif ( support.getById ) {\n-\t\tExpr.filter[ \"ID\" ] = function( id ) {\n-\t\t\tvar attrId = id.replace( runescape, funescape );\n-\t\t\treturn function( elem ) {\n-\t\t\t\treturn elem.getAttribute( \"id\" ) === attrId;\n-\t\t\t};\n-\t\t};\n-\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n-\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n-\t\t\t\tvar elem = context.getElementById( id );\n-\t\t\t\treturn elem ? [ elem ] : [];\n-\t\t\t}\n-\t\t};\n-\t} else {\n-\t\tExpr.filter[ \"ID\" ] =  function( id ) {\n-\t\t\tvar attrId = id.replace( runescape, funescape );\n-\t\t\treturn function( elem ) {\n-\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n-\t\t\t\t\telem.getAttributeNode( \"id\" );\n-\t\t\t\treturn node && node.value === attrId;\n-\t\t\t};\n-\t\t};\n-\n-\t\t// Support: IE 6 - 7 only\n-\t\t// getElementById is not reliable as a find shortcut\n-\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n-\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n-\t\t\t\tvar node, i, elems,\n-\t\t\t\t\telem = context.getElementById( id );\n-\n-\t\t\t\tif ( elem ) {\n-\n-\t\t\t\t\t// Verify the id attribute\n-\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n-\t\t\t\t\tif ( node && node.value === id ) {\n-\t\t\t\t\t\treturn [ elem ];\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Fall back on getElementsByName\n-\t\t\t\t\telems = context.getElementsByName( id );\n-\t\t\t\t\ti = 0;\n-\t\t\t\t\twhile ( ( elem = elems[ i++ ] ) ) {\n-\t\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n-\t\t\t\t\t\tif ( node && node.value === id ) {\n-\t\t\t\t\t\t\treturn [ elem ];\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\treturn [];\n-\t\t\t}\n-\t\t};\n-\t}\n-\n-\t// Tag\n-\tExpr.find[ \"TAG\" ] = support.getElementsByTagName ?\n-\t\tfunction( tag, context ) {\n-\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n-\t\t\t\treturn context.getElementsByTagName( tag );\n-\n-\t\t\t// DocumentFragment nodes don't have gEBTN\n-\t\t\t} else if ( support.qsa ) {\n-\t\t\t\treturn context.querySelectorAll( tag );\n-\t\t\t}\n-\t\t} :\n-\n-\t\tfunction( tag, context ) {\n-\t\t\tvar elem,\n-\t\t\t\ttmp = [],\n-\t\t\t\ti = 0,\n-\n-\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n-\t\t\t\tresults = context.getElementsByTagName( tag );\n-\n-\t\t\t// Filter out possible comments\n-\t\t\tif ( tag === \"*\" ) {\n-\t\t\t\twhile ( ( elem = results[ i++ ] ) ) {\n-\t\t\t\t\tif ( elem.nodeType === 1 ) {\n-\t\t\t\t\t\ttmp.push( elem );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\treturn tmp;\n-\t\t\t}\n-\t\t\treturn results;\n-\t\t};\n-\n-\t// Class\n-\tExpr.find[ \"CLASS\" ] = support.getElementsByClassName && function( className, context ) {\n-\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n-\t\t\treturn context.getElementsByClassName( className );\n-\t\t}\n-\t};\n-\n-\t/* QSA/matchesSelector\n-\t---------------------------------------------------------------------- */\n-\n-\t// QSA and matchesSelector support\n-\n-\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n-\trbuggyMatches = [];\n-\n-\t// qSa(:focus) reports false when true (Chrome 21)\n-\t// We allow this because of a bug in IE8/9 that throws an error\n-\t// whenever `document.activeElement` is accessed on an iframe\n-\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n-\t// See https://bugs.jquery.com/ticket/13378\n-\trbuggyQSA = [];\n-\n-\tif ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {\n-\n-\t\t// Build QSA regex\n-\t\t// Regex strategy adopted from Diego Perini\n-\t\tassert( function( el ) {\n-\n-\t\t\tvar input;\n-\n-\t\t\t// Select is set to empty string on purpose\n-\t\t\t// This is to test IE's treatment of not explicitly\n-\t\t\t// setting a boolean content attribute,\n-\t\t\t// since its presence should be enough\n-\t\t\t// https://bugs.jquery.com/ticket/12359\n-\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n-\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n-\t\t\t\t\"<option selected=''></option></select>\";\n-\n-\t\t\t// Support: IE8, Opera 11-12.16\n-\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n-\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n-\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n-\t\t\tif ( el.querySelectorAll( \"[msallowcapture^='']\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n-\t\t\t}\n-\n-\t\t\t// Support: IE8\n-\t\t\t// Boolean attributes and \"value\" are not treated correctly\n-\t\t\tif ( !el.querySelectorAll( \"[selected]\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n-\t\t\t}\n-\n-\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n-\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \"~=\" );\n-\t\t\t}\n-\n-\t\t\t// Support: IE 11+, Edge 15 - 18+\n-\t\t\t// IE 11/Edge don't find elements on a `[name='']` query in some cases.\n-\t\t\t// Adding a temporary attribute to the document before the selection works\n-\t\t\t// around the issue.\n-\t\t\t// Interestingly, IE 10 & older don't seem to have the issue.\n-\t\t\tinput = document.createElement( \"input\" );\n-\t\t\tinput.setAttribute( \"name\", \"\" );\n-\t\t\tel.appendChild( input );\n-\t\t\tif ( !el.querySelectorAll( \"[name='']\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" +\n-\t\t\t\t\twhitespace + \"*(?:''|\\\"\\\")\" );\n-\t\t\t}\n-\n-\t\t\t// Webkit/Opera - :checked should return selected option elements\n-\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n-\t\t\t// IE8 throws error here and will not see later tests\n-\t\t\tif ( !el.querySelectorAll( \":checked\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \":checked\" );\n-\t\t\t}\n-\n-\t\t\t// Support: Safari 8+, iOS 8+\n-\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n-\t\t\t// In-page `selector#id sibling-combinator selector` fails\n-\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \".#.+[+~]\" );\n-\t\t\t}\n-\n-\t\t\t// Support: Firefox <=3.6 - 5 only\n-\t\t\t// Old Firefox doesn't throw on a badly-escaped identifier.\n-\t\t\tel.querySelectorAll( \"\\\\\\f\" );\n-\t\t\trbuggyQSA.push( \"[\\\\r\\\\n\\\\f]\" );\n-\t\t} );\n-\n-\t\tassert( function( el ) {\n-\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n-\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n-\n-\t\t\t// Support: Windows 8 Native Apps\n-\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n-\t\t\tvar input = document.createElement( \"input\" );\n-\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n-\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n-\n-\t\t\t// Support: IE8\n-\t\t\t// Enforce case-sensitivity of name attribute\n-\t\t\tif ( el.querySelectorAll( \"[name=d]\" ).length ) {\n-\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n-\t\t\t}\n-\n-\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n-\t\t\t// IE8 throws error here and will not see later tests\n-\t\t\tif ( el.querySelectorAll( \":enabled\" ).length !== 2 ) {\n-\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n-\t\t\t}\n-\n-\t\t\t// Support: IE9-11+\n-\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n-\t\t\tdocElem.appendChild( el ).disabled = true;\n-\t\t\tif ( el.querySelectorAll( \":disabled\" ).length !== 2 ) {\n-\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n-\t\t\t}\n-\n-\t\t\t// Support: Opera 10 - 11 only\n-\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n-\t\t\tel.querySelectorAll( \"*,:x\" );\n-\t\t\trbuggyQSA.push( \",.*:\" );\n-\t\t} );\n-\t}\n-\n-\tif ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||\n-\t\tdocElem.webkitMatchesSelector ||\n-\t\tdocElem.mozMatchesSelector ||\n-\t\tdocElem.oMatchesSelector ||\n-\t\tdocElem.msMatchesSelector ) ) ) ) {\n-\n-\t\tassert( function( el ) {\n-\n-\t\t\t// Check to see if it's possible to do matchesSelector\n-\t\t\t// on a disconnected node (IE 9)\n-\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n-\n-\t\t\t// This should fail with an exception\n-\t\t\t// Gecko does not error, returns false instead\n-\t\t\tmatches.call( el, \"[s!='']:x\" );\n-\t\t\trbuggyMatches.push( \"!=\", pseudos );\n-\t\t} );\n-\t}\n-\n-\tif ( !support.cssSupportsSelector ) {\n-\n-\t\t// Support: Chrome 105+, Safari 15.4+\n-\t\t// `:has()` uses a forgiving selector list as an argument so our regular\n-\t\t// `try-catch` mechanism fails to catch `:has()` with arguments not supported\n-\t\t// natively like `:has(:contains(\"Foo\"))`. Where supported & spec-compliant,\n-\t\t// we now use `CSS.supports(\"selector(:is(SELECTOR_TO_BE_TESTED))\")`, but\n-\t\t// outside that we mark `:has` as buggy.\n-\t\trbuggyQSA.push( \":has\" );\n-\t}\n-\n-\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( \"|\" ) );\n-\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( \"|\" ) );\n-\n-\t/* Contains\n-\t---------------------------------------------------------------------- */\n-\thasCompare = rnative.test( docElem.compareDocumentPosition );\n-\n-\t// Element contains another\n-\t// Purposefully self-exclusive\n-\t// As in, an element does not contain itself\n-\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n-\t\tfunction( a, b ) {\n-\n-\t\t\t// Support: IE <9 only\n-\t\t\t// IE doesn't have `contains` on `document` so we need to check for\n-\t\t\t// `documentElement` presence.\n-\t\t\t// We need to fall back to `a` when `documentElement` is missing\n-\t\t\t// as `ownerDocument` of elements within `<template/>` may have\n-\t\t\t// a null one - a default behavior of all modern browsers.\n-\t\t\tvar adown = a.nodeType === 9 && a.documentElement || a,\n-\t\t\t\tbup = b && b.parentNode;\n-\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n-\t\t\t\tadown.contains ?\n-\t\t\t\t\tadown.contains( bup ) :\n-\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n-\t\t\t) );\n-\t\t} :\n-\t\tfunction( a, b ) {\n-\t\t\tif ( b ) {\n-\t\t\t\twhile ( ( b = b.parentNode ) ) {\n-\t\t\t\t\tif ( b === a ) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t};\n-\n-\t/* Sorting\n-\t---------------------------------------------------------------------- */\n-\n-\t// Document order sorting\n-\tsortOrder = hasCompare ?\n-\tfunction( a, b ) {\n-\n-\t\t// Flag for duplicate removal\n-\t\tif ( a === b ) {\n-\t\t\thasDuplicate = true;\n-\t\t\treturn 0;\n-\t\t}\n-\n-\t\t// Sort on method existence if only one input has compareDocumentPosition\n-\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n-\t\tif ( compare ) {\n-\t\t\treturn compare;\n-\t\t}\n-\n-\t\t// Calculate position if both inputs belong to the same document\n-\t\t// Support: IE 11+, Edge 17 - 18+\n-\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t// two documents; shallow comparisons work.\n-\t\t// eslint-disable-next-line eqeqeq\n-\t\tcompare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?\n-\t\t\ta.compareDocumentPosition( b ) :\n-\n-\t\t\t// Otherwise we know they are disconnected\n-\t\t\t1;\n-\n-\t\t// Disconnected nodes\n-\t\tif ( compare & 1 ||\n-\t\t\t( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {\n-\n-\t\t\t// Choose the first element that is related to our preferred document\n-\t\t\t// Support: IE 11+, Edge 17 - 18+\n-\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\t// two documents; shallow comparisons work.\n-\t\t\t// eslint-disable-next-line eqeqeq\n-\t\t\tif ( a == document || a.ownerDocument == preferredDoc &&\n-\t\t\t\tcontains( preferredDoc, a ) ) {\n-\t\t\t\treturn -1;\n-\t\t\t}\n-\n-\t\t\t// Support: IE 11+, Edge 17 - 18+\n-\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\t// two documents; shallow comparisons work.\n-\t\t\t// eslint-disable-next-line eqeqeq\n-\t\t\tif ( b == document || b.ownerDocument == preferredDoc &&\n-\t\t\t\tcontains( preferredDoc, b ) ) {\n-\t\t\t\treturn 1;\n-\t\t\t}\n-\n-\t\t\t// Maintain original order\n-\t\t\treturn sortInput ?\n-\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n-\t\t\t\t0;\n-\t\t}\n-\n-\t\treturn compare & 4 ? -1 : 1;\n-\t} :\n-\tfunction( a, b ) {\n-\n-\t\t// Exit early if the nodes are identical\n-\t\tif ( a === b ) {\n-\t\t\thasDuplicate = true;\n-\t\t\treturn 0;\n-\t\t}\n-\n-\t\tvar cur,\n-\t\t\ti = 0,\n-\t\t\taup = a.parentNode,\n-\t\t\tbup = b.parentNode,\n-\t\t\tap = [ a ],\n-\t\t\tbp = [ b ];\n-\n-\t\t// Parentless nodes are either documents or disconnected\n-\t\tif ( !aup || !bup ) {\n-\n-\t\t\t// Support: IE 11+, Edge 17 - 18+\n-\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\t// two documents; shallow comparisons work.\n-\t\t\t/* eslint-disable eqeqeq */\n-\t\t\treturn a == document ? -1 :\n-\t\t\t\tb == document ? 1 :\n-\t\t\t\t/* eslint-enable eqeqeq */\n-\t\t\t\taup ? -1 :\n-\t\t\t\tbup ? 1 :\n-\t\t\t\tsortInput ?\n-\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n-\t\t\t\t0;\n-\n-\t\t// If the nodes are siblings, we can do a quick check\n-\t\t} else if ( aup === bup ) {\n-\t\t\treturn siblingCheck( a, b );\n-\t\t}\n-\n-\t\t// Otherwise we need full lists of their ancestors for comparison\n-\t\tcur = a;\n-\t\twhile ( ( cur = cur.parentNode ) ) {\n-\t\t\tap.unshift( cur );\n-\t\t}\n-\t\tcur = b;\n-\t\twhile ( ( cur = cur.parentNode ) ) {\n-\t\t\tbp.unshift( cur );\n-\t\t}\n-\n-\t\t// Walk down the tree looking for a discrepancy\n-\t\twhile ( ap[ i ] === bp[ i ] ) {\n-\t\t\ti++;\n-\t\t}\n-\n-\t\treturn i ?\n-\n-\t\t\t// Do a sibling check if the nodes have a common ancestor\n-\t\t\tsiblingCheck( ap[ i ], bp[ i ] ) :\n-\n-\t\t\t// Otherwise nodes in our document sort first\n-\t\t\t// Support: IE 11+, Edge 17 - 18+\n-\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\t// two documents; shallow comparisons work.\n-\t\t\t/* eslint-disable eqeqeq */\n-\t\t\tap[ i ] == preferredDoc ? -1 :\n-\t\t\tbp[ i ] == preferredDoc ? 1 :\n-\t\t\t/* eslint-enable eqeqeq */\n-\t\t\t0;\n-\t};\n-\n-\treturn document;\n-};\n-\n-Sizzle.matches = function( expr, elements ) {\n-\treturn Sizzle( expr, null, null, elements );\n-};\n-\n-Sizzle.matchesSelector = function( elem, expr ) {\n-\tsetDocument( elem );\n-\n-\tif ( support.matchesSelector && documentIsHTML &&\n-\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n-\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n-\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n-\n-\t\ttry {\n-\t\t\tvar ret = matches.call( elem, expr );\n-\n-\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n-\t\t\tif ( ret || support.disconnectedMatch ||\n-\n-\t\t\t\t// As well, disconnected nodes are said to be in a document\n-\t\t\t\t// fragment in IE 9\n-\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n-\t\t\t\treturn ret;\n-\t\t\t}\n-\t\t} catch ( e ) {\n-\t\t\tnonnativeSelectorCache( expr, true );\n-\t\t}\n-\t}\n-\n-\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n-};\n-\n-Sizzle.contains = function( context, elem ) {\n-\n-\t// Set document vars if needed\n-\t// Support: IE 11+, Edge 17 - 18+\n-\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t// two documents; shallow comparisons work.\n-\t// eslint-disable-next-line eqeqeq\n-\tif ( ( context.ownerDocument || context ) != document ) {\n-\t\tsetDocument( context );\n-\t}\n-\treturn contains( context, elem );\n-};\n-\n-Sizzle.attr = function( elem, name ) {\n-\n-\t// Set document vars if needed\n-\t// Support: IE 11+, Edge 17 - 18+\n-\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t// two documents; shallow comparisons work.\n-\t// eslint-disable-next-line eqeqeq\n-\tif ( ( elem.ownerDocument || elem ) != document ) {\n-\t\tsetDocument( elem );\n-\t}\n-\n-\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n-\n-\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n-\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n-\t\t\tfn( elem, name, !documentIsHTML ) :\n-\t\t\tundefined;\n-\n-\treturn val !== undefined ?\n-\t\tval :\n-\t\tsupport.attributes || !documentIsHTML ?\n-\t\t\telem.getAttribute( name ) :\n-\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n-\t\t\t\tval.value :\n-\t\t\t\tnull;\n-};\n-\n-Sizzle.escape = function( sel ) {\n-\treturn ( sel + \"\" ).replace( rcssescape, fcssescape );\n-};\n-\n-Sizzle.error = function( msg ) {\n-\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n-};\n-\n-/**\n- * Document sorting and removing duplicates\n- * @param {ArrayLike} results\n- */\n-Sizzle.uniqueSort = function( results ) {\n-\tvar elem,\n-\t\tduplicates = [],\n-\t\tj = 0,\n-\t\ti = 0;\n-\n-\t// Unless we *know* we can detect duplicates, assume their presence\n-\thasDuplicate = !support.detectDuplicates;\n-\tsortInput = !support.sortStable && results.slice( 0 );\n-\tresults.sort( sortOrder );\n-\n-\tif ( hasDuplicate ) {\n-\t\twhile ( ( elem = results[ i++ ] ) ) {\n-\t\t\tif ( elem === results[ i ] ) {\n-\t\t\t\tj = duplicates.push( i );\n-\t\t\t}\n-\t\t}\n-\t\twhile ( j-- ) {\n-\t\t\tresults.splice( duplicates[ j ], 1 );\n-\t\t}\n-\t}\n-\n-\t// Clear input after sorting to release objects\n-\t// See https://github.com/jquery/sizzle/pull/225\n-\tsortInput = null;\n-\n-\treturn results;\n-};\n-\n-/**\n- * Utility function for retrieving the text value of an array of DOM nodes\n- * @param {Array|Element} elem\n- */\n-getText = Sizzle.getText = function( elem ) {\n-\tvar node,\n-\t\tret = \"\",\n-\t\ti = 0,\n-\t\tnodeType = elem.nodeType;\n-\n-\tif ( !nodeType ) {\n-\n-\t\t// If no nodeType, this is expected to be an array\n-\t\twhile ( ( node = elem[ i++ ] ) ) {\n-\n-\t\t\t// Do not traverse comment nodes\n-\t\t\tret += getText( node );\n-\t\t}\n-\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n-\n-\t\t// Use textContent for elements\n-\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n-\t\tif ( typeof elem.textContent === \"string\" ) {\n-\t\t\treturn elem.textContent;\n-\t\t} else {\n-\n-\t\t\t// Traverse its children\n-\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n-\t\t\t\tret += getText( elem );\n-\t\t\t}\n-\t\t}\n-\t} else if ( nodeType === 3 || nodeType === 4 ) {\n-\t\treturn elem.nodeValue;\n-\t}\n-\n-\t// Do not include comment or processing instruction nodes\n-\n-\treturn ret;\n-};\n-\n-Expr = Sizzle.selectors = {\n-\n-\t// Can be adjusted by the user\n-\tcacheLength: 50,\n-\n-\tcreatePseudo: markFunction,\n-\n-\tmatch: matchExpr,\n-\n-\tattrHandle: {},\n-\n-\tfind: {},\n-\n-\trelative: {\n-\t\t\">\": { dir: \"parentNode\", first: true },\n-\t\t\" \": { dir: \"parentNode\" },\n-\t\t\"+\": { dir: \"previousSibling\", first: true },\n-\t\t\"~\": { dir: \"previousSibling\" }\n-\t},\n-\n-\tpreFilter: {\n-\t\t\"ATTR\": function( match ) {\n-\t\t\tmatch[ 1 ] = match[ 1 ].replace( runescape, funescape );\n-\n-\t\t\t// Move the given value to match[3] whether quoted or unquoted\n-\t\t\tmatch[ 3 ] = ( match[ 3 ] || match[ 4 ] ||\n-\t\t\t\tmatch[ 5 ] || \"\" ).replace( runescape, funescape );\n-\n-\t\t\tif ( match[ 2 ] === \"~=\" ) {\n-\t\t\t\tmatch[ 3 ] = \" \" + match[ 3 ] + \" \";\n-\t\t\t}\n-\n-\t\t\treturn match.slice( 0, 4 );\n-\t\t},\n-\n-\t\t\"CHILD\": function( match ) {\n-\n-\t\t\t/* matches from matchExpr[\"CHILD\"]\n-\t\t\t\t1 type (only|nth|...)\n-\t\t\t\t2 what (child|of-type)\n-\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n-\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n-\t\t\t\t5 sign of xn-component\n-\t\t\t\t6 x of xn-component\n-\t\t\t\t7 sign of y-component\n-\t\t\t\t8 y of y-component\n-\t\t\t*/\n-\t\t\tmatch[ 1 ] = match[ 1 ].toLowerCase();\n-\n-\t\t\tif ( match[ 1 ].slice( 0, 3 ) === \"nth\" ) {\n-\n-\t\t\t\t// nth-* requires argument\n-\t\t\t\tif ( !match[ 3 ] ) {\n-\t\t\t\t\tSizzle.error( match[ 0 ] );\n-\t\t\t\t}\n-\n-\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n-\t\t\t\t// remember that false/true cast respectively to 0/1\n-\t\t\t\tmatch[ 4 ] = +( match[ 4 ] ?\n-\t\t\t\t\tmatch[ 5 ] + ( match[ 6 ] || 1 ) :\n-\t\t\t\t\t2 * ( match[ 3 ] === \"even\" || match[ 3 ] === \"odd\" ) );\n-\t\t\t\tmatch[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === \"odd\" );\n-\n-\t\t\t\t// other types prohibit arguments\n-\t\t\t} else if ( match[ 3 ] ) {\n-\t\t\t\tSizzle.error( match[ 0 ] );\n-\t\t\t}\n-\n-\t\t\treturn match;\n-\t\t},\n-\n-\t\t\"PSEUDO\": function( match ) {\n-\t\t\tvar excess,\n-\t\t\t\tunquoted = !match[ 6 ] && match[ 2 ];\n-\n-\t\t\tif ( matchExpr[ \"CHILD\" ].test( match[ 0 ] ) ) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\t// Accept quoted arguments as-is\n-\t\t\tif ( match[ 3 ] ) {\n-\t\t\t\tmatch[ 2 ] = match[ 4 ] || match[ 5 ] || \"\";\n-\n-\t\t\t// Strip excess characters from unquoted arguments\n-\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n-\n-\t\t\t\t// Get excess from tokenize (recursively)\n-\t\t\t\t( excess = tokenize( unquoted, true ) ) &&\n-\n-\t\t\t\t// advance to the next closing parenthesis\n-\t\t\t\t( excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length ) ) {\n-\n-\t\t\t\t// excess is a negative index\n-\t\t\t\tmatch[ 0 ] = match[ 0 ].slice( 0, excess );\n-\t\t\t\tmatch[ 2 ] = unquoted.slice( 0, excess );\n-\t\t\t}\n-\n-\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n-\t\t\treturn match.slice( 0, 3 );\n-\t\t}\n-\t},\n-\n-\tfilter: {\n-\n-\t\t\"TAG\": function( nodeNameSelector ) {\n-\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n-\t\t\treturn nodeNameSelector === \"*\" ?\n-\t\t\t\tfunction() {\n-\t\t\t\t\treturn true;\n-\t\t\t\t} :\n-\t\t\t\tfunction( elem ) {\n-\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n-\t\t\t\t};\n-\t\t},\n-\n-\t\t\"CLASS\": function( className ) {\n-\t\t\tvar pattern = classCache[ className + \" \" ];\n-\n-\t\t\treturn pattern ||\n-\t\t\t\t( pattern = new RegExp( \"(^|\" + whitespace +\n-\t\t\t\t\t\")\" + className + \"(\" + whitespace + \"|$)\" ) ) && classCache(\n-\t\t\t\t\t\tclassName, function( elem ) {\n-\t\t\t\t\t\t\treturn pattern.test(\n-\t\t\t\t\t\t\t\ttypeof elem.className === \"string\" && elem.className ||\n-\t\t\t\t\t\t\t\ttypeof elem.getAttribute !== \"undefined\" &&\n-\t\t\t\t\t\t\t\t\telem.getAttribute( \"class\" ) ||\n-\t\t\t\t\t\t\t\t\"\"\n-\t\t\t\t\t\t\t);\n-\t\t\t\t} );\n-\t\t},\n-\n-\t\t\"ATTR\": function( name, operator, check ) {\n-\t\t\treturn function( elem ) {\n-\t\t\t\tvar result = Sizzle.attr( elem, name );\n-\n-\t\t\t\tif ( result == null ) {\n-\t\t\t\t\treturn operator === \"!=\";\n-\t\t\t\t}\n-\t\t\t\tif ( !operator ) {\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\n-\t\t\t\tresult += \"\";\n-\n-\t\t\t\t/* eslint-disable max-len */\n-\n-\t\t\t\treturn operator === \"=\" ? result === check :\n-\t\t\t\t\toperator === \"!=\" ? result !== check :\n-\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n-\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n-\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n-\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n-\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n-\t\t\t\t\tfalse;\n-\t\t\t\t/* eslint-enable max-len */\n-\n-\t\t\t};\n-\t\t},\n-\n-\t\t\"CHILD\": function( type, what, _argument, first, last ) {\n-\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n-\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n-\t\t\t\tofType = what === \"of-type\";\n-\n-\t\t\treturn first === 1 && last === 0 ?\n-\n-\t\t\t\t// Shortcut for :nth-*(n)\n-\t\t\t\tfunction( elem ) {\n-\t\t\t\t\treturn !!elem.parentNode;\n-\t\t\t\t} :\n-\n-\t\t\t\tfunction( elem, _context, xml ) {\n-\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n-\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n-\t\t\t\t\t\tparent = elem.parentNode,\n-\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n-\t\t\t\t\t\tuseCache = !xml && !ofType,\n-\t\t\t\t\t\tdiff = false;\n-\n-\t\t\t\t\tif ( parent ) {\n-\n-\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n-\t\t\t\t\t\tif ( simple ) {\n-\t\t\t\t\t\t\twhile ( dir ) {\n-\t\t\t\t\t\t\t\tnode = elem;\n-\t\t\t\t\t\t\t\twhile ( ( node = node[ dir ] ) ) {\n-\t\t\t\t\t\t\t\t\tif ( ofType ?\n-\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n-\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n-\n-\t\t\t\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n-\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n-\n-\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n-\t\t\t\t\t\tif ( forward && useCache ) {\n-\n-\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n-\n-\t\t\t\t\t\t\t// ...in a gzip-friendly way\n-\t\t\t\t\t\t\tnode = parent;\n-\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n-\n-\t\t\t\t\t\t\t// Support: IE <9 only\n-\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n-\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n-\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n-\n-\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n-\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n-\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n-\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n-\n-\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n-\n-\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n-\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n-\n-\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n-\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n-\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t// Use previously-cached element index if available\n-\t\t\t\t\t\t\tif ( useCache ) {\n-\n-\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n-\t\t\t\t\t\t\t\tnode = elem;\n-\t\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n-\n-\t\t\t\t\t\t\t\t// Support: IE <9 only\n-\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n-\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n-\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n-\n-\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n-\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n-\t\t\t\t\t\t\t\tdiff = nodeIndex;\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t// xml :nth-child(...)\n-\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n-\t\t\t\t\t\t\tif ( diff === false ) {\n-\n-\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n-\t\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n-\t\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n-\n-\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n-\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n-\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n-\t\t\t\t\t\t\t\t\t\t++diff ) {\n-\n-\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n-\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n-\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] ||\n-\t\t\t\t\t\t\t\t\t\t\t\t( node[ expando ] = {} );\n-\n-\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n-\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n-\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n-\t\t\t\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n-\n-\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n-\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n-\t\t\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n-\t\t\t\t\t\tdiff -= last;\n-\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n-\t\t\t\t\t}\n-\t\t\t\t};\n-\t\t},\n-\n-\t\t\"PSEUDO\": function( pseudo, argument ) {\n-\n-\t\t\t// pseudo-class names are case-insensitive\n-\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n-\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n-\t\t\t// Remember that setFilters inherits from pseudos\n-\t\t\tvar args,\n-\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n-\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n-\n-\t\t\t// The user may use createPseudo to indicate that\n-\t\t\t// arguments are needed to create the filter function\n-\t\t\t// just as Sizzle does\n-\t\t\tif ( fn[ expando ] ) {\n-\t\t\t\treturn fn( argument );\n-\t\t\t}\n-\n-\t\t\t// But maintain support for old signatures\n-\t\t\tif ( fn.length > 1 ) {\n-\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n-\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n-\t\t\t\t\tmarkFunction( function( seed, matches ) {\n-\t\t\t\t\t\tvar idx,\n-\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n-\t\t\t\t\t\t\ti = matched.length;\n-\t\t\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\t\t\tidx = indexOf( seed, matched[ i ] );\n-\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[ i ] );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} ) :\n-\t\t\t\t\tfunction( elem ) {\n-\t\t\t\t\t\treturn fn( elem, 0, args );\n-\t\t\t\t\t};\n-\t\t\t}\n-\n-\t\t\treturn fn;\n-\t\t}\n-\t},\n-\n-\tpseudos: {\n-\n-\t\t// Potentially complex pseudos\n-\t\t\"not\": markFunction( function( selector ) {\n-\n-\t\t\t// Trim the selector passed to compile\n-\t\t\t// to avoid treating leading and trailing\n-\t\t\t// spaces as combinators\n-\t\t\tvar input = [],\n-\t\t\t\tresults = [],\n-\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n-\n-\t\t\treturn matcher[ expando ] ?\n-\t\t\t\tmarkFunction( function( seed, matches, _context, xml ) {\n-\t\t\t\t\tvar elem,\n-\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n-\t\t\t\t\t\ti = seed.length;\n-\n-\t\t\t\t\t// Match elements unmatched by `matcher`\n-\t\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\t\tif ( ( elem = unmatched[ i ] ) ) {\n-\t\t\t\t\t\t\tseed[ i ] = !( matches[ i ] = elem );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t} ) :\n-\t\t\t\tfunction( elem, _context, xml ) {\n-\t\t\t\t\tinput[ 0 ] = elem;\n-\t\t\t\t\tmatcher( input, null, xml, results );\n-\n-\t\t\t\t\t// Don't keep the element (issue #299)\n-\t\t\t\t\tinput[ 0 ] = null;\n-\t\t\t\t\treturn !results.pop();\n-\t\t\t\t};\n-\t\t} ),\n-\n-\t\t\"has\": markFunction( function( selector ) {\n-\t\t\treturn function( elem ) {\n-\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n-\t\t\t};\n-\t\t} ),\n-\n-\t\t\"contains\": markFunction( function( text ) {\n-\t\t\ttext = text.replace( runescape, funescape );\n-\t\t\treturn function( elem ) {\n-\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n-\t\t\t};\n-\t\t} ),\n-\n-\t\t// \"Whether an element is represented by a :lang() selector\n-\t\t// is based solely on the element's language value\n-\t\t// being equal to the identifier C,\n-\t\t// or beginning with the identifier C immediately followed by \"-\".\n-\t\t// The matching of C against the element's language value is performed case-insensitively.\n-\t\t// The identifier C does not have to be a valid language name.\"\n-\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n-\t\t\"lang\": markFunction( function( lang ) {\n-\n-\t\t\t// lang value must be a valid identifier\n-\t\t\tif ( !ridentifier.test( lang || \"\" ) ) {\n-\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n-\t\t\t}\n-\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n-\t\t\treturn function( elem ) {\n-\t\t\t\tvar elemLang;\n-\t\t\t\tdo {\n-\t\t\t\t\tif ( ( elemLang = documentIsHTML ?\n-\t\t\t\t\t\telem.lang :\n-\t\t\t\t\t\telem.getAttribute( \"xml:lang\" ) || elem.getAttribute( \"lang\" ) ) ) {\n-\n-\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n-\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n-\t\t\t\t\t}\n-\t\t\t\t} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );\n-\t\t\t\treturn false;\n-\t\t\t};\n-\t\t} ),\n-\n-\t\t// Miscellaneous\n-\t\t\"target\": function( elem ) {\n-\t\t\tvar hash = window.location && window.location.hash;\n-\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n-\t\t},\n-\n-\t\t\"root\": function( elem ) {\n-\t\t\treturn elem === docElem;\n-\t\t},\n-\n-\t\t\"focus\": function( elem ) {\n-\t\t\treturn elem === document.activeElement &&\n-\t\t\t\t( !document.hasFocus || document.hasFocus() ) &&\n-\t\t\t\t!!( elem.type || elem.href || ~elem.tabIndex );\n-\t\t},\n-\n-\t\t// Boolean properties\n-\t\t\"enabled\": createDisabledPseudo( false ),\n-\t\t\"disabled\": createDisabledPseudo( true ),\n-\n-\t\t\"checked\": function( elem ) {\n-\n-\t\t\t// In CSS3, :checked should return both checked and selected elements\n-\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n-\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n-\t\t\treturn ( nodeName === \"input\" && !!elem.checked ) ||\n-\t\t\t\t( nodeName === \"option\" && !!elem.selected );\n-\t\t},\n-\n-\t\t\"selected\": function( elem ) {\n-\n-\t\t\t// Accessing this property makes selected-by-default\n-\t\t\t// options in Safari work properly\n-\t\t\tif ( elem.parentNode ) {\n-\t\t\t\t// eslint-disable-next-line no-unused-expressions\n-\t\t\t\telem.parentNode.selectedIndex;\n-\t\t\t}\n-\n-\t\t\treturn elem.selected === true;\n-\t\t},\n-\n-\t\t// Contents\n-\t\t\"empty\": function( elem ) {\n-\n-\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n-\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n-\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n-\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n-\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n-\t\t\t\tif ( elem.nodeType < 6 ) {\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn true;\n-\t\t},\n-\n-\t\t\"parent\": function( elem ) {\n-\t\t\treturn !Expr.pseudos[ \"empty\" ]( elem );\n-\t\t},\n-\n-\t\t// Element/input types\n-\t\t\"header\": function( elem ) {\n-\t\t\treturn rheader.test( elem.nodeName );\n-\t\t},\n-\n-\t\t\"input\": function( elem ) {\n-\t\t\treturn rinputs.test( elem.nodeName );\n-\t\t},\n-\n-\t\t\"button\": function( elem ) {\n-\t\t\tvar name = elem.nodeName.toLowerCase();\n-\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n-\t\t},\n-\n-\t\t\"text\": function( elem ) {\n-\t\t\tvar attr;\n-\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n-\t\t\t\telem.type === \"text\" &&\n-\n-\t\t\t\t// Support: IE <10 only\n-\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n-\t\t\t\t( ( attr = elem.getAttribute( \"type\" ) ) == null ||\n-\t\t\t\t\tattr.toLowerCase() === \"text\" );\n-\t\t},\n-\n-\t\t// Position-in-collection\n-\t\t\"first\": createPositionalPseudo( function() {\n-\t\t\treturn [ 0 ];\n-\t\t} ),\n-\n-\t\t\"last\": createPositionalPseudo( function( _matchIndexes, length ) {\n-\t\t\treturn [ length - 1 ];\n-\t\t} ),\n-\n-\t\t\"eq\": createPositionalPseudo( function( _matchIndexes, length, argument ) {\n-\t\t\treturn [ argument < 0 ? argument + length : argument ];\n-\t\t} ),\n-\n-\t\t\"even\": createPositionalPseudo( function( matchIndexes, length ) {\n-\t\t\tvar i = 0;\n-\t\t\tfor ( ; i < length; i += 2 ) {\n-\t\t\t\tmatchIndexes.push( i );\n-\t\t\t}\n-\t\t\treturn matchIndexes;\n-\t\t} ),\n-\n-\t\t\"odd\": createPositionalPseudo( function( matchIndexes, length ) {\n-\t\t\tvar i = 1;\n-\t\t\tfor ( ; i < length; i += 2 ) {\n-\t\t\t\tmatchIndexes.push( i );\n-\t\t\t}\n-\t\t\treturn matchIndexes;\n-\t\t} ),\n-\n-\t\t\"lt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n-\t\t\tvar i = argument < 0 ?\n-\t\t\t\targument + length :\n-\t\t\t\targument > length ?\n-\t\t\t\t\tlength :\n-\t\t\t\t\targument;\n-\t\t\tfor ( ; --i >= 0; ) {\n-\t\t\t\tmatchIndexes.push( i );\n-\t\t\t}\n-\t\t\treturn matchIndexes;\n-\t\t} ),\n-\n-\t\t\"gt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n-\t\t\tvar i = argument < 0 ? argument + length : argument;\n-\t\t\tfor ( ; ++i < length; ) {\n-\t\t\t\tmatchIndexes.push( i );\n-\t\t\t}\n-\t\t\treturn matchIndexes;\n-\t\t} )\n-\t}\n-};\n-\n-Expr.pseudos[ \"nth\" ] = Expr.pseudos[ \"eq\" ];\n-\n-// Add button/input type pseudos\n-for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n-\tExpr.pseudos[ i ] = createInputPseudo( i );\n-}\n-for ( i in { submit: true, reset: true } ) {\n-\tExpr.pseudos[ i ] = createButtonPseudo( i );\n-}\n-\n-// Easy API for creating new setFilters\n-function setFilters() {}\n-setFilters.prototype = Expr.filters = Expr.pseudos;\n-Expr.setFilters = new setFilters();\n-\n-tokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n-\tvar matched, match, tokens, type,\n-\t\tsoFar, groups, preFilters,\n-\t\tcached = tokenCache[ selector + \" \" ];\n-\n-\tif ( cached ) {\n-\t\treturn parseOnly ? 0 : cached.slice( 0 );\n-\t}\n-\n-\tsoFar = selector;\n-\tgroups = [];\n-\tpreFilters = Expr.preFilter;\n-\n-\twhile ( soFar ) {\n-\n-\t\t// Comma and first run\n-\t\tif ( !matched || ( match = rcomma.exec( soFar ) ) ) {\n-\t\t\tif ( match ) {\n-\n-\t\t\t\t// Don't consume trailing commas as valid\n-\t\t\t\tsoFar = soFar.slice( match[ 0 ].length ) || soFar;\n-\t\t\t}\n-\t\t\tgroups.push( ( tokens = [] ) );\n-\t\t}\n-\n-\t\tmatched = false;\n-\n-\t\t// Combinators\n-\t\tif ( ( match = rcombinators.exec( soFar ) ) ) {\n-\t\t\tmatched = match.shift();\n-\t\t\ttokens.push( {\n-\t\t\t\tvalue: matched,\n-\n-\t\t\t\t// Cast descendant combinators to space\n-\t\t\t\ttype: match[ 0 ].replace( rtrim, \" \" )\n-\t\t\t} );\n-\t\t\tsoFar = soFar.slice( matched.length );\n-\t\t}\n-\n-\t\t// Filters\n-\t\tfor ( type in Expr.filter ) {\n-\t\t\tif ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||\n-\t\t\t\t( match = preFilters[ type ]( match ) ) ) ) {\n-\t\t\t\tmatched = match.shift();\n-\t\t\t\ttokens.push( {\n-\t\t\t\t\tvalue: matched,\n-\t\t\t\t\ttype: type,\n-\t\t\t\t\tmatches: match\n-\t\t\t\t} );\n-\t\t\t\tsoFar = soFar.slice( matched.length );\n-\t\t\t}\n-\t\t}\n-\n-\t\tif ( !matched ) {\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\n-\t// Return the length of the invalid excess\n-\t// if we're just parsing\n-\t// Otherwise, throw an error or return tokens\n-\treturn parseOnly ?\n-\t\tsoFar.length :\n-\t\tsoFar ?\n-\t\t\tSizzle.error( selector ) :\n-\n-\t\t\t// Cache the tokens\n-\t\t\ttokenCache( selector, groups ).slice( 0 );\n-};\n-\n-function toSelector( tokens ) {\n-\tvar i = 0,\n-\t\tlen = tokens.length,\n-\t\tselector = \"\";\n-\tfor ( ; i < len; i++ ) {\n-\t\tselector += tokens[ i ].value;\n-\t}\n-\treturn selector;\n-}\n-\n-function addCombinator( matcher, combinator, base ) {\n-\tvar dir = combinator.dir,\n-\t\tskip = combinator.next,\n-\t\tkey = skip || dir,\n-\t\tcheckNonElements = base && key === \"parentNode\",\n-\t\tdoneName = done++;\n-\n-\treturn combinator.first ?\n-\n-\t\t// Check against closest ancestor/preceding element\n-\t\tfunction( elem, context, xml ) {\n-\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n-\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n-\t\t\t\t\treturn matcher( elem, context, xml );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t} :\n-\n-\t\t// Check against all ancestor/preceding elements\n-\t\tfunction( elem, context, xml ) {\n-\t\t\tvar oldCache, uniqueCache, outerCache,\n-\t\t\t\tnewCache = [ dirruns, doneName ];\n-\n-\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n-\t\t\tif ( xml ) {\n-\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n-\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n-\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n-\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n-\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n-\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n-\n-\t\t\t\t\t\t// Support: IE <9 only\n-\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n-\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] ||\n-\t\t\t\t\t\t\t( outerCache[ elem.uniqueID ] = {} );\n-\n-\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n-\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n-\t\t\t\t\t\t} else if ( ( oldCache = uniqueCache[ key ] ) &&\n-\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n-\n-\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n-\t\t\t\t\t\t\treturn ( newCache[ 2 ] = oldCache[ 2 ] );\n-\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n-\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n-\n-\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n-\t\t\t\t\t\t\tif ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {\n-\t\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t};\n-}\n-\n-function elementMatcher( matchers ) {\n-\treturn matchers.length > 1 ?\n-\t\tfunction( elem, context, xml ) {\n-\t\t\tvar i = matchers.length;\n-\t\t\twhile ( i-- ) {\n-\t\t\t\tif ( !matchers[ i ]( elem, context, xml ) ) {\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn true;\n-\t\t} :\n-\t\tmatchers[ 0 ];\n-}\n-\n-function multipleContexts( selector, contexts, results ) {\n-\tvar i = 0,\n-\t\tlen = contexts.length;\n-\tfor ( ; i < len; i++ ) {\n-\t\tSizzle( selector, contexts[ i ], results );\n-\t}\n-\treturn results;\n-}\n-\n-function condense( unmatched, map, filter, context, xml ) {\n-\tvar elem,\n-\t\tnewUnmatched = [],\n-\t\ti = 0,\n-\t\tlen = unmatched.length,\n-\t\tmapped = map != null;\n-\n-\tfor ( ; i < len; i++ ) {\n-\t\tif ( ( elem = unmatched[ i ] ) ) {\n-\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n-\t\t\t\tnewUnmatched.push( elem );\n-\t\t\t\tif ( mapped ) {\n-\t\t\t\t\tmap.push( i );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn newUnmatched;\n-}\n-\n-function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n-\tif ( postFilter && !postFilter[ expando ] ) {\n-\t\tpostFilter = setMatcher( postFilter );\n-\t}\n-\tif ( postFinder && !postFinder[ expando ] ) {\n-\t\tpostFinder = setMatcher( postFinder, postSelector );\n-\t}\n-\treturn markFunction( function( seed, results, context, xml ) {\n-\t\tvar temp, i, elem,\n-\t\t\tpreMap = [],\n-\t\t\tpostMap = [],\n-\t\t\tpreexisting = results.length,\n-\n-\t\t\t// Get initial elements from seed or context\n-\t\t\telems = seed || multipleContexts(\n-\t\t\t\tselector || \"*\",\n-\t\t\t\tcontext.nodeType ? [ context ] : context,\n-\t\t\t\t[]\n-\t\t\t),\n-\n-\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n-\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n-\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n-\t\t\t\telems,\n-\n-\t\t\tmatcherOut = matcher ?\n-\n-\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n-\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n-\n-\t\t\t\t\t// ...intermediate processing is necessary\n-\t\t\t\t\t[] :\n-\n-\t\t\t\t\t// ...otherwise use results directly\n-\t\t\t\t\tresults :\n-\t\t\t\tmatcherIn;\n-\n-\t\t// Find primary matches\n-\t\tif ( matcher ) {\n-\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n-\t\t}\n-\n-\t\t// Apply postFilter\n-\t\tif ( postFilter ) {\n-\t\t\ttemp = condense( matcherOut, postMap );\n-\t\t\tpostFilter( temp, [], context, xml );\n-\n-\t\t\t// Un-match failing elements by moving them back to matcherIn\n-\t\t\ti = temp.length;\n-\t\t\twhile ( i-- ) {\n-\t\t\t\tif ( ( elem = temp[ i ] ) ) {\n-\t\t\t\t\tmatcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif ( seed ) {\n-\t\t\tif ( postFinder || preFilter ) {\n-\t\t\t\tif ( postFinder ) {\n-\n-\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n-\t\t\t\t\ttemp = [];\n-\t\t\t\t\ti = matcherOut.length;\n-\t\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) ) {\n-\n-\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n-\t\t\t\t\t\t\ttemp.push( ( matcherIn[ i ] = elem ) );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tpostFinder( null, ( matcherOut = [] ), temp, xml );\n-\t\t\t\t}\n-\n-\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n-\t\t\t\ti = matcherOut.length;\n-\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) &&\n-\t\t\t\t\t\t( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {\n-\n-\t\t\t\t\t\tseed[ temp ] = !( results[ temp ] = elem );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t// Add elements to results, through postFinder if defined\n-\t\t} else {\n-\t\t\tmatcherOut = condense(\n-\t\t\t\tmatcherOut === results ?\n-\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n-\t\t\t\t\tmatcherOut\n-\t\t\t);\n-\t\t\tif ( postFinder ) {\n-\t\t\t\tpostFinder( null, results, matcherOut, xml );\n-\t\t\t} else {\n-\t\t\t\tpush.apply( results, matcherOut );\n-\t\t\t}\n-\t\t}\n-\t} );\n-}\n-\n-function matcherFromTokens( tokens ) {\n-\tvar checkContext, matcher, j,\n-\t\tlen = tokens.length,\n-\t\tleadingRelative = Expr.relative[ tokens[ 0 ].type ],\n-\t\timplicitRelative = leadingRelative || Expr.relative[ \" \" ],\n-\t\ti = leadingRelative ? 1 : 0,\n-\n-\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n-\t\tmatchContext = addCombinator( function( elem ) {\n-\t\t\treturn elem === checkContext;\n-\t\t}, implicitRelative, true ),\n-\t\tmatchAnyContext = addCombinator( function( elem ) {\n-\t\t\treturn indexOf( checkContext, elem ) > -1;\n-\t\t}, implicitRelative, true ),\n-\t\tmatchers = [ function( elem, context, xml ) {\n-\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n-\t\t\t\t( checkContext = context ).nodeType ?\n-\t\t\t\t\tmatchContext( elem, context, xml ) :\n-\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n-\n-\t\t\t// Avoid hanging onto element (issue #299)\n-\t\t\tcheckContext = null;\n-\t\t\treturn ret;\n-\t\t} ];\n-\n-\tfor ( ; i < len; i++ ) {\n-\t\tif ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {\n-\t\t\tmatchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];\n-\t\t} else {\n-\t\t\tmatcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );\n-\n-\t\t\t// Return special upon seeing a positional matcher\n-\t\t\tif ( matcher[ expando ] ) {\n-\n-\t\t\t\t// Find the next relative operator (if any) for proper handling\n-\t\t\t\tj = ++i;\n-\t\t\t\tfor ( ; j < len; j++ ) {\n-\t\t\t\t\tif ( Expr.relative[ tokens[ j ].type ] ) {\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\treturn setMatcher(\n-\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n-\t\t\t\t\ti > 1 && toSelector(\n-\n-\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n-\t\t\t\t\ttokens\n-\t\t\t\t\t\t.slice( 0, i - 1 )\n-\t\t\t\t\t\t.concat( { value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" } )\n-\t\t\t\t\t).replace( rtrim, \"$1\" ),\n-\t\t\t\t\tmatcher,\n-\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n-\t\t\t\t\tj < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),\n-\t\t\t\t\tj < len && toSelector( tokens )\n-\t\t\t\t);\n-\t\t\t}\n-\t\t\tmatchers.push( matcher );\n-\t\t}\n-\t}\n-\n-\treturn elementMatcher( matchers );\n-}\n-\n-function matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n-\tvar bySet = setMatchers.length > 0,\n-\t\tbyElement = elementMatchers.length > 0,\n-\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n-\t\t\tvar elem, j, matcher,\n-\t\t\t\tmatchedCount = 0,\n-\t\t\t\ti = \"0\",\n-\t\t\t\tunmatched = seed && [],\n-\t\t\t\tsetMatched = [],\n-\t\t\t\tcontextBackup = outermostContext,\n-\n-\t\t\t\t// We must always have either seed elements or outermost context\n-\t\t\t\telems = seed || byElement && Expr.find[ \"TAG\" ]( \"*\", outermost ),\n-\n-\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n-\t\t\t\tdirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),\n-\t\t\t\tlen = elems.length;\n-\n-\t\t\tif ( outermost ) {\n-\n-\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n-\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\t\t// two documents; shallow comparisons work.\n-\t\t\t\t// eslint-disable-next-line eqeqeq\n-\t\t\t\toutermostContext = context == document || context || outermost;\n-\t\t\t}\n-\n-\t\t\t// Add elements passing elementMatchers directly to results\n-\t\t\t// Support: IE<9, Safari\n-\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n-\t\t\tfor ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {\n-\t\t\t\tif ( byElement && elem ) {\n-\t\t\t\t\tj = 0;\n-\n-\t\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n-\t\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n-\t\t\t\t\t// two documents; shallow comparisons work.\n-\t\t\t\t\t// eslint-disable-next-line eqeqeq\n-\t\t\t\t\tif ( !context && elem.ownerDocument != document ) {\n-\t\t\t\t\t\tsetDocument( elem );\n-\t\t\t\t\t\txml = !documentIsHTML;\n-\t\t\t\t\t}\n-\t\t\t\t\twhile ( ( matcher = elementMatchers[ j++ ] ) ) {\n-\t\t\t\t\t\tif ( matcher( elem, context || document, xml ) ) {\n-\t\t\t\t\t\t\tresults.push( elem );\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif ( outermost ) {\n-\t\t\t\t\t\tdirruns = dirrunsUnique;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// Track unmatched elements for set filters\n-\t\t\t\tif ( bySet ) {\n-\n-\t\t\t\t\t// They will have gone through all possible matchers\n-\t\t\t\t\tif ( ( elem = !matcher && elem ) ) {\n-\t\t\t\t\t\tmatchedCount--;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Lengthen the array for every element, matched or not\n-\t\t\t\t\tif ( seed ) {\n-\t\t\t\t\t\tunmatched.push( elem );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n-\t\t\t// makes the latter nonnegative.\n-\t\t\tmatchedCount += i;\n-\n-\t\t\t// Apply set filters to unmatched elements\n-\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n-\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n-\t\t\t// no element matchers and no seed.\n-\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n-\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n-\t\t\t// numerically zero.\n-\t\t\tif ( bySet && i !== matchedCount ) {\n-\t\t\t\tj = 0;\n-\t\t\t\twhile ( ( matcher = setMatchers[ j++ ] ) ) {\n-\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n-\t\t\t\t}\n-\n-\t\t\t\tif ( seed ) {\n-\n-\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n-\t\t\t\t\tif ( matchedCount > 0 ) {\n-\t\t\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\t\t\tif ( !( unmatched[ i ] || setMatched[ i ] ) ) {\n-\t\t\t\t\t\t\t\tsetMatched[ i ] = pop.call( results );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Discard index placeholder values to get only actual matches\n-\t\t\t\t\tsetMatched = condense( setMatched );\n-\t\t\t\t}\n-\n-\t\t\t\t// Add matches to results\n-\t\t\t\tpush.apply( results, setMatched );\n-\n-\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n-\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n-\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n-\n-\t\t\t\t\tSizzle.uniqueSort( results );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Override manipulation of globals by nested matchers\n-\t\t\tif ( outermost ) {\n-\t\t\t\tdirruns = dirrunsUnique;\n-\t\t\t\toutermostContext = contextBackup;\n-\t\t\t}\n-\n-\t\t\treturn unmatched;\n-\t\t};\n-\n-\treturn bySet ?\n-\t\tmarkFunction( superMatcher ) :\n-\t\tsuperMatcher;\n-}\n-\n-compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n-\tvar i,\n-\t\tsetMatchers = [],\n-\t\telementMatchers = [],\n-\t\tcached = compilerCache[ selector + \" \" ];\n-\n-\tif ( !cached ) {\n-\n-\t\t// Generate a function of recursive functions that can be used to check each element\n-\t\tif ( !match ) {\n-\t\t\tmatch = tokenize( selector );\n-\t\t}\n-\t\ti = match.length;\n-\t\twhile ( i-- ) {\n-\t\t\tcached = matcherFromTokens( match[ i ] );\n-\t\t\tif ( cached[ expando ] ) {\n-\t\t\t\tsetMatchers.push( cached );\n-\t\t\t} else {\n-\t\t\t\telementMatchers.push( cached );\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Cache the compiled function\n-\t\tcached = compilerCache(\n-\t\t\tselector,\n-\t\t\tmatcherFromGroupMatchers( elementMatchers, setMatchers )\n-\t\t);\n-\n-\t\t// Save selector and tokenization\n-\t\tcached.selector = selector;\n-\t}\n-\treturn cached;\n-};\n-\n-/**\n- * A low-level selection function that works with Sizzle's compiled\n- *  selector functions\n- * @param {String|Function} selector A selector or a pre-compiled\n- *  selector function built with Sizzle.compile\n- * @param {Element} context\n- * @param {Array} [results]\n- * @param {Array} [seed] A set of elements to match against\n- */\n-select = Sizzle.select = function( selector, context, results, seed ) {\n-\tvar i, tokens, token, type, find,\n-\t\tcompiled = typeof selector === \"function\" && selector,\n-\t\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\n-\n-\tresults = results || [];\n-\n-\t// Try to minimize operations if there is only one selector in the list and no seed\n-\t// (the latter of which guarantees us context)\n-\tif ( match.length === 1 ) {\n-\n-\t\t// Reduce context if the leading compound selector is an ID\n-\t\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\n-\t\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === \"ID\" &&\n-\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\n-\n-\t\t\tcontext = ( Expr.find[ \"ID\" ]( token.matches[ 0 ]\n-\t\t\t\t.replace( runescape, funescape ), context ) || [] )[ 0 ];\n-\t\t\tif ( !context ) {\n-\t\t\t\treturn results;\n-\n-\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n-\t\t\t} else if ( compiled ) {\n-\t\t\t\tcontext = context.parentNode;\n-\t\t\t}\n-\n-\t\t\tselector = selector.slice( tokens.shift().value.length );\n-\t\t}\n-\n-\t\t// Fetch a seed set for right-to-left matching\n-\t\ti = matchExpr[ \"needsContext\" ].test( selector ) ? 0 : tokens.length;\n-\t\twhile ( i-- ) {\n-\t\t\ttoken = tokens[ i ];\n-\n-\t\t\t// Abort if we hit a combinator\n-\t\t\tif ( Expr.relative[ ( type = token.type ) ] ) {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tif ( ( find = Expr.find[ type ] ) ) {\n-\n-\t\t\t\t// Search, expanding context for leading sibling combinators\n-\t\t\t\tif ( ( seed = find(\n-\t\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n-\t\t\t\t\trsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||\n-\t\t\t\t\t\tcontext\n-\t\t\t\t) ) ) {\n-\n-\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n-\t\t\t\t\ttokens.splice( i, 1 );\n-\t\t\t\t\tselector = seed.length && toSelector( tokens );\n-\t\t\t\t\tif ( !selector ) {\n-\t\t\t\t\t\tpush.apply( results, seed );\n-\t\t\t\t\t\treturn results;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Compile and execute a filtering function if one is not provided\n-\t// Provide `match` to avoid retokenization if we modified the selector above\n-\t( compiled || compile( selector, match ) )(\n-\t\tseed,\n-\t\tcontext,\n-\t\t!documentIsHTML,\n-\t\tresults,\n-\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n-\t);\n-\treturn results;\n-};\n-\n-// One-time assignments\n-\n-// Sort stability\n-support.sortStable = expando.split( \"\" ).sort( sortOrder ).join( \"\" ) === expando;\n-\n-// Support: Chrome 14-35+\n-// Always assume duplicates if they aren't passed to the comparison function\n-support.detectDuplicates = !!hasDuplicate;\n-\n-// Initialize against the default document\n-setDocument();\n-\n-// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n-// Detached nodes confoundingly follow *each other*\n-support.sortDetached = assert( function( el ) {\n-\n-\t// Should return 1, but returns 4 (following)\n-\treturn el.compareDocumentPosition( document.createElement( \"fieldset\" ) ) & 1;\n-} );\n-\n-// Support: IE<8\n-// Prevent attribute/property \"interpolation\"\n-// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n-if ( !assert( function( el ) {\n-\tel.innerHTML = \"<a href='#'></a>\";\n-\treturn el.firstChild.getAttribute( \"href\" ) === \"#\";\n-} ) ) {\n-\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n-\t\tif ( !isXML ) {\n-\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n-\t\t}\n-\t} );\n-}\n-\n-// Support: IE<9\n-// Use defaultValue in place of getAttribute(\"value\")\n-if ( !support.attributes || !assert( function( el ) {\n-\tel.innerHTML = \"<input/>\";\n-\tel.firstChild.setAttribute( \"value\", \"\" );\n-\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n-} ) ) {\n-\taddHandle( \"value\", function( elem, _name, isXML ) {\n-\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n-\t\t\treturn elem.defaultValue;\n-\t\t}\n-\t} );\n-}\n-\n-// Support: IE<9\n-// Use getAttributeNode to fetch booleans when getAttribute lies\n-if ( !assert( function( el ) {\n-\treturn el.getAttribute( \"disabled\" ) == null;\n-} ) ) {\n-\taddHandle( booleans, function( elem, name, isXML ) {\n-\t\tvar val;\n-\t\tif ( !isXML ) {\n-\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n-\t\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n-\t\t\t\t\tval.value :\n-\t\t\t\t\tnull;\n-\t\t}\n-\t} );\n-}\n-\n-return Sizzle;\n-\n-} )( window );\n-\n-\n-\n-jQuery.find = Sizzle;\n-jQuery.expr = Sizzle.selectors;\n-\n-// Deprecated\n-jQuery.expr[ \":\" ] = jQuery.expr.pseudos;\n-jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n-jQuery.text = Sizzle.getText;\n-jQuery.isXMLDoc = Sizzle.isXML;\n-jQuery.contains = Sizzle.contains;\n-jQuery.escapeSelector = Sizzle.escape;\n-\n-\n-\n-\n-var dir = function( elem, dir, until ) {\n-\tvar matched = [],\n-\t\ttruncate = until !== undefined;\n-\n-\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n-\t\tif ( elem.nodeType === 1 ) {\n-\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tmatched.push( elem );\n-\t\t}\n-\t}\n-\treturn matched;\n-};\n-\n-\n-var siblings = function( n, elem ) {\n-\tvar matched = [];\n-\n-\tfor ( ; n; n = n.nextSibling ) {\n-\t\tif ( n.nodeType === 1 && n !== elem ) {\n-\t\t\tmatched.push( n );\n-\t\t}\n-\t}\n-\n-\treturn matched;\n-};\n-\n-\n-var rneedsContext = jQuery.expr.match.needsContext;\n-\n-\n-\n-function nodeName( elem, name ) {\n-\n-\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n-\n-}\n-var rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n-\n-\n-\n-// Implement the identical functionality for filter and not\n-function winnow( elements, qualifier, not ) {\n-\tif ( isFunction( qualifier ) ) {\n-\t\treturn jQuery.grep( elements, function( elem, i ) {\n-\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n-\t\t} );\n-\t}\n-\n-\t// Single element\n-\tif ( qualifier.nodeType ) {\n-\t\treturn jQuery.grep( elements, function( elem ) {\n-\t\t\treturn ( elem === qualifier ) !== not;\n-\t\t} );\n-\t}\n-\n-\t// Arraylike of elements (jQuery, arguments, Array)\n-\tif ( typeof qualifier !== \"string\" ) {\n-\t\treturn jQuery.grep( elements, function( elem ) {\n-\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n-\t\t} );\n-\t}\n-\n-\t// Filtered directly for both simple and complex selectors\n-\treturn jQuery.filter( qualifier, elements, not );\n-}\n-\n-jQuery.filter = function( expr, elems, not ) {\n-\tvar elem = elems[ 0 ];\n-\n-\tif ( not ) {\n-\t\texpr = \":not(\" + expr + \")\";\n-\t}\n-\n-\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n-\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n-\t}\n-\n-\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n-\t\treturn elem.nodeType === 1;\n-\t} ) );\n-};\n-\n-jQuery.fn.extend( {\n-\tfind: function( selector ) {\n-\t\tvar i, ret,\n-\t\t\tlen = this.length,\n-\t\t\tself = this;\n-\n-\t\tif ( typeof selector !== \"string\" ) {\n-\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n-\t\t\t\tfor ( i = 0; i < len; i++ ) {\n-\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} ) );\n-\t\t}\n-\n-\t\tret = this.pushStack( [] );\n-\n-\t\tfor ( i = 0; i < len; i++ ) {\n-\t\t\tjQuery.find( selector, self[ i ], ret );\n-\t\t}\n-\n-\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n-\t},\n-\tfilter: function( selector ) {\n-\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n-\t},\n-\tnot: function( selector ) {\n-\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n-\t},\n-\tis: function( selector ) {\n-\t\treturn !!winnow(\n-\t\t\tthis,\n-\n-\t\t\t// If this is a positional/relative selector, check membership in the returned set\n-\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n-\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n-\t\t\t\tjQuery( selector ) :\n-\t\t\t\tselector || [],\n-\t\t\tfalse\n-\t\t).length;\n-\t}\n-} );\n-\n-\n-// Initialize a jQuery object\n-\n-\n-// A central reference to the root jQuery(document)\n-var rootjQuery,\n-\n-\t// A simple way to check for HTML strings\n-\t// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n-\t// Strict HTML recognition (trac-11290: must start with <)\n-\t// Shortcut simple #id case for speed\n-\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n-\n-\tinit = jQuery.fn.init = function( selector, context, root ) {\n-\t\tvar match, elem;\n-\n-\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n-\t\tif ( !selector ) {\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t// Method init() accepts an alternate rootjQuery\n-\t\t// so migrate can support jQuery.sub (gh-2101)\n-\t\troot = root || rootjQuery;\n-\n-\t\t// Handle HTML strings\n-\t\tif ( typeof selector === \"string\" ) {\n-\t\t\tif ( selector[ 0 ] === \"<\" &&\n-\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n-\t\t\t\tselector.length >= 3 ) {\n-\n-\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n-\t\t\t\tmatch = [ null, selector, null ];\n-\n-\t\t\t} else {\n-\t\t\t\tmatch = rquickExpr.exec( selector );\n-\t\t\t}\n-\n-\t\t\t// Match html or make sure no context is specified for #id\n-\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n-\n-\t\t\t\t// HANDLE: $(html) -> $(array)\n-\t\t\t\tif ( match[ 1 ] ) {\n-\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n-\n-\t\t\t\t\t// Option to run scripts is true for back-compat\n-\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n-\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n-\t\t\t\t\t\tmatch[ 1 ],\n-\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n-\t\t\t\t\t\ttrue\n-\t\t\t\t\t) );\n-\n-\t\t\t\t\t// HANDLE: $(html, props)\n-\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n-\t\t\t\t\t\tfor ( match in context ) {\n-\n-\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n-\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n-\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n-\n-\t\t\t\t\t\t\t// ...and otherwise set as attributes\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\treturn this;\n-\n-\t\t\t\t// HANDLE: $(#id)\n-\t\t\t\t} else {\n-\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n-\n-\t\t\t\t\tif ( elem ) {\n-\n-\t\t\t\t\t\t// Inject the element directly into the jQuery object\n-\t\t\t\t\t\tthis[ 0 ] = elem;\n-\t\t\t\t\t\tthis.length = 1;\n-\t\t\t\t\t}\n-\t\t\t\t\treturn this;\n-\t\t\t\t}\n-\n-\t\t\t// HANDLE: $(expr, $(...))\n-\t\t\t} else if ( !context || context.jquery ) {\n-\t\t\t\treturn ( context || root ).find( selector );\n-\n-\t\t\t// HANDLE: $(expr, context)\n-\t\t\t// (which is just equivalent to: $(context).find(expr)\n-\t\t\t} else {\n-\t\t\t\treturn this.constructor( context ).find( selector );\n-\t\t\t}\n-\n-\t\t// HANDLE: $(DOMElement)\n-\t\t} else if ( selector.nodeType ) {\n-\t\t\tthis[ 0 ] = selector;\n-\t\t\tthis.length = 1;\n-\t\t\treturn this;\n-\n-\t\t// HANDLE: $(function)\n-\t\t// Shortcut for document ready\n-\t\t} else if ( isFunction( selector ) ) {\n-\t\t\treturn root.ready !== undefined ?\n-\t\t\t\troot.ready( selector ) :\n-\n-\t\t\t\t// Execute immediately if ready is not present\n-\t\t\t\tselector( jQuery );\n-\t\t}\n-\n-\t\treturn jQuery.makeArray( selector, this );\n-\t};\n-\n-// Give the init function the jQuery prototype for later instantiation\n-init.prototype = jQuery.fn;\n-\n-// Initialize central reference\n-rootjQuery = jQuery( document );\n-\n-\n-var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n-\n-\t// Methods guaranteed to produce a unique set when starting from a unique set\n-\tguaranteedUnique = {\n-\t\tchildren: true,\n-\t\tcontents: true,\n-\t\tnext: true,\n-\t\tprev: true\n-\t};\n-\n-jQuery.fn.extend( {\n-\thas: function( target ) {\n-\t\tvar targets = jQuery( target, this ),\n-\t\t\tl = targets.length;\n-\n-\t\treturn this.filter( function() {\n-\t\t\tvar i = 0;\n-\t\t\tfor ( ; i < l; i++ ) {\n-\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\tclosest: function( selectors, context ) {\n-\t\tvar cur,\n-\t\t\ti = 0,\n-\t\t\tl = this.length,\n-\t\t\tmatched = [],\n-\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n-\n-\t\t// Positional selectors never match, since there's no _selection_ context\n-\t\tif ( !rneedsContext.test( selectors ) ) {\n-\t\t\tfor ( ; i < l; i++ ) {\n-\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n-\n-\t\t\t\t\t// Always skip document fragments\n-\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n-\t\t\t\t\t\ttargets.index( cur ) > -1 :\n-\n-\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n-\t\t\t\t\t\tcur.nodeType === 1 &&\n-\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n-\n-\t\t\t\t\t\tmatched.push( cur );\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n-\t},\n-\n-\t// Determine the position of an element within the set\n-\tindex: function( elem ) {\n-\n-\t\t// No argument, return index in parent\n-\t\tif ( !elem ) {\n-\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n-\t\t}\n-\n-\t\t// Index in selector\n-\t\tif ( typeof elem === \"string\" ) {\n-\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n-\t\t}\n-\n-\t\t// Locate the position of the desired element\n-\t\treturn indexOf.call( this,\n-\n-\t\t\t// If it receives a jQuery object, the first element is used\n-\t\t\telem.jquery ? elem[ 0 ] : elem\n-\t\t);\n-\t},\n-\n-\tadd: function( selector, context ) {\n-\t\treturn this.pushStack(\n-\t\t\tjQuery.uniqueSort(\n-\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n-\t\t\t)\n-\t\t);\n-\t},\n-\n-\taddBack: function( selector ) {\n-\t\treturn this.add( selector == null ?\n-\t\t\tthis.prevObject : this.prevObject.filter( selector )\n-\t\t);\n-\t}\n-} );\n-\n-function sibling( cur, dir ) {\n-\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n-\treturn cur;\n-}\n-\n-jQuery.each( {\n-\tparent: function( elem ) {\n-\t\tvar parent = elem.parentNode;\n-\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n-\t},\n-\tparents: function( elem ) {\n-\t\treturn dir( elem, \"parentNode\" );\n-\t},\n-\tparentsUntil: function( elem, _i, until ) {\n-\t\treturn dir( elem, \"parentNode\", until );\n-\t},\n-\tnext: function( elem ) {\n-\t\treturn sibling( elem, \"nextSibling\" );\n-\t},\n-\tprev: function( elem ) {\n-\t\treturn sibling( elem, \"previousSibling\" );\n-\t},\n-\tnextAll: function( elem ) {\n-\t\treturn dir( elem, \"nextSibling\" );\n-\t},\n-\tprevAll: function( elem ) {\n-\t\treturn dir( elem, \"previousSibling\" );\n-\t},\n-\tnextUntil: function( elem, _i, until ) {\n-\t\treturn dir( elem, \"nextSibling\", until );\n-\t},\n-\tprevUntil: function( elem, _i, until ) {\n-\t\treturn dir( elem, \"previousSibling\", until );\n-\t},\n-\tsiblings: function( elem ) {\n-\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n-\t},\n-\tchildren: function( elem ) {\n-\t\treturn siblings( elem.firstChild );\n-\t},\n-\tcontents: function( elem ) {\n-\t\tif ( elem.contentDocument != null &&\n-\n-\t\t\t// Support: IE 11+\n-\t\t\t// <object> elements with no `data` attribute has an object\n-\t\t\t// `contentDocument` with a `null` prototype.\n-\t\t\tgetProto( elem.contentDocument ) ) {\n-\n-\t\t\treturn elem.contentDocument;\n-\t\t}\n-\n-\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n-\t\t// Treat the template element as a regular one in browsers that\n-\t\t// don't support it.\n-\t\tif ( nodeName( elem, \"template\" ) ) {\n-\t\t\telem = elem.content || elem;\n-\t\t}\n-\n-\t\treturn jQuery.merge( [], elem.childNodes );\n-\t}\n-}, function( name, fn ) {\n-\tjQuery.fn[ name ] = function( until, selector ) {\n-\t\tvar matched = jQuery.map( this, fn, until );\n-\n-\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n-\t\t\tselector = until;\n-\t\t}\n-\n-\t\tif ( selector && typeof selector === \"string\" ) {\n-\t\t\tmatched = jQuery.filter( selector, matched );\n-\t\t}\n-\n-\t\tif ( this.length > 1 ) {\n-\n-\t\t\t// Remove duplicates\n-\t\t\tif ( !guaranteedUnique[ name ] ) {\n-\t\t\t\tjQuery.uniqueSort( matched );\n-\t\t\t}\n-\n-\t\t\t// Reverse order for parents* and prev-derivatives\n-\t\t\tif ( rparentsprev.test( name ) ) {\n-\t\t\t\tmatched.reverse();\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn this.pushStack( matched );\n-\t};\n-} );\n-var rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n-\n-\n-\n-// Convert String-formatted options into Object-formatted ones\n-function createOptions( options ) {\n-\tvar object = {};\n-\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n-\t\tobject[ flag ] = true;\n-\t} );\n-\treturn object;\n-}\n-\n-/*\n- * Create a callback list using the following parameters:\n- *\n- *\toptions: an optional list of space-separated options that will change how\n- *\t\t\tthe callback list behaves or a more traditional option object\n- *\n- * By default a callback list will act like an event callback list and can be\n- * \"fired\" multiple times.\n- *\n- * Possible options:\n- *\n- *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n- *\n- *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n- *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n- *\t\t\t\t\tvalues (like a Deferred)\n- *\n- *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n- *\n- *\tstopOnFalse:\tinterrupt callings when a callback returns false\n- *\n- */\n-jQuery.Callbacks = function( options ) {\n-\n-\t// Convert options from String-formatted to Object-formatted if needed\n-\t// (we check in cache first)\n-\toptions = typeof options === \"string\" ?\n-\t\tcreateOptions( options ) :\n-\t\tjQuery.extend( {}, options );\n-\n-\tvar // Flag to know if list is currently firing\n-\t\tfiring,\n-\n-\t\t// Last fire value for non-forgettable lists\n-\t\tmemory,\n-\n-\t\t// Flag to know if list was already fired\n-\t\tfired,\n-\n-\t\t// Flag to prevent firing\n-\t\tlocked,\n-\n-\t\t// Actual callback list\n-\t\tlist = [],\n-\n-\t\t// Queue of execution data for repeatable lists\n-\t\tqueue = [],\n-\n-\t\t// Index of currently firing callback (modified by add/remove as needed)\n-\t\tfiringIndex = -1,\n-\n-\t\t// Fire callbacks\n-\t\tfire = function() {\n-\n-\t\t\t// Enforce single-firing\n-\t\t\tlocked = locked || options.once;\n-\n-\t\t\t// Execute callbacks for all pending executions,\n-\t\t\t// respecting firingIndex overrides and runtime changes\n-\t\t\tfired = firing = true;\n-\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n-\t\t\t\tmemory = queue.shift();\n-\t\t\t\twhile ( ++firingIndex < list.length ) {\n-\n-\t\t\t\t\t// Run callback and check for early termination\n-\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n-\t\t\t\t\t\toptions.stopOnFalse ) {\n-\n-\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n-\t\t\t\t\t\tfiringIndex = list.length;\n-\t\t\t\t\t\tmemory = false;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Forget the data if we're done with it\n-\t\t\tif ( !options.memory ) {\n-\t\t\t\tmemory = false;\n-\t\t\t}\n-\n-\t\t\tfiring = false;\n-\n-\t\t\t// Clean up if we're done firing for good\n-\t\t\tif ( locked ) {\n-\n-\t\t\t\t// Keep an empty list if we have data for future add calls\n-\t\t\t\tif ( memory ) {\n-\t\t\t\t\tlist = [];\n-\n-\t\t\t\t// Otherwise, this object is spent\n-\t\t\t\t} else {\n-\t\t\t\t\tlist = \"\";\n-\t\t\t\t}\n-\t\t\t}\n-\t\t},\n-\n-\t\t// Actual Callbacks object\n-\t\tself = {\n-\n-\t\t\t// Add a callback or a collection of callbacks to the list\n-\t\t\tadd: function() {\n-\t\t\t\tif ( list ) {\n-\n-\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n-\t\t\t\t\tif ( memory && !firing ) {\n-\t\t\t\t\t\tfiringIndex = list.length - 1;\n-\t\t\t\t\t\tqueue.push( memory );\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t( function add( args ) {\n-\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n-\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n-\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n-\t\t\t\t\t\t\t\t\tlist.push( arg );\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n-\n-\t\t\t\t\t\t\t\t// Inspect recursively\n-\t\t\t\t\t\t\t\tadd( arg );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} );\n-\t\t\t\t\t} )( arguments );\n-\n-\t\t\t\t\tif ( memory && !firing ) {\n-\t\t\t\t\t\tfire();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\treturn this;\n-\t\t\t},\n-\n-\t\t\t// Remove a callback from the list\n-\t\t\tremove: function() {\n-\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n-\t\t\t\t\tvar index;\n-\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n-\t\t\t\t\t\tlist.splice( index, 1 );\n-\n-\t\t\t\t\t\t// Handle firing indexes\n-\t\t\t\t\t\tif ( index <= firingIndex ) {\n-\t\t\t\t\t\t\tfiringIndex--;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t} );\n-\t\t\t\treturn this;\n-\t\t\t},\n-\n-\t\t\t// Check if a given callback is in the list.\n-\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n-\t\t\thas: function( fn ) {\n-\t\t\t\treturn fn ?\n-\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n-\t\t\t\t\tlist.length > 0;\n-\t\t\t},\n-\n-\t\t\t// Remove all callbacks from the list\n-\t\t\tempty: function() {\n-\t\t\t\tif ( list ) {\n-\t\t\t\t\tlist = [];\n-\t\t\t\t}\n-\t\t\t\treturn this;\n-\t\t\t},\n-\n-\t\t\t// Disable .fire and .add\n-\t\t\t// Abort any current/pending executions\n-\t\t\t// Clear all callbacks and values\n-\t\t\tdisable: function() {\n-\t\t\t\tlocked = queue = [];\n-\t\t\t\tlist = memory = \"\";\n-\t\t\t\treturn this;\n-\t\t\t},\n-\t\t\tdisabled: function() {\n-\t\t\t\treturn !list;\n-\t\t\t},\n-\n-\t\t\t// Disable .fire\n-\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n-\t\t\t// Abort any pending executions\n-\t\t\tlock: function() {\n-\t\t\t\tlocked = queue = [];\n-\t\t\t\tif ( !memory && !firing ) {\n-\t\t\t\t\tlist = memory = \"\";\n-\t\t\t\t}\n-\t\t\t\treturn this;\n-\t\t\t},\n-\t\t\tlocked: function() {\n-\t\t\t\treturn !!locked;\n-\t\t\t},\n-\n-\t\t\t// Call all callbacks with the given context and arguments\n-\t\t\tfireWith: function( context, args ) {\n-\t\t\t\tif ( !locked ) {\n-\t\t\t\t\targs = args || [];\n-\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n-\t\t\t\t\tqueue.push( args );\n-\t\t\t\t\tif ( !firing ) {\n-\t\t\t\t\t\tfire();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\treturn this;\n-\t\t\t},\n-\n-\t\t\t// Call all the callbacks with the given arguments\n-\t\t\tfire: function() {\n-\t\t\t\tself.fireWith( this, arguments );\n-\t\t\t\treturn this;\n-\t\t\t},\n-\n-\t\t\t// To know if the callbacks have already been called at least once\n-\t\t\tfired: function() {\n-\t\t\t\treturn !!fired;\n-\t\t\t}\n-\t\t};\n-\n-\treturn self;\n-};\n-\n-\n-function Identity( v ) {\n-\treturn v;\n-}\n-function Thrower( ex ) {\n-\tthrow ex;\n-}\n-\n-function adoptValue( value, resolve, reject, noValue ) {\n-\tvar method;\n-\n-\ttry {\n-\n-\t\t// Check for promise aspect first to privilege synchronous behavior\n-\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n-\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n-\n-\t\t// Other thenables\n-\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n-\t\t\tmethod.call( value, resolve, reject );\n-\n-\t\t// Other non-thenables\n-\t\t} else {\n-\n-\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n-\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n-\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n-\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n-\t\t}\n-\n-\t// For Promises/A+, convert exceptions into rejections\n-\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n-\t// Deferred#then to conditionally suppress rejection.\n-\t} catch ( value ) {\n-\n-\t\t// Support: Android 4.0 only\n-\t\t// Strict mode functions invoked without .call/.apply get global-object context\n-\t\treject.apply( undefined, [ value ] );\n-\t}\n-}\n-\n-jQuery.extend( {\n-\n-\tDeferred: function( func ) {\n-\t\tvar tuples = [\n-\n-\t\t\t\t// action, add listener, callbacks,\n-\t\t\t\t// ... .then handlers, argument index, [final state]\n-\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n-\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n-\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n-\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n-\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n-\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n-\t\t\t],\n-\t\t\tstate = \"pending\",\n-\t\t\tpromise = {\n-\t\t\t\tstate: function() {\n-\t\t\t\t\treturn state;\n-\t\t\t\t},\n-\t\t\t\talways: function() {\n-\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n-\t\t\t\t\treturn this;\n-\t\t\t\t},\n-\t\t\t\t\"catch\": function( fn ) {\n-\t\t\t\t\treturn promise.then( null, fn );\n-\t\t\t\t},\n-\n-\t\t\t\t// Keep pipe for back-compat\n-\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n-\t\t\t\t\tvar fns = arguments;\n-\n-\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n-\t\t\t\t\t\tjQuery.each( tuples, function( _i, tuple ) {\n-\n-\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n-\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n-\n-\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n-\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n-\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n-\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n-\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n-\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n-\t\t\t\t\t\t\t\t\treturned.promise()\n-\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n-\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n-\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n-\t\t\t\t\t\t\t\t\t\tthis,\n-\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n-\t\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} );\n-\t\t\t\t\t\t} );\n-\t\t\t\t\t\tfns = null;\n-\t\t\t\t\t} ).promise();\n-\t\t\t\t},\n-\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n-\t\t\t\t\tvar maxDepth = 0;\n-\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n-\t\t\t\t\t\treturn function() {\n-\t\t\t\t\t\t\tvar that = this,\n-\t\t\t\t\t\t\t\targs = arguments,\n-\t\t\t\t\t\t\t\tmightThrow = function() {\n-\t\t\t\t\t\t\t\t\tvar returned, then;\n-\n-\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n-\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n-\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n-\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n-\t\t\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n-\n-\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n-\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n-\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n-\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n-\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n-\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n-\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n-\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n-\t\t\t\t\t\t\t\t\tthen = returned &&\n-\n-\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n-\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n-\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n-\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n-\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n-\t\t\t\t\t\t\t\t\t\treturned.then;\n-\n-\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n-\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n-\n-\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n-\t\t\t\t\t\t\t\t\t\tif ( special ) {\n-\t\t\t\t\t\t\t\t\t\t\tthen.call(\n-\t\t\t\t\t\t\t\t\t\t\t\treturned,\n-\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n-\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n-\t\t\t\t\t\t\t\t\t\t\t);\n-\n-\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n-\t\t\t\t\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n-\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n-\n-\t\t\t\t\t\t\t\t\t\t\tthen.call(\n-\t\t\t\t\t\t\t\t\t\t\t\treturned,\n-\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n-\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n-\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n-\t\t\t\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t// Handle all other returned values\n-\t\t\t\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n-\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n-\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n-\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n-\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n-\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n-\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n-\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t},\n-\n-\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n-\t\t\t\t\t\t\t\tprocess = special ?\n-\t\t\t\t\t\t\t\t\tmightThrow :\n-\t\t\t\t\t\t\t\t\tfunction() {\n-\t\t\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n-\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n-\n-\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n-\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n-\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n-\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n-\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n-\n-\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n-\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n-\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n-\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n-\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t};\n-\n-\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n-\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n-\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n-\t\t\t\t\t\t\t// subsequent errors\n-\t\t\t\t\t\t\tif ( depth ) {\n-\t\t\t\t\t\t\t\tprocess();\n-\t\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n-\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n-\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n-\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\twindow.setTimeout( process );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t};\n-\t\t\t\t\t}\n-\n-\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n-\n-\t\t\t\t\t\t// progress_handlers.add( ... )\n-\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n-\t\t\t\t\t\t\tresolve(\n-\t\t\t\t\t\t\t\t0,\n-\t\t\t\t\t\t\t\tnewDefer,\n-\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n-\t\t\t\t\t\t\t\t\tonProgress :\n-\t\t\t\t\t\t\t\t\tIdentity,\n-\t\t\t\t\t\t\t\tnewDefer.notifyWith\n-\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t);\n-\n-\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n-\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n-\t\t\t\t\t\t\tresolve(\n-\t\t\t\t\t\t\t\t0,\n-\t\t\t\t\t\t\t\tnewDefer,\n-\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n-\t\t\t\t\t\t\t\t\tonFulfilled :\n-\t\t\t\t\t\t\t\t\tIdentity\n-\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t);\n-\n-\t\t\t\t\t\t// rejected_handlers.add( ... )\n-\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n-\t\t\t\t\t\t\tresolve(\n-\t\t\t\t\t\t\t\t0,\n-\t\t\t\t\t\t\t\tnewDefer,\n-\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n-\t\t\t\t\t\t\t\t\tonRejected :\n-\t\t\t\t\t\t\t\t\tThrower\n-\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t);\n-\t\t\t\t\t} ).promise();\n-\t\t\t\t},\n-\n-\t\t\t\t// Get a promise for this deferred\n-\t\t\t\t// If obj is provided, the promise aspect is added to the object\n-\t\t\t\tpromise: function( obj ) {\n-\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n-\t\t\t\t}\n-\t\t\t},\n-\t\t\tdeferred = {};\n-\n-\t\t// Add list-specific methods\n-\t\tjQuery.each( tuples, function( i, tuple ) {\n-\t\t\tvar list = tuple[ 2 ],\n-\t\t\t\tstateString = tuple[ 5 ];\n-\n-\t\t\t// promise.progress = list.add\n-\t\t\t// promise.done = list.add\n-\t\t\t// promise.fail = list.add\n-\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n-\n-\t\t\t// Handle state\n-\t\t\tif ( stateString ) {\n-\t\t\t\tlist.add(\n-\t\t\t\t\tfunction() {\n-\n-\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n-\t\t\t\t\t\t// state = \"rejected\"\n-\t\t\t\t\t\tstate = stateString;\n-\t\t\t\t\t},\n-\n-\t\t\t\t\t// rejected_callbacks.disable\n-\t\t\t\t\t// fulfilled_callbacks.disable\n-\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n-\n-\t\t\t\t\t// rejected_handlers.disable\n-\t\t\t\t\t// fulfilled_handlers.disable\n-\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n-\n-\t\t\t\t\t// progress_callbacks.lock\n-\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n-\n-\t\t\t\t\t// progress_handlers.lock\n-\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n-\t\t\t\t);\n-\t\t\t}\n-\n-\t\t\t// progress_handlers.fire\n-\t\t\t// fulfilled_handlers.fire\n-\t\t\t// rejected_handlers.fire\n-\t\t\tlist.add( tuple[ 3 ].fire );\n-\n-\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n-\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n-\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n-\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n-\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n-\t\t\t\treturn this;\n-\t\t\t};\n-\n-\t\t\t// deferred.notifyWith = list.fireWith\n-\t\t\t// deferred.resolveWith = list.fireWith\n-\t\t\t// deferred.rejectWith = list.fireWith\n-\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n-\t\t} );\n-\n-\t\t// Make the deferred a promise\n-\t\tpromise.promise( deferred );\n-\n-\t\t// Call given func if any\n-\t\tif ( func ) {\n-\t\t\tfunc.call( deferred, deferred );\n-\t\t}\n-\n-\t\t// All done!\n-\t\treturn deferred;\n-\t},\n-\n-\t// Deferred helper\n-\twhen: function( singleValue ) {\n-\t\tvar\n-\n-\t\t\t// count of uncompleted subordinates\n-\t\t\tremaining = arguments.length,\n-\n-\t\t\t// count of unprocessed arguments\n-\t\t\ti = remaining,\n-\n-\t\t\t// subordinate fulfillment data\n-\t\t\tresolveContexts = Array( i ),\n-\t\t\tresolveValues = slice.call( arguments ),\n-\n-\t\t\t// the primary Deferred\n-\t\t\tprimary = jQuery.Deferred(),\n-\n-\t\t\t// subordinate callback factory\n-\t\t\tupdateFunc = function( i ) {\n-\t\t\t\treturn function( value ) {\n-\t\t\t\t\tresolveContexts[ i ] = this;\n-\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n-\t\t\t\t\tif ( !( --remaining ) ) {\n-\t\t\t\t\t\tprimary.resolveWith( resolveContexts, resolveValues );\n-\t\t\t\t\t}\n-\t\t\t\t};\n-\t\t\t};\n-\n-\t\t// Single- and empty arguments are adopted like Promise.resolve\n-\t\tif ( remaining <= 1 ) {\n-\t\t\tadoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,\n-\t\t\t\t!remaining );\n-\n-\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n-\t\t\tif ( primary.state() === \"pending\" ||\n-\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n-\n-\t\t\t\treturn primary.then();\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Multiple arguments are aggregated like Promise.all array elements\n-\t\twhile ( i-- ) {\n-\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );\n-\t\t}\n-\n-\t\treturn primary.promise();\n-\t}\n-} );\n-\n-\n-// These usually indicate a programmer mistake during development,\n-// warn about them ASAP rather than swallowing them by default.\n-var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n-\n-jQuery.Deferred.exceptionHook = function( error, stack ) {\n-\n-\t// Support: IE 8 - 9 only\n-\t// Console exists when dev tools are open, which can happen at any time\n-\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n-\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n-\t}\n-};\n-\n-\n-\n-\n-jQuery.readyException = function( error ) {\n-\twindow.setTimeout( function() {\n-\t\tthrow error;\n-\t} );\n-};\n-\n-\n-\n-\n-// The deferred used on DOM ready\n-var readyList = jQuery.Deferred();\n-\n-jQuery.fn.ready = function( fn ) {\n-\n-\treadyList\n-\t\t.then( fn )\n-\n-\t\t// Wrap jQuery.readyException in a function so that the lookup\n-\t\t// happens at the time of error handling instead of callback\n-\t\t// registration.\n-\t\t.catch( function( error ) {\n-\t\t\tjQuery.readyException( error );\n-\t\t} );\n-\n-\treturn this;\n-};\n-\n-jQuery.extend( {\n-\n-\t// Is the DOM ready to be used? Set to true once it occurs.\n-\tisReady: false,\n-\n-\t// A counter to track how many items to wait for before\n-\t// the ready event fires. See trac-6781\n-\treadyWait: 1,\n-\n-\t// Handle when the DOM is ready\n-\tready: function( wait ) {\n-\n-\t\t// Abort if there are pending holds or we're already ready\n-\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Remember that the DOM is ready\n-\t\tjQuery.isReady = true;\n-\n-\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n-\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// If there are functions bound, to execute\n-\t\treadyList.resolveWith( document, [ jQuery ] );\n-\t}\n-} );\n-\n-jQuery.ready.then = readyList.then;\n-\n-// The ready event handler and self cleanup method\n-function completed() {\n-\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n-\twindow.removeEventListener( \"load\", completed );\n-\tjQuery.ready();\n-}\n-\n-// Catch cases where $(document).ready() is called\n-// after the browser event has already occurred.\n-// Support: IE <=9 - 10 only\n-// Older IE sometimes signals \"interactive\" too soon\n-if ( document.readyState === \"complete\" ||\n-\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n-\n-\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n-\twindow.setTimeout( jQuery.ready );\n-\n-} else {\n-\n-\t// Use the handy event callback\n-\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n-\n-\t// A fallback to window.onload, that will always work\n-\twindow.addEventListener( \"load\", completed );\n-}\n-\n-\n-\n-\n-// Multifunctional method to get and set values of a collection\n-// The value/s can optionally be executed if it's a function\n-var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n-\tvar i = 0,\n-\t\tlen = elems.length,\n-\t\tbulk = key == null;\n-\n-\t// Sets many values\n-\tif ( toType( key ) === \"object\" ) {\n-\t\tchainable = true;\n-\t\tfor ( i in key ) {\n-\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n-\t\t}\n-\n-\t// Sets one value\n-\t} else if ( value !== undefined ) {\n-\t\tchainable = true;\n-\n-\t\tif ( !isFunction( value ) ) {\n-\t\t\traw = true;\n-\t\t}\n-\n-\t\tif ( bulk ) {\n-\n-\t\t\t// Bulk operations run against the entire set\n-\t\t\tif ( raw ) {\n-\t\t\t\tfn.call( elems, value );\n-\t\t\t\tfn = null;\n-\n-\t\t\t// ...except when executing function values\n-\t\t\t} else {\n-\t\t\t\tbulk = fn;\n-\t\t\t\tfn = function( elem, _key, value ) {\n-\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n-\t\t\t\t};\n-\t\t\t}\n-\t\t}\n-\n-\t\tif ( fn ) {\n-\t\t\tfor ( ; i < len; i++ ) {\n-\t\t\t\tfn(\n-\t\t\t\t\telems[ i ], key, raw ?\n-\t\t\t\t\t\tvalue :\n-\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n-\t\t\t\t);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif ( chainable ) {\n-\t\treturn elems;\n-\t}\n-\n-\t// Gets\n-\tif ( bulk ) {\n-\t\treturn fn.call( elems );\n-\t}\n-\n-\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n-};\n-\n-\n-// Matches dashed string for camelizing\n-var rmsPrefix = /^-ms-/,\n-\trdashAlpha = /-([a-z])/g;\n-\n-// Used by camelCase as callback to replace()\n-function fcamelCase( _all, letter ) {\n-\treturn letter.toUpperCase();\n-}\n-\n-// Convert dashed to camelCase; used by the css and data modules\n-// Support: IE <=9 - 11, Edge 12 - 15\n-// Microsoft forgot to hump their vendor prefix (trac-9572)\n-function camelCase( string ) {\n-\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n-}\n-var acceptData = function( owner ) {\n-\n-\t// Accepts only:\n-\t//  - Node\n-\t//    - Node.ELEMENT_NODE\n-\t//    - Node.DOCUMENT_NODE\n-\t//  - Object\n-\t//    - Any\n-\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n-};\n-\n-\n-\n-\n-function Data() {\n-\tthis.expando = jQuery.expando + Data.uid++;\n-}\n-\n-Data.uid = 1;\n-\n-Data.prototype = {\n-\n-\tcache: function( owner ) {\n-\n-\t\t// Check if the owner object already has a cache\n-\t\tvar value = owner[ this.expando ];\n-\n-\t\t// If not, create one\n-\t\tif ( !value ) {\n-\t\t\tvalue = {};\n-\n-\t\t\t// We can accept data for non-element nodes in modern browsers,\n-\t\t\t// but we should not, see trac-8335.\n-\t\t\t// Always return an empty object.\n-\t\t\tif ( acceptData( owner ) ) {\n-\n-\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n-\t\t\t\t// use plain assignment\n-\t\t\t\tif ( owner.nodeType ) {\n-\t\t\t\t\towner[ this.expando ] = value;\n-\n-\t\t\t\t// Otherwise secure it in a non-enumerable property\n-\t\t\t\t// configurable must be true to allow the property to be\n-\t\t\t\t// deleted when data is removed\n-\t\t\t\t} else {\n-\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n-\t\t\t\t\t\tvalue: value,\n-\t\t\t\t\t\tconfigurable: true\n-\t\t\t\t\t} );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn value;\n-\t},\n-\tset: function( owner, data, value ) {\n-\t\tvar prop,\n-\t\t\tcache = this.cache( owner );\n-\n-\t\t// Handle: [ owner, key, value ] args\n-\t\t// Always use camelCase key (gh-2257)\n-\t\tif ( typeof data === \"string\" ) {\n-\t\t\tcache[ camelCase( data ) ] = value;\n-\n-\t\t// Handle: [ owner, { properties } ] args\n-\t\t} else {\n-\n-\t\t\t// Copy the properties one-by-one to the cache object\n-\t\t\tfor ( prop in data ) {\n-\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n-\t\t\t}\n-\t\t}\n-\t\treturn cache;\n-\t},\n-\tget: function( owner, key ) {\n-\t\treturn key === undefined ?\n-\t\t\tthis.cache( owner ) :\n-\n-\t\t\t// Always use camelCase key (gh-2257)\n-\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n-\t},\n-\taccess: function( owner, key, value ) {\n-\n-\t\t// In cases where either:\n-\t\t//\n-\t\t//   1. No key was specified\n-\t\t//   2. A string key was specified, but no value provided\n-\t\t//\n-\t\t// Take the \"read\" path and allow the get method to determine\n-\t\t// which value to return, respectively either:\n-\t\t//\n-\t\t//   1. The entire cache object\n-\t\t//   2. The data stored at the key\n-\t\t//\n-\t\tif ( key === undefined ||\n-\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n-\n-\t\t\treturn this.get( owner, key );\n-\t\t}\n-\n-\t\t// When the key is not a string, or both a key and value\n-\t\t// are specified, set or extend (existing objects) with either:\n-\t\t//\n-\t\t//   1. An object of properties\n-\t\t//   2. A key and value\n-\t\t//\n-\t\tthis.set( owner, key, value );\n-\n-\t\t// Since the \"set\" path can have two possible entry points\n-\t\t// return the expected data based on which path was taken[*]\n-\t\treturn value !== undefined ? value : key;\n-\t},\n-\tremove: function( owner, key ) {\n-\t\tvar i,\n-\t\t\tcache = owner[ this.expando ];\n-\n-\t\tif ( cache === undefined ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif ( key !== undefined ) {\n-\n-\t\t\t// Support array or space separated string of keys\n-\t\t\tif ( Array.isArray( key ) ) {\n-\n-\t\t\t\t// If key is an array of keys...\n-\t\t\t\t// We always set camelCase keys, so remove that.\n-\t\t\t\tkey = key.map( camelCase );\n-\t\t\t} else {\n-\t\t\t\tkey = camelCase( key );\n-\n-\t\t\t\t// If a key with the spaces exists, use it.\n-\t\t\t\t// Otherwise, create an array by matching non-whitespace\n-\t\t\t\tkey = key in cache ?\n-\t\t\t\t\t[ key ] :\n-\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n-\t\t\t}\n-\n-\t\t\ti = key.length;\n-\n-\t\t\twhile ( i-- ) {\n-\t\t\t\tdelete cache[ key[ i ] ];\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Remove the expando if there's no more data\n-\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n-\n-\t\t\t// Support: Chrome <=35 - 45\n-\t\t\t// Webkit & Blink performance suffers when deleting properties\n-\t\t\t// from DOM nodes, so set to undefined instead\n-\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n-\t\t\tif ( owner.nodeType ) {\n-\t\t\t\towner[ this.expando ] = undefined;\n-\t\t\t} else {\n-\t\t\t\tdelete owner[ this.expando ];\n-\t\t\t}\n-\t\t}\n-\t},\n-\thasData: function( owner ) {\n-\t\tvar cache = owner[ this.expando ];\n-\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n-\t}\n-};\n-var dataPriv = new Data();\n-\n-var dataUser = new Data();\n-\n-\n-\n-//\tImplementation Summary\n-//\n-//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n-//\t2. Improve the module's maintainability by reducing the storage\n-//\t\tpaths to a single mechanism.\n-//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n-//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n-//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n-//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n-\n-var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n-\trmultiDash = /[A-Z]/g;\n-\n-function getData( data ) {\n-\tif ( data === \"true\" ) {\n-\t\treturn true;\n-\t}\n-\n-\tif ( data === \"false\" ) {\n-\t\treturn false;\n-\t}\n-\n-\tif ( data === \"null\" ) {\n-\t\treturn null;\n-\t}\n-\n-\t// Only convert to a number if it doesn't change the string\n-\tif ( data === +data + \"\" ) {\n-\t\treturn +data;\n-\t}\n-\n-\tif ( rbrace.test( data ) ) {\n-\t\treturn JSON.parse( data );\n-\t}\n-\n-\treturn data;\n-}\n-\n-function dataAttr( elem, key, data ) {\n-\tvar name;\n-\n-\t// If nothing was found internally, try to fetch any\n-\t// data from the HTML5 data-* attribute\n-\tif ( data === undefined && elem.nodeType === 1 ) {\n-\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n-\t\tdata = elem.getAttribute( name );\n-\n-\t\tif ( typeof data === \"string\" ) {\n-\t\t\ttry {\n-\t\t\t\tdata = getData( data );\n-\t\t\t} catch ( e ) {}\n-\n-\t\t\t// Make sure we set the data so it isn't changed later\n-\t\t\tdataUser.set( elem, key, data );\n-\t\t} else {\n-\t\t\tdata = undefined;\n-\t\t}\n-\t}\n-\treturn data;\n-}\n-\n-jQuery.extend( {\n-\thasData: function( elem ) {\n-\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n-\t},\n-\n-\tdata: function( elem, name, data ) {\n-\t\treturn dataUser.access( elem, name, data );\n-\t},\n-\n-\tremoveData: function( elem, name ) {\n-\t\tdataUser.remove( elem, name );\n-\t},\n-\n-\t// TODO: Now that all calls to _data and _removeData have been replaced\n-\t// with direct calls to dataPriv methods, these can be deprecated.\n-\t_data: function( elem, name, data ) {\n-\t\treturn dataPriv.access( elem, name, data );\n-\t},\n-\n-\t_removeData: function( elem, name ) {\n-\t\tdataPriv.remove( elem, name );\n-\t}\n-} );\n-\n-jQuery.fn.extend( {\n-\tdata: function( key, value ) {\n-\t\tvar i, name, data,\n-\t\t\telem = this[ 0 ],\n-\t\t\tattrs = elem && elem.attributes;\n-\n-\t\t// Gets all values\n-\t\tif ( key === undefined ) {\n-\t\t\tif ( this.length ) {\n-\t\t\t\tdata = dataUser.get( elem );\n-\n-\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n-\t\t\t\t\ti = attrs.length;\n-\t\t\t\t\twhile ( i-- ) {\n-\n-\t\t\t\t\t\t// Support: IE 11 only\n-\t\t\t\t\t\t// The attrs elements can be null (trac-14894)\n-\t\t\t\t\t\tif ( attrs[ i ] ) {\n-\t\t\t\t\t\t\tname = attrs[ i ].name;\n-\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n-\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n-\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\treturn data;\n-\t\t}\n-\n-\t\t// Sets multiple values\n-\t\tif ( typeof key === \"object\" ) {\n-\t\t\treturn this.each( function() {\n-\t\t\t\tdataUser.set( this, key );\n-\t\t\t} );\n-\t\t}\n-\n-\t\treturn access( this, function( value ) {\n-\t\t\tvar data;\n-\n-\t\t\t// The calling jQuery object (element matches) is not empty\n-\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n-\t\t\t// `value` parameter was not undefined. An empty jQuery object\n-\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n-\t\t\t// throw an exception if an attempt to read a data cache is made.\n-\t\t\tif ( elem && value === undefined ) {\n-\n-\t\t\t\t// Attempt to get data from the cache\n-\t\t\t\t// The key will always be camelCased in Data\n-\t\t\t\tdata = dataUser.get( elem, key );\n-\t\t\t\tif ( data !== undefined ) {\n-\t\t\t\t\treturn data;\n-\t\t\t\t}\n-\n-\t\t\t\t// Attempt to \"discover\" the data in\n-\t\t\t\t// HTML5 custom data-* attrs\n-\t\t\t\tdata = dataAttr( elem, key );\n-\t\t\t\tif ( data !== undefined ) {\n-\t\t\t\t\treturn data;\n-\t\t\t\t}\n-\n-\t\t\t\t// We tried really hard, but the data doesn't exist.\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Set the data...\n-\t\t\tthis.each( function() {\n-\n-\t\t\t\t// We always store the camelCased key\n-\t\t\t\tdataUser.set( this, key, value );\n-\t\t\t} );\n-\t\t}, null, value, arguments.length > 1, null, true );\n-\t},\n-\n-\tremoveData: function( key ) {\n-\t\treturn this.each( function() {\n-\t\t\tdataUser.remove( this, key );\n-\t\t} );\n-\t}\n-} );\n-\n-\n-jQuery.extend( {\n-\tqueue: function( elem, type, data ) {\n-\t\tvar queue;\n-\n-\t\tif ( elem ) {\n-\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n-\t\t\tqueue = dataPriv.get( elem, type );\n-\n-\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n-\t\t\tif ( data ) {\n-\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n-\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n-\t\t\t\t} else {\n-\t\t\t\t\tqueue.push( data );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn queue || [];\n-\t\t}\n-\t},\n-\n-\tdequeue: function( elem, type ) {\n-\t\ttype = type || \"fx\";\n-\n-\t\tvar queue = jQuery.queue( elem, type ),\n-\t\t\tstartLength = queue.length,\n-\t\t\tfn = queue.shift(),\n-\t\t\thooks = jQuery._queueHooks( elem, type ),\n-\t\t\tnext = function() {\n-\t\t\t\tjQuery.dequeue( elem, type );\n-\t\t\t};\n-\n-\t\t// If the fx queue is dequeued, always remove the progress sentinel\n-\t\tif ( fn === \"inprogress\" ) {\n-\t\t\tfn = queue.shift();\n-\t\t\tstartLength--;\n-\t\t}\n-\n-\t\tif ( fn ) {\n-\n-\t\t\t// Add a progress sentinel to prevent the fx queue from being\n-\t\t\t// automatically dequeued\n-\t\t\tif ( type === \"fx\" ) {\n-\t\t\t\tqueue.unshift( \"inprogress\" );\n-\t\t\t}\n-\n-\t\t\t// Clear up the last queue stop function\n-\t\t\tdelete hooks.stop;\n-\t\t\tfn.call( elem, next, hooks );\n-\t\t}\n-\n-\t\tif ( !startLength && hooks ) {\n-\t\t\thooks.empty.fire();\n-\t\t}\n-\t},\n-\n-\t// Not public - generate a queueHooks object, or return the current one\n-\t_queueHooks: function( elem, type ) {\n-\t\tvar key = type + \"queueHooks\";\n-\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n-\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n-\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n-\t\t\t} )\n-\t\t} );\n-\t}\n-} );\n-\n-jQuery.fn.extend( {\n-\tqueue: function( type, data ) {\n-\t\tvar setter = 2;\n-\n-\t\tif ( typeof type !== \"string\" ) {\n-\t\t\tdata = type;\n-\t\t\ttype = \"fx\";\n-\t\t\tsetter--;\n-\t\t}\n-\n-\t\tif ( arguments.length < setter ) {\n-\t\t\treturn jQuery.queue( this[ 0 ], type );\n-\t\t}\n-\n-\t\treturn data === undefined ?\n-\t\t\tthis :\n-\t\t\tthis.each( function() {\n-\t\t\t\tvar queue = jQuery.queue( this, type, data );\n-\n-\t\t\t\t// Ensure a hooks for this queue\n-\t\t\t\tjQuery._queueHooks( this, type );\n-\n-\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n-\t\t\t\t\tjQuery.dequeue( this, type );\n-\t\t\t\t}\n-\t\t\t} );\n-\t},\n-\tdequeue: function( type ) {\n-\t\treturn this.each( function() {\n-\t\t\tjQuery.dequeue( this, type );\n-\t\t} );\n-\t},\n-\tclearQueue: function( type ) {\n-\t\treturn this.queue( type || \"fx\", [] );\n-\t},\n-\n-\t// Get a promise resolved when queues of a certain type\n-\t// are emptied (fx is the type by default)\n-\tpromise: function( type, obj ) {\n-\t\tvar tmp,\n-\t\t\tcount = 1,\n-\t\t\tdefer = jQuery.Deferred(),\n-\t\t\telements = this,\n-\t\t\ti = this.length,\n-\t\t\tresolve = function() {\n-\t\t\t\tif ( !( --count ) ) {\n-\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\tif ( typeof type !== \"string\" ) {\n-\t\t\tobj = type;\n-\t\t\ttype = undefined;\n-\t\t}\n-\t\ttype = type || \"fx\";\n-\n-\t\twhile ( i-- ) {\n-\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n-\t\t\tif ( tmp && tmp.empty ) {\n-\t\t\t\tcount++;\n-\t\t\t\ttmp.empty.add( resolve );\n-\t\t\t}\n-\t\t}\n-\t\tresolve();\n-\t\treturn defer.promise( obj );\n-\t}\n-} );\n-var pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n-\n-var rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n-\n-\n-var cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n-\n-var documentElement = document.documentElement;\n-\n-\n-\n-\tvar isAttached = function( elem ) {\n-\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n-\t\t},\n-\t\tcomposed = { composed: true };\n-\n-\t// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n-\t// Check attachment across shadow DOM boundaries when possible (gh-3504)\n-\t// Support: iOS 10.0-10.2 only\n-\t// Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n-\t// leading to errors. We need to check for `getRootNode`.\n-\tif ( documentElement.getRootNode ) {\n-\t\tisAttached = function( elem ) {\n-\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n-\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n-\t\t};\n-\t}\n-var isHiddenWithinTree = function( elem, el ) {\n-\n-\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n-\t\t// in that case, element will be second argument\n-\t\telem = el || elem;\n-\n-\t\t// Inline style trumps all\n-\t\treturn elem.style.display === \"none\" ||\n-\t\t\telem.style.display === \"\" &&\n-\n-\t\t\t// Otherwise, check computed style\n-\t\t\t// Support: Firefox <=43 - 45\n-\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n-\t\t\t// in the document.\n-\t\t\tisAttached( elem ) &&\n-\n-\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n-\t};\n-\n-\n-\n-function adjustCSS( elem, prop, valueParts, tween ) {\n-\tvar adjusted, scale,\n-\t\tmaxIterations = 20,\n-\t\tcurrentValue = tween ?\n-\t\t\tfunction() {\n-\t\t\t\treturn tween.cur();\n-\t\t\t} :\n-\t\t\tfunction() {\n-\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n-\t\t\t},\n-\t\tinitial = currentValue(),\n-\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n-\n-\t\t// Starting value computation is required for potential unit mismatches\n-\t\tinitialInUnit = elem.nodeType &&\n-\t\t\t( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n-\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n-\n-\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n-\n-\t\t// Support: Firefox <=54\n-\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n-\t\tinitial = initial / 2;\n-\n-\t\t// Trust units reported by jQuery.css\n-\t\tunit = unit || initialInUnit[ 3 ];\n-\n-\t\t// Iteratively approximate from a nonzero starting point\n-\t\tinitialInUnit = +initial || 1;\n-\n-\t\twhile ( maxIterations-- ) {\n-\n-\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n-\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n-\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n-\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n-\t\t\t\tmaxIterations = 0;\n-\t\t\t}\n-\t\t\tinitialInUnit = initialInUnit / scale;\n-\n-\t\t}\n-\n-\t\tinitialInUnit = initialInUnit * 2;\n-\t\tjQuery.style( elem, prop, initialInUnit + unit );\n-\n-\t\t// Make sure we update the tween properties later on\n-\t\tvalueParts = valueParts || [];\n-\t}\n-\n-\tif ( valueParts ) {\n-\t\tinitialInUnit = +initialInUnit || +initial || 0;\n-\n-\t\t// Apply relative offset (+=/-=) if specified\n-\t\tadjusted = valueParts[ 1 ] ?\n-\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n-\t\t\t+valueParts[ 2 ];\n-\t\tif ( tween ) {\n-\t\t\ttween.unit = unit;\n-\t\t\ttween.start = initialInUnit;\n-\t\t\ttween.end = adjusted;\n-\t\t}\n-\t}\n-\treturn adjusted;\n-}\n-\n-\n-var defaultDisplayMap = {};\n-\n-function getDefaultDisplay( elem ) {\n-\tvar temp,\n-\t\tdoc = elem.ownerDocument,\n-\t\tnodeName = elem.nodeName,\n-\t\tdisplay = defaultDisplayMap[ nodeName ];\n-\n-\tif ( display ) {\n-\t\treturn display;\n-\t}\n-\n-\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n-\tdisplay = jQuery.css( temp, \"display\" );\n-\n-\ttemp.parentNode.removeChild( temp );\n-\n-\tif ( display === \"none\" ) {\n-\t\tdisplay = \"block\";\n-\t}\n-\tdefaultDisplayMap[ nodeName ] = display;\n-\n-\treturn display;\n-}\n-\n-function showHide( elements, show ) {\n-\tvar display, elem,\n-\t\tvalues = [],\n-\t\tindex = 0,\n-\t\tlength = elements.length;\n-\n-\t// Determine new display value for elements that need to change\n-\tfor ( ; index < length; index++ ) {\n-\t\telem = elements[ index ];\n-\t\tif ( !elem.style ) {\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tdisplay = elem.style.display;\n-\t\tif ( show ) {\n-\n-\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n-\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n-\t\t\t// inline or about-to-be-restored)\n-\t\t\tif ( display === \"none\" ) {\n-\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n-\t\t\t\tif ( !values[ index ] ) {\n-\t\t\t\t\telem.style.display = \"\";\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n-\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif ( display !== \"none\" ) {\n-\t\t\t\tvalues[ index ] = \"none\";\n-\n-\t\t\t\t// Remember what we're overwriting\n-\t\t\t\tdataPriv.set( elem, \"display\", display );\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Set the display of the elements in a second loop to avoid constant reflow\n-\tfor ( index = 0; index < length; index++ ) {\n-\t\tif ( values[ index ] != null ) {\n-\t\t\telements[ index ].style.display = values[ index ];\n-\t\t}\n-\t}\n-\n-\treturn elements;\n-}\n-\n-jQuery.fn.extend( {\n-\tshow: function() {\n-\t\treturn showHide( this, true );\n-\t},\n-\thide: function() {\n-\t\treturn showHide( this );\n-\t},\n-\ttoggle: function( state ) {\n-\t\tif ( typeof state === \"boolean\" ) {\n-\t\t\treturn state ? this.show() : this.hide();\n-\t\t}\n-\n-\t\treturn this.each( function() {\n-\t\t\tif ( isHiddenWithinTree( this ) ) {\n-\t\t\t\tjQuery( this ).show();\n-\t\t\t} else {\n-\t\t\t\tjQuery( this ).hide();\n-\t\t\t}\n-\t\t} );\n-\t}\n-} );\n-var rcheckableType = ( /^(?:checkbox|radio)$/i );\n-\n-var rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i );\n-\n-var rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n-\n-\n-\n-( function() {\n-\tvar fragment = document.createDocumentFragment(),\n-\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n-\t\tinput = document.createElement( \"input\" );\n-\n-\t// Support: Android 4.0 - 4.3 only\n-\t// Check state lost if the name is set (trac-11217)\n-\t// Support: Windows Web Apps (WWA)\n-\t// `name` and `type` must use .setAttribute for WWA (trac-14901)\n-\tinput.setAttribute( \"type\", \"radio\" );\n-\tinput.setAttribute( \"checked\", \"checked\" );\n-\tinput.setAttribute( \"name\", \"t\" );\n-\n-\tdiv.appendChild( input );\n-\n-\t// Support: Android <=4.1 only\n-\t// Older WebKit doesn't clone checked state correctly in fragments\n-\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n-\n-\t// Support: IE <=11 only\n-\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n-\tdiv.innerHTML = \"<textarea>x</textarea>\";\n-\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n-\n-\t// Support: IE <=9 only\n-\t// IE <=9 replaces <option> tags with their contents when inserted outside of\n-\t// the select element.\n-\tdiv.innerHTML = \"<option></option>\";\n-\tsupport.option = !!div.lastChild;\n-} )();\n-\n-\n-// We have to close these tags to support XHTML (trac-13200)\n-var wrapMap = {\n-\n-\t// XHTML parsers do not magically insert elements in the\n-\t// same way that tag soup parsers do. So we cannot shorten\n-\t// this by omitting <tbody> or other required elements.\n-\tthead: [ 1, \"<table>\", \"</table>\" ],\n-\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n-\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n-\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n-\n-\t_default: [ 0, \"\", \"\" ]\n-};\n-\n-wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n-wrapMap.th = wrapMap.td;\n-\n-// Support: IE <=9 only\n-if ( !support.option ) {\n-\twrapMap.optgroup = wrapMap.option = [ 1, \"<select multiple='multiple'>\", \"</select>\" ];\n-}\n-\n-\n-function getAll( context, tag ) {\n-\n-\t// Support: IE <=9 - 11 only\n-\t// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)\n-\tvar ret;\n-\n-\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n-\t\tret = context.getElementsByTagName( tag || \"*\" );\n-\n-\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n-\t\tret = context.querySelectorAll( tag || \"*\" );\n-\n-\t} else {\n-\t\tret = [];\n-\t}\n-\n-\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n-\t\treturn jQuery.merge( [ context ], ret );\n-\t}\n-\n-\treturn ret;\n-}\n-\n-\n-// Mark scripts as having already been evaluated\n-function setGlobalEval( elems, refElements ) {\n-\tvar i = 0,\n-\t\tl = elems.length;\n-\n-\tfor ( ; i < l; i++ ) {\n-\t\tdataPriv.set(\n-\t\t\telems[ i ],\n-\t\t\t\"globalEval\",\n-\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n-\t\t);\n-\t}\n-}\n-\n-\n-var rhtml = /<|&#?\\w+;/;\n-\n-function buildFragment( elems, context, scripts, selection, ignored ) {\n-\tvar elem, tmp, tag, wrap, attached, j,\n-\t\tfragment = context.createDocumentFragment(),\n-\t\tnodes = [],\n-\t\ti = 0,\n-\t\tl = elems.length;\n-\n-\tfor ( ; i < l; i++ ) {\n-\t\telem = elems[ i ];\n-\n-\t\tif ( elem || elem === 0 ) {\n-\n-\t\t\t// Add nodes directly\n-\t\t\tif ( toType( elem ) === \"object\" ) {\n-\n-\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n-\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n-\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n-\n-\t\t\t// Convert non-html into a text node\n-\t\t\t} else if ( !rhtml.test( elem ) ) {\n-\t\t\t\tnodes.push( context.createTextNode( elem ) );\n-\n-\t\t\t// Convert html into DOM nodes\n-\t\t\t} else {\n-\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n-\n-\t\t\t\t// Deserialize a standard representation\n-\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n-\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n-\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n-\n-\t\t\t\t// Descend through wrappers to the right content\n-\t\t\t\tj = wrap[ 0 ];\n-\t\t\t\twhile ( j-- ) {\n-\t\t\t\t\ttmp = tmp.lastChild;\n-\t\t\t\t}\n-\n-\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n-\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n-\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n-\n-\t\t\t\t// Remember the top-level container\n-\t\t\t\ttmp = fragment.firstChild;\n-\n-\t\t\t\t// Ensure the created nodes are orphaned (trac-12392)\n-\t\t\t\ttmp.textContent = \"\";\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Remove wrapper from fragment\n-\tfragment.textContent = \"\";\n-\n-\ti = 0;\n-\twhile ( ( elem = nodes[ i++ ] ) ) {\n-\n-\t\t// Skip elements already in the context collection (trac-4087)\n-\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n-\t\t\tif ( ignored ) {\n-\t\t\t\tignored.push( elem );\n-\t\t\t}\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tattached = isAttached( elem );\n-\n-\t\t// Append to fragment\n-\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n-\n-\t\t// Preserve script evaluation history\n-\t\tif ( attached ) {\n-\t\t\tsetGlobalEval( tmp );\n-\t\t}\n-\n-\t\t// Capture executables\n-\t\tif ( scripts ) {\n-\t\t\tj = 0;\n-\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n-\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n-\t\t\t\t\tscripts.push( elem );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn fragment;\n-}\n-\n-\n-var rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n-\n-function returnTrue() {\n-\treturn true;\n-}\n-\n-function returnFalse() {\n-\treturn false;\n-}\n-\n-// Support: IE <=9 - 11+\n-// focus() and blur() are asynchronous, except when they are no-op.\n-// So expect focus to be synchronous when the element is already active,\n-// and blur to be synchronous when the element is not already active.\n-// (focus and blur are always synchronous in other supported browsers,\n-// this just defines when we can count on it).\n-function expectSync( elem, type ) {\n-\treturn ( elem === safeActiveElement() ) === ( type === \"focus\" );\n-}\n-\n-// Support: IE <=9 only\n-// Accessing document.activeElement can throw unexpectedly\n-// https://bugs.jquery.com/ticket/13393\n-function safeActiveElement() {\n-\ttry {\n-\t\treturn document.activeElement;\n-\t} catch ( err ) { }\n-}\n-\n-function on( elem, types, selector, data, fn, one ) {\n-\tvar origFn, type;\n-\n-\t// Types can be a map of types/handlers\n-\tif ( typeof types === \"object\" ) {\n-\n-\t\t// ( types-Object, selector, data )\n-\t\tif ( typeof selector !== \"string\" ) {\n-\n-\t\t\t// ( types-Object, data )\n-\t\t\tdata = data || selector;\n-\t\t\tselector = undefined;\n-\t\t}\n-\t\tfor ( type in types ) {\n-\t\t\ton( elem, type, selector, data, types[ type ], one );\n-\t\t}\n-\t\treturn elem;\n-\t}\n-\n-\tif ( data == null && fn == null ) {\n-\n-\t\t// ( types, fn )\n-\t\tfn = selector;\n-\t\tdata = selector = undefined;\n-\t} else if ( fn == null ) {\n-\t\tif ( typeof selector === \"string\" ) {\n-\n-\t\t\t// ( types, selector, fn )\n-\t\t\tfn = data;\n-\t\t\tdata = undefined;\n-\t\t} else {\n-\n-\t\t\t// ( types, data, fn )\n-\t\t\tfn = data;\n-\t\t\tdata = selector;\n-\t\t\tselector = undefined;\n-\t\t}\n-\t}\n-\tif ( fn === false ) {\n-\t\tfn = returnFalse;\n-\t} else if ( !fn ) {\n-\t\treturn elem;\n-\t}\n-\n-\tif ( one === 1 ) {\n-\t\torigFn = fn;\n-\t\tfn = function( event ) {\n-\n-\t\t\t// Can use an empty set, since event contains the info\n-\t\t\tjQuery().off( event );\n-\t\t\treturn origFn.apply( this, arguments );\n-\t\t};\n-\n-\t\t// Use same guid so caller can remove using origFn\n-\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n-\t}\n-\treturn elem.each( function() {\n-\t\tjQuery.event.add( this, types, fn, data, selector );\n-\t} );\n-}\n-\n-/*\n- * Helper functions for managing events -- not part of the public interface.\n- * Props to Dean Edwards' addEvent library for many of the ideas.\n- */\n-jQuery.event = {\n-\n-\tglobal: {},\n-\n-\tadd: function( elem, types, handler, data, selector ) {\n-\n-\t\tvar handleObjIn, eventHandle, tmp,\n-\t\t\tevents, t, handleObj,\n-\t\t\tspecial, handlers, type, namespaces, origType,\n-\t\t\telemData = dataPriv.get( elem );\n-\n-\t\t// Only attach events to objects that accept data\n-\t\tif ( !acceptData( elem ) ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Caller can pass in an object of custom data in lieu of the handler\n-\t\tif ( handler.handler ) {\n-\t\t\thandleObjIn = handler;\n-\t\t\thandler = handleObjIn.handler;\n-\t\t\tselector = handleObjIn.selector;\n-\t\t}\n-\n-\t\t// Ensure that invalid selectors throw exceptions at attach time\n-\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n-\t\tif ( selector ) {\n-\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n-\t\t}\n-\n-\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n-\t\tif ( !handler.guid ) {\n-\t\t\thandler.guid = jQuery.guid++;\n-\t\t}\n-\n-\t\t// Init the element's event structure and main handler, if this is the first\n-\t\tif ( !( events = elemData.events ) ) {\n-\t\t\tevents = elemData.events = Object.create( null );\n-\t\t}\n-\t\tif ( !( eventHandle = elemData.handle ) ) {\n-\t\t\teventHandle = elemData.handle = function( e ) {\n-\n-\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n-\t\t\t\t// when an event is called after a page has unloaded\n-\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n-\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n-\t\t\t};\n-\t\t}\n-\n-\t\t// Handle multiple events separated by a space\n-\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n-\t\tt = types.length;\n-\t\twhile ( t-- ) {\n-\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n-\t\t\ttype = origType = tmp[ 1 ];\n-\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n-\n-\t\t\t// There *must* be a type, no attaching namespace-only handlers\n-\t\t\tif ( !type ) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\t// If event changes its type, use the special event handlers for the changed type\n-\t\t\tspecial = jQuery.event.special[ type ] || {};\n-\n-\t\t\t// If selector defined, determine special event api type, otherwise given type\n-\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n-\n-\t\t\t// Update special based on newly reset type\n-\t\t\tspecial = jQuery.event.special[ type ] || {};\n-\n-\t\t\t// handleObj is passed to all event handlers\n-\t\t\thandleObj = jQuery.extend( {\n-\t\t\t\ttype: type,\n-\t\t\t\torigType: origType,\n-\t\t\t\tdata: data,\n-\t\t\t\thandler: handler,\n-\t\t\t\tguid: handler.guid,\n-\t\t\t\tselector: selector,\n-\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n-\t\t\t\tnamespace: namespaces.join( \".\" )\n-\t\t\t}, handleObjIn );\n-\n-\t\t\t// Init the event handler queue if we're the first\n-\t\t\tif ( !( handlers = events[ type ] ) ) {\n-\t\t\t\thandlers = events[ type ] = [];\n-\t\t\t\thandlers.delegateCount = 0;\n-\n-\t\t\t\t// Only use addEventListener if the special events handler returns false\n-\t\t\t\tif ( !special.setup ||\n-\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n-\n-\t\t\t\t\tif ( elem.addEventListener ) {\n-\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif ( special.add ) {\n-\t\t\t\tspecial.add.call( elem, handleObj );\n-\n-\t\t\t\tif ( !handleObj.handler.guid ) {\n-\t\t\t\t\thandleObj.handler.guid = handler.guid;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Add to the element's handler list, delegates in front\n-\t\t\tif ( selector ) {\n-\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n-\t\t\t} else {\n-\t\t\t\thandlers.push( handleObj );\n-\t\t\t}\n-\n-\t\t\t// Keep track of which events have ever been used, for event optimization\n-\t\t\tjQuery.event.global[ type ] = true;\n-\t\t}\n-\n-\t},\n-\n-\t// Detach an event or set of events from an element\n-\tremove: function( elem, types, handler, selector, mappedTypes ) {\n-\n-\t\tvar j, origCount, tmp,\n-\t\t\tevents, t, handleObj,\n-\t\t\tspecial, handlers, type, namespaces, origType,\n-\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n-\n-\t\tif ( !elemData || !( events = elemData.events ) ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Once for each type.namespace in types; type may be omitted\n-\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n-\t\tt = types.length;\n-\t\twhile ( t-- ) {\n-\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n-\t\t\ttype = origType = tmp[ 1 ];\n-\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n-\n-\t\t\t// Unbind all events (on this namespace, if provided) for the element\n-\t\t\tif ( !type ) {\n-\t\t\t\tfor ( type in events ) {\n-\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n-\t\t\t\t}\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tspecial = jQuery.event.special[ type ] || {};\n-\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n-\t\t\thandlers = events[ type ] || [];\n-\t\t\ttmp = tmp[ 2 ] &&\n-\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n-\n-\t\t\t// Remove matching events\n-\t\t\torigCount = j = handlers.length;\n-\t\t\twhile ( j-- ) {\n-\t\t\t\thandleObj = handlers[ j ];\n-\n-\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n-\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n-\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n-\t\t\t\t\t( !selector || selector === handleObj.selector ||\n-\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n-\t\t\t\t\thandlers.splice( j, 1 );\n-\n-\t\t\t\t\tif ( handleObj.selector ) {\n-\t\t\t\t\t\thandlers.delegateCount--;\n-\t\t\t\t\t}\n-\t\t\t\t\tif ( special.remove ) {\n-\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n-\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n-\t\t\tif ( origCount && !handlers.length ) {\n-\t\t\t\tif ( !special.teardown ||\n-\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n-\n-\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n-\t\t\t\t}\n-\n-\t\t\t\tdelete events[ type ];\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Remove data and the expando if it's no longer used\n-\t\tif ( jQuery.isEmptyObject( events ) ) {\n-\t\t\tdataPriv.remove( elem, \"handle events\" );\n-\t\t}\n-\t},\n-\n-\tdispatch: function( nativeEvent ) {\n-\n-\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n-\t\t\targs = new Array( arguments.length ),\n-\n-\t\t\t// Make a writable jQuery.Event from the native event object\n-\t\t\tevent = jQuery.event.fix( nativeEvent ),\n-\n-\t\t\thandlers = (\n-\t\t\t\tdataPriv.get( this, \"events\" ) || Object.create( null )\n-\t\t\t)[ event.type ] || [],\n-\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n-\n-\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n-\t\targs[ 0 ] = event;\n-\n-\t\tfor ( i = 1; i < arguments.length; i++ ) {\n-\t\t\targs[ i ] = arguments[ i ];\n-\t\t}\n-\n-\t\tevent.delegateTarget = this;\n-\n-\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n-\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Determine handlers\n-\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n-\n-\t\t// Run delegates first; they may want to stop propagation beneath us\n-\t\ti = 0;\n-\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n-\t\t\tevent.currentTarget = matched.elem;\n-\n-\t\t\tj = 0;\n-\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n-\t\t\t\t!event.isImmediatePropagationStopped() ) {\n-\n-\t\t\t\t// If the event is namespaced, then each handler is only invoked if it is\n-\t\t\t\t// specially universal or its namespaces are a superset of the event's.\n-\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n-\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n-\n-\t\t\t\t\tevent.handleObj = handleObj;\n-\t\t\t\t\tevent.data = handleObj.data;\n-\n-\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n-\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n-\n-\t\t\t\t\tif ( ret !== undefined ) {\n-\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n-\t\t\t\t\t\t\tevent.preventDefault();\n-\t\t\t\t\t\t\tevent.stopPropagation();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Call the postDispatch hook for the mapped type\n-\t\tif ( special.postDispatch ) {\n-\t\t\tspecial.postDispatch.call( this, event );\n-\t\t}\n-\n-\t\treturn event.result;\n-\t},\n-\n-\thandlers: function( event, handlers ) {\n-\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n-\t\t\thandlerQueue = [],\n-\t\t\tdelegateCount = handlers.delegateCount,\n-\t\t\tcur = event.target;\n-\n-\t\t// Find delegate handlers\n-\t\tif ( delegateCount &&\n-\n-\t\t\t// Support: IE <=9\n-\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n-\t\t\tcur.nodeType &&\n-\n-\t\t\t// Support: Firefox <=42\n-\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n-\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n-\t\t\t// Support: IE 11 only\n-\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n-\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n-\n-\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n-\n-\t\t\t\t// Don't check non-elements (trac-13208)\n-\t\t\t\t// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n-\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n-\t\t\t\t\tmatchedHandlers = [];\n-\t\t\t\t\tmatchedSelectors = {};\n-\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n-\t\t\t\t\t\thandleObj = handlers[ i ];\n-\n-\t\t\t\t\t\t// Don't conflict with Object.prototype properties (trac-13203)\n-\t\t\t\t\t\tsel = handleObj.selector + \" \";\n-\n-\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n-\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n-\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n-\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n-\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif ( matchedHandlers.length ) {\n-\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Add the remaining (directly-bound) handlers\n-\t\tcur = this;\n-\t\tif ( delegateCount < handlers.length ) {\n-\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n-\t\t}\n-\n-\t\treturn handlerQueue;\n-\t},\n-\n-\taddProp: function( name, hook ) {\n-\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n-\t\t\tenumerable: true,\n-\t\t\tconfigurable: true,\n-\n-\t\t\tget: isFunction( hook ) ?\n-\t\t\t\tfunction() {\n-\t\t\t\t\tif ( this.originalEvent ) {\n-\t\t\t\t\t\treturn hook( this.originalEvent );\n-\t\t\t\t\t}\n-\t\t\t\t} :\n-\t\t\t\tfunction() {\n-\t\t\t\t\tif ( this.originalEvent ) {\n-\t\t\t\t\t\treturn this.originalEvent[ name ];\n-\t\t\t\t\t}\n-\t\t\t\t},\n-\n-\t\t\tset: function( value ) {\n-\t\t\t\tObject.defineProperty( this, name, {\n-\t\t\t\t\tenumerable: true,\n-\t\t\t\t\tconfigurable: true,\n-\t\t\t\t\twritable: true,\n-\t\t\t\t\tvalue: value\n-\t\t\t\t} );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\tfix: function( originalEvent ) {\n-\t\treturn originalEvent[ jQuery.expando ] ?\n-\t\t\toriginalEvent :\n-\t\t\tnew jQuery.Event( originalEvent );\n-\t},\n-\n-\tspecial: {\n-\t\tload: {\n-\n-\t\t\t// Prevent triggered image.load events from bubbling to window.load\n-\t\t\tnoBubble: true\n-\t\t},\n-\t\tclick: {\n-\n-\t\t\t// Utilize native event to ensure correct state for checkable inputs\n-\t\t\tsetup: function( data ) {\n-\n-\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n-\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n-\t\t\t\tvar el = this || data;\n-\n-\t\t\t\t// Claim the first handler\n-\t\t\t\tif ( rcheckableType.test( el.type ) &&\n-\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n-\n-\t\t\t\t\t// dataPriv.set( el, \"click\", ... )\n-\t\t\t\t\tleverageNative( el, \"click\", returnTrue );\n-\t\t\t\t}\n-\n-\t\t\t\t// Return false to allow normal processing in the caller\n-\t\t\t\treturn false;\n-\t\t\t},\n-\t\t\ttrigger: function( data ) {\n-\n-\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n-\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n-\t\t\t\tvar el = this || data;\n-\n-\t\t\t\t// Force setup before triggering a click\n-\t\t\t\tif ( rcheckableType.test( el.type ) &&\n-\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n-\n-\t\t\t\t\tleverageNative( el, \"click\" );\n-\t\t\t\t}\n-\n-\t\t\t\t// Return non-false to allow normal event-path propagation\n-\t\t\t\treturn true;\n-\t\t\t},\n-\n-\t\t\t// For cross-browser consistency, suppress native .click() on links\n-\t\t\t// Also prevent it if we're currently inside a leveraged native-event stack\n-\t\t\t_default: function( event ) {\n-\t\t\t\tvar target = event.target;\n-\t\t\t\treturn rcheckableType.test( target.type ) &&\n-\t\t\t\t\ttarget.click && nodeName( target, \"input\" ) &&\n-\t\t\t\t\tdataPriv.get( target, \"click\" ) ||\n-\t\t\t\t\tnodeName( target, \"a\" );\n-\t\t\t}\n-\t\t},\n-\n-\t\tbeforeunload: {\n-\t\t\tpostDispatch: function( event ) {\n-\n-\t\t\t\t// Support: Firefox 20+\n-\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n-\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n-\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-};\n-\n-// Ensure the presence of an event listener that handles manually-triggered\n-// synthetic events by interrupting progress until reinvoked in response to\n-// *native* events that it fires directly, ensuring that state changes have\n-// already occurred before other listeners are invoked.\n-function leverageNative( el, type, expectSync ) {\n-\n-\t// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n-\tif ( !expectSync ) {\n-\t\tif ( dataPriv.get( el, type ) === undefined ) {\n-\t\t\tjQuery.event.add( el, type, returnTrue );\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\t// Register the controller as a special universal handler for all event namespaces\n-\tdataPriv.set( el, type, false );\n-\tjQuery.event.add( el, type, {\n-\t\tnamespace: false,\n-\t\thandler: function( event ) {\n-\t\t\tvar notAsync, result,\n-\t\t\t\tsaved = dataPriv.get( this, type );\n-\n-\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n-\n-\t\t\t\t// Interrupt processing of the outer synthetic .trigger()ed event\n-\t\t\t\t// Saved data should be false in such cases, but might be a leftover capture object\n-\t\t\t\t// from an async native handler (gh-4350)\n-\t\t\t\tif ( !saved.length ) {\n-\n-\t\t\t\t\t// Store arguments for use when handling the inner native event\n-\t\t\t\t\t// There will always be at least one argument (an event object), so this array\n-\t\t\t\t\t// will not be confused with a leftover capture object.\n-\t\t\t\t\tsaved = slice.call( arguments );\n-\t\t\t\t\tdataPriv.set( this, type, saved );\n-\n-\t\t\t\t\t// Trigger the native event and capture its result\n-\t\t\t\t\t// Support: IE <=9 - 11+\n-\t\t\t\t\t// focus() and blur() are asynchronous\n-\t\t\t\t\tnotAsync = expectSync( this, type );\n-\t\t\t\t\tthis[ type ]();\n-\t\t\t\t\tresult = dataPriv.get( this, type );\n-\t\t\t\t\tif ( saved !== result || notAsync ) {\n-\t\t\t\t\t\tdataPriv.set( this, type, false );\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tresult = {};\n-\t\t\t\t\t}\n-\t\t\t\t\tif ( saved !== result ) {\n-\n-\t\t\t\t\t\t// Cancel the outer synthetic event\n-\t\t\t\t\t\tevent.stopImmediatePropagation();\n-\t\t\t\t\t\tevent.preventDefault();\n-\n-\t\t\t\t\t\t// Support: Chrome 86+\n-\t\t\t\t\t\t// In Chrome, if an element having a focusout handler is blurred by\n-\t\t\t\t\t\t// clicking outside of it, it invokes the handler synchronously. If\n-\t\t\t\t\t\t// that handler calls `.remove()` on the element, the data is cleared,\n-\t\t\t\t\t\t// leaving `result` undefined. We need to guard against this.\n-\t\t\t\t\t\treturn result && result.value;\n-\t\t\t\t\t}\n-\n-\t\t\t\t// If this is an inner synthetic event for an event with a bubbling surrogate\n-\t\t\t\t// (focus or blur), assume that the surrogate already propagated from triggering the\n-\t\t\t\t// native event and prevent that from happening again here.\n-\t\t\t\t// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n-\t\t\t\t// bubbling surrogate propagates *after* the non-bubbling base), but that seems\n-\t\t\t\t// less bad than duplication.\n-\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n-\t\t\t\t\tevent.stopPropagation();\n-\t\t\t\t}\n-\n-\t\t\t// If this is a native event triggered above, everything is now in order\n-\t\t\t// Fire an inner synthetic event with the original arguments\n-\t\t\t} else if ( saved.length ) {\n-\n-\t\t\t\t// ...and capture the result\n-\t\t\t\tdataPriv.set( this, type, {\n-\t\t\t\t\tvalue: jQuery.event.trigger(\n-\n-\t\t\t\t\t\t// Support: IE <=9 - 11+\n-\t\t\t\t\t\t// Extend with the prototype to reset the above stopImmediatePropagation()\n-\t\t\t\t\t\tjQuery.extend( saved[ 0 ], jQuery.Event.prototype ),\n-\t\t\t\t\t\tsaved.slice( 1 ),\n-\t\t\t\t\t\tthis\n-\t\t\t\t\t)\n-\t\t\t\t} );\n-\n-\t\t\t\t// Abort handling of the native event\n-\t\t\t\tevent.stopImmediatePropagation();\n-\t\t\t}\n-\t\t}\n-\t} );\n-}\n-\n-jQuery.removeEvent = function( elem, type, handle ) {\n-\n-\t// This \"if\" is needed for plain objects\n-\tif ( elem.removeEventListener ) {\n-\t\telem.removeEventListener( type, handle );\n-\t}\n-};\n-\n-jQuery.Event = function( src, props ) {\n-\n-\t// Allow instantiation without the 'new' keyword\n-\tif ( !( this instanceof jQuery.Event ) ) {\n-\t\treturn new jQuery.Event( src, props );\n-\t}\n-\n-\t// Event object\n-\tif ( src && src.type ) {\n-\t\tthis.originalEvent = src;\n-\t\tthis.type = src.type;\n-\n-\t\t// Events bubbling up the document may have been marked as prevented\n-\t\t// by a handler lower down the tree; reflect the correct value.\n-\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n-\t\t\t\tsrc.defaultPrevented === undefined &&\n-\n-\t\t\t\t// Support: Android <=2.3 only\n-\t\t\t\tsrc.returnValue === false ?\n-\t\t\treturnTrue :\n-\t\t\treturnFalse;\n-\n-\t\t// Create target properties\n-\t\t// Support: Safari <=6 - 7 only\n-\t\t// Target should not be a text node (trac-504, trac-13143)\n-\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n-\t\t\tsrc.target.parentNode :\n-\t\t\tsrc.target;\n-\n-\t\tthis.currentTarget = src.currentTarget;\n-\t\tthis.relatedTarget = src.relatedTarget;\n-\n-\t// Event type\n-\t} else {\n-\t\tthis.type = src;\n-\t}\n-\n-\t// Put explicitly provided properties onto the event object\n-\tif ( props ) {\n-\t\tjQuery.extend( this, props );\n-\t}\n-\n-\t// Create a timestamp if incoming event doesn't have one\n-\tthis.timeStamp = src && src.timeStamp || Date.now();\n-\n-\t// Mark it as fixed\n-\tthis[ jQuery.expando ] = true;\n-};\n-\n-// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n-// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n-jQuery.Event.prototype = {\n-\tconstructor: jQuery.Event,\n-\tisDefaultPrevented: returnFalse,\n-\tisPropagationStopped: returnFalse,\n-\tisImmediatePropagationStopped: returnFalse,\n-\tisSimulated: false,\n-\n-\tpreventDefault: function() {\n-\t\tvar e = this.originalEvent;\n-\n-\t\tthis.isDefaultPrevented = returnTrue;\n-\n-\t\tif ( e && !this.isSimulated ) {\n-\t\t\te.preventDefault();\n-\t\t}\n-\t},\n-\tstopPropagation: function() {\n-\t\tvar e = this.originalEvent;\n-\n-\t\tthis.isPropagationStopped = returnTrue;\n-\n-\t\tif ( e && !this.isSimulated ) {\n-\t\t\te.stopPropagation();\n-\t\t}\n-\t},\n-\tstopImmediatePropagation: function() {\n-\t\tvar e = this.originalEvent;\n-\n-\t\tthis.isImmediatePropagationStopped = returnTrue;\n-\n-\t\tif ( e && !this.isSimulated ) {\n-\t\t\te.stopImmediatePropagation();\n-\t\t}\n-\n-\t\tthis.stopPropagation();\n-\t}\n-};\n-\n-// Includes all common event props including KeyEvent and MouseEvent specific props\n-jQuery.each( {\n-\taltKey: true,\n-\tbubbles: true,\n-\tcancelable: true,\n-\tchangedTouches: true,\n-\tctrlKey: true,\n-\tdetail: true,\n-\teventPhase: true,\n-\tmetaKey: true,\n-\tpageX: true,\n-\tpageY: true,\n-\tshiftKey: true,\n-\tview: true,\n-\t\"char\": true,\n-\tcode: true,\n-\tcharCode: true,\n-\tkey: true,\n-\tkeyCode: true,\n-\tbutton: true,\n-\tbuttons: true,\n-\tclientX: true,\n-\tclientY: true,\n-\toffsetX: true,\n-\toffsetY: true,\n-\tpointerId: true,\n-\tpointerType: true,\n-\tscreenX: true,\n-\tscreenY: true,\n-\ttargetTouches: true,\n-\ttoElement: true,\n-\ttouches: true,\n-\twhich: true\n-}, jQuery.event.addProp );\n-\n-jQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( type, delegateType ) {\n-\tjQuery.event.special[ type ] = {\n-\n-\t\t// Utilize native event if possible so blur/focus sequence is correct\n-\t\tsetup: function() {\n-\n-\t\t\t// Claim the first handler\n-\t\t\t// dataPriv.set( this, \"focus\", ... )\n-\t\t\t// dataPriv.set( this, \"blur\", ... )\n-\t\t\tleverageNative( this, type, expectSync );\n-\n-\t\t\t// Return false to allow normal processing in the caller\n-\t\t\treturn false;\n-\t\t},\n-\t\ttrigger: function() {\n-\n-\t\t\t// Force setup before trigger\n-\t\t\tleverageNative( this, type );\n-\n-\t\t\t// Return non-false to allow normal event-path propagation\n-\t\t\treturn true;\n-\t\t},\n-\n-\t\t// Suppress native focus or blur if we're currently inside\n-\t\t// a leveraged native-event stack\n-\t\t_default: function( event ) {\n-\t\t\treturn dataPriv.get( event.target, type );\n-\t\t},\n-\n-\t\tdelegateType: delegateType\n-\t};\n-} );\n-\n-// Create mouseenter/leave events using mouseover/out and event-time checks\n-// so that event delegation works in jQuery.\n-// Do the same for pointerenter/pointerleave and pointerover/pointerout\n-//\n-// Support: Safari 7 only\n-// Safari sends mouseenter too often; see:\n-// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n-// for the description of the bug (it existed in older Chrome versions as well).\n-jQuery.each( {\n-\tmouseenter: \"mouseover\",\n-\tmouseleave: \"mouseout\",\n-\tpointerenter: \"pointerover\",\n-\tpointerleave: \"pointerout\"\n-}, function( orig, fix ) {\n-\tjQuery.event.special[ orig ] = {\n-\t\tdelegateType: fix,\n-\t\tbindType: fix,\n-\n-\t\thandle: function( event ) {\n-\t\t\tvar ret,\n-\t\t\t\ttarget = this,\n-\t\t\t\trelated = event.relatedTarget,\n-\t\t\t\thandleObj = event.handleObj;\n-\n-\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n-\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n-\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n-\t\t\t\tevent.type = handleObj.origType;\n-\t\t\t\tret = handleObj.handler.apply( this, arguments );\n-\t\t\t\tevent.type = fix;\n-\t\t\t}\n-\t\t\treturn ret;\n-\t\t}\n-\t};\n-} );\n-\n-jQuery.fn.extend( {\n-\n-\ton: function( types, selector, data, fn ) {\n-\t\treturn on( this, types, selector, data, fn );\n-\t},\n-\tone: function( types, selector, data, fn ) {\n-\t\treturn on( this, types, selector, data, fn, 1 );\n-\t},\n-\toff: function( types, selector, fn ) {\n-\t\tvar handleObj, type;\n-\t\tif ( types && types.preventDefault && types.handleObj ) {\n-\n-\t\t\t// ( event )  dispatched jQuery.Event\n-\t\t\thandleObj = types.handleObj;\n-\t\t\tjQuery( types.delegateTarget ).off(\n-\t\t\t\thandleObj.namespace ?\n-\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n-\t\t\t\t\thandleObj.origType,\n-\t\t\t\thandleObj.selector,\n-\t\t\t\thandleObj.handler\n-\t\t\t);\n-\t\t\treturn this;\n-\t\t}\n-\t\tif ( typeof types === \"object\" ) {\n-\n-\t\t\t// ( types-object [, selector] )\n-\t\t\tfor ( type in types ) {\n-\t\t\t\tthis.off( type, selector, types[ type ] );\n-\t\t\t}\n-\t\t\treturn this;\n-\t\t}\n-\t\tif ( selector === false || typeof selector === \"function\" ) {\n-\n-\t\t\t// ( types [, fn] )\n-\t\t\tfn = selector;\n-\t\t\tselector = undefined;\n-\t\t}\n-\t\tif ( fn === false ) {\n-\t\t\tfn = returnFalse;\n-\t\t}\n-\t\treturn this.each( function() {\n-\t\t\tjQuery.event.remove( this, types, fn, selector );\n-\t\t} );\n-\t}\n-} );\n-\n-\n-var\n-\n-\t// Support: IE <=10 - 11, Edge 12 - 13 only\n-\t// In IE/Edge using regex groups here causes severe slowdowns.\n-\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n-\trnoInnerhtml = /<script|<style|<link/i,\n-\n-\t// checked=\"checked\" or checked\n-\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n-\n-\trcleanScript = /^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$/g;\n-\n-// Prefer a tbody over its parent table for containing new rows\n-function manipulationTarget( elem, content ) {\n-\tif ( nodeName( elem, \"table\" ) &&\n-\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n-\n-\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n-\t}\n-\n-\treturn elem;\n-}\n-\n-// Replace/restore the type attribute of script elements for safe DOM manipulation\n-function disableScript( elem ) {\n-\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n-\treturn elem;\n-}\n-function restoreScript( elem ) {\n-\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n-\t\telem.type = elem.type.slice( 5 );\n-\t} else {\n-\t\telem.removeAttribute( \"type\" );\n-\t}\n-\n-\treturn elem;\n-}\n-\n-function cloneCopyEvent( src, dest ) {\n-\tvar i, l, type, pdataOld, udataOld, udataCur, events;\n-\n-\tif ( dest.nodeType !== 1 ) {\n-\t\treturn;\n-\t}\n-\n-\t// 1. Copy private data: events, handlers, etc.\n-\tif ( dataPriv.hasData( src ) ) {\n-\t\tpdataOld = dataPriv.get( src );\n-\t\tevents = pdataOld.events;\n-\n-\t\tif ( events ) {\n-\t\t\tdataPriv.remove( dest, \"handle events\" );\n-\n-\t\t\tfor ( type in events ) {\n-\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n-\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// 2. Copy user data\n-\tif ( dataUser.hasData( src ) ) {\n-\t\tudataOld = dataUser.access( src );\n-\t\tudataCur = jQuery.extend( {}, udataOld );\n-\n-\t\tdataUser.set( dest, udataCur );\n-\t}\n-}\n-\n-// Fix IE bugs, see support tests\n-function fixInput( src, dest ) {\n-\tvar nodeName = dest.nodeName.toLowerCase();\n-\n-\t// Fails to persist the checked state of a cloned checkbox or radio button.\n-\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n-\t\tdest.checked = src.checked;\n-\n-\t// Fails to return the selected option to the default selected state when cloning options\n-\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n-\t\tdest.defaultValue = src.defaultValue;\n-\t}\n-}\n-\n-function domManip( collection, args, callback, ignored ) {\n-\n-\t// Flatten any nested arrays\n-\targs = flat( args );\n-\n-\tvar fragment, first, scripts, hasScripts, node, doc,\n-\t\ti = 0,\n-\t\tl = collection.length,\n-\t\tiNoClone = l - 1,\n-\t\tvalue = args[ 0 ],\n-\t\tvalueIsFunction = isFunction( value );\n-\n-\t// We can't cloneNode fragments that contain checked, in WebKit\n-\tif ( valueIsFunction ||\n-\t\t\t( l > 1 && typeof value === \"string\" &&\n-\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n-\t\treturn collection.each( function( index ) {\n-\t\t\tvar self = collection.eq( index );\n-\t\t\tif ( valueIsFunction ) {\n-\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n-\t\t\t}\n-\t\t\tdomManip( self, args, callback, ignored );\n-\t\t} );\n-\t}\n-\n-\tif ( l ) {\n-\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n-\t\tfirst = fragment.firstChild;\n-\n-\t\tif ( fragment.childNodes.length === 1 ) {\n-\t\t\tfragment = first;\n-\t\t}\n-\n-\t\t// Require either new content or an interest in ignored elements to invoke the callback\n-\t\tif ( first || ignored ) {\n-\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n-\t\t\thasScripts = scripts.length;\n-\n-\t\t\t// Use the original fragment for the last item\n-\t\t\t// instead of the first because it can end up\n-\t\t\t// being emptied incorrectly in certain situations (trac-8070).\n-\t\t\tfor ( ; i < l; i++ ) {\n-\t\t\t\tnode = fragment;\n-\n-\t\t\t\tif ( i !== iNoClone ) {\n-\t\t\t\t\tnode = jQuery.clone( node, true, true );\n-\n-\t\t\t\t\t// Keep references to cloned scripts for later restoration\n-\t\t\t\t\tif ( hasScripts ) {\n-\n-\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n-\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n-\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tcallback.call( collection[ i ], node, i );\n-\t\t\t}\n-\n-\t\t\tif ( hasScripts ) {\n-\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n-\n-\t\t\t\t// Reenable scripts\n-\t\t\t\tjQuery.map( scripts, restoreScript );\n-\n-\t\t\t\t// Evaluate executable scripts on first document insertion\n-\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n-\t\t\t\t\tnode = scripts[ i ];\n-\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n-\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n-\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n-\n-\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n-\n-\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n-\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n-\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n-\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( \"nonce\" )\n-\t\t\t\t\t\t\t\t}, doc );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t// Unwrap a CDATA section containing script contents. This shouldn't be\n-\t\t\t\t\t\t\t// needed as in XML documents they're already not visible when\n-\t\t\t\t\t\t\t// inspecting element contents and in HTML documents they have no\n-\t\t\t\t\t\t\t// meaning but we're preserving that logic for backwards compatibility.\n-\t\t\t\t\t\t\t// This will be removed completely in 4.0. See gh-4904.\n-\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), node, doc );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn collection;\n-}\n-\n-function remove( elem, selector, keepData ) {\n-\tvar node,\n-\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n-\t\ti = 0;\n-\n-\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n-\t\tif ( !keepData && node.nodeType === 1 ) {\n-\t\t\tjQuery.cleanData( getAll( node ) );\n-\t\t}\n-\n-\t\tif ( node.parentNode ) {\n-\t\t\tif ( keepData && isAttached( node ) ) {\n-\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n-\t\t\t}\n-\t\t\tnode.parentNode.removeChild( node );\n-\t\t}\n-\t}\n-\n-\treturn elem;\n-}\n-\n-jQuery.extend( {\n-\thtmlPrefilter: function( html ) {\n-\t\treturn html;\n-\t},\n-\n-\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n-\t\tvar i, l, srcElements, destElements,\n-\t\t\tclone = elem.cloneNode( true ),\n-\t\t\tinPage = isAttached( elem );\n-\n-\t\t// Fix IE cloning issues\n-\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n-\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n-\n-\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n-\t\t\tdestElements = getAll( clone );\n-\t\t\tsrcElements = getAll( elem );\n-\n-\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n-\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Copy the events from the original to the clone\n-\t\tif ( dataAndEvents ) {\n-\t\t\tif ( deepDataAndEvents ) {\n-\t\t\t\tsrcElements = srcElements || getAll( elem );\n-\t\t\t\tdestElements = destElements || getAll( clone );\n-\n-\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n-\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tcloneCopyEvent( elem, clone );\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Preserve script evaluation history\n-\t\tdestElements = getAll( clone, \"script\" );\n-\t\tif ( destElements.length > 0 ) {\n-\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n-\t\t}\n-\n-\t\t// Return the cloned set\n-\t\treturn clone;\n-\t},\n-\n-\tcleanData: function( elems ) {\n-\t\tvar data, elem, type,\n-\t\t\tspecial = jQuery.event.special,\n-\t\t\ti = 0;\n-\n-\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n-\t\t\tif ( acceptData( elem ) ) {\n-\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n-\t\t\t\t\tif ( data.events ) {\n-\t\t\t\t\t\tfor ( type in data.events ) {\n-\t\t\t\t\t\t\tif ( special[ type ] ) {\n-\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n-\n-\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Support: Chrome <=35 - 45+\n-\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n-\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n-\t\t\t\t}\n-\t\t\t\tif ( elem[ dataUser.expando ] ) {\n-\n-\t\t\t\t\t// Support: Chrome <=35 - 45+\n-\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n-\t\t\t\t\telem[ dataUser.expando ] = undefined;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-} );\n-\n-jQuery.fn.extend( {\n-\tdetach: function( selector ) {\n-\t\treturn remove( this, selector, true );\n-\t},\n-\n-\tremove: function( selector ) {\n-\t\treturn remove( this, selector );\n-\t},\n-\n-\ttext: function( value ) {\n-\t\treturn access( this, function( value ) {\n-\t\t\treturn value === undefined ?\n-\t\t\t\tjQuery.text( this ) :\n-\t\t\t\tthis.empty().each( function() {\n-\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n-\t\t\t\t\t\tthis.textContent = value;\n-\t\t\t\t\t}\n-\t\t\t\t} );\n-\t\t}, null, value, arguments.length );\n-\t},\n-\n-\tappend: function() {\n-\t\treturn domManip( this, arguments, function( elem ) {\n-\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n-\t\t\t\tvar target = manipulationTarget( this, elem );\n-\t\t\t\ttarget.appendChild( elem );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\tprepend: function() {\n-\t\treturn domManip( this, arguments, function( elem ) {\n-\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n-\t\t\t\tvar target = manipulationTarget( this, elem );\n-\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\tbefore: function() {\n-\t\treturn domManip( this, arguments, function( elem ) {\n-\t\t\tif ( this.parentNode ) {\n-\t\t\t\tthis.parentNode.insertBefore( elem, this );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\tafter: function() {\n-\t\treturn domManip( this, arguments, function( elem ) {\n-\t\t\tif ( this.parentNode ) {\n-\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\tempty: function() {\n-\t\tvar elem,\n-\t\t\ti = 0;\n-\n-\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n-\t\t\tif ( elem.nodeType === 1 ) {\n-\n-\t\t\t\t// Prevent memory leaks\n-\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n-\n-\t\t\t\t// Remove any remaining nodes\n-\t\t\t\telem.textContent = \"\";\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn this;\n-\t},\n-\n-\tclone: function( dataAndEvents, deepDataAndEvents ) {\n-\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n-\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n-\n-\t\treturn this.map( function() {\n-\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n-\t\t} );\n-\t},\n-\n-\thtml: function( value ) {\n-\t\treturn access( this, function( value ) {\n-\t\t\tvar elem = this[ 0 ] || {},\n-\t\t\t\ti = 0,\n-\t\t\t\tl = this.length;\n-\n-\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n-\t\t\t\treturn elem.innerHTML;\n-\t\t\t}\n-\n-\t\t\t// See if we can take a shortcut and just use innerHTML\n-\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n-\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n-\n-\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n-\n-\t\t\t\ttry {\n-\t\t\t\t\tfor ( ; i < l; i++ ) {\n-\t\t\t\t\t\telem = this[ i ] || {};\n-\n-\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n-\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n-\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n-\t\t\t\t\t\t\telem.innerHTML = value;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\telem = 0;\n-\n-\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n-\t\t\t\t} catch ( e ) {}\n-\t\t\t}\n-\n-\t\t\tif ( elem ) {\n-\t\t\t\tthis.empty().append( value );\n-\t\t\t}\n-\t\t}, null, value, arguments.length );\n-\t},\n-\n-\treplaceWith: function() {\n-\t\tvar ignored = [];\n-\n-\t\t// Make the changes, replacing each non-ignored context element with the new content\n-\t\treturn domManip( this, arguments, function( elem ) {\n-\t\t\tvar parent = this.parentNode;\n-\n-\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n-\t\t\t\tjQuery.cleanData( getAll( this ) );\n-\t\t\t\tif ( parent ) {\n-\t\t\t\t\tparent.replaceChild( elem, this );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t// Force callback invocation\n-\t\t}, ignored );\n-\t}\n-} );\n-\n-jQuery.each( {\n-\tappendTo: \"append\",\n-\tprependTo: \"prepend\",\n-\tinsertBefore: \"before\",\n-\tinsertAfter: \"after\",\n-\treplaceAll: \"replaceWith\"\n-}, function( name, original ) {\n-\tjQuery.fn[ name ] = function( selector ) {\n-\t\tvar elems,\n-\t\t\tret = [],\n-\t\t\tinsert = jQuery( selector ),\n-\t\t\tlast = insert.length - 1,\n-\t\t\ti = 0;\n-\n-\t\tfor ( ; i <= last; i++ ) {\n-\t\t\telems = i === last ? this : this.clone( true );\n-\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n-\n-\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n-\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n-\t\t\tpush.apply( ret, elems.get() );\n-\t\t}\n-\n-\t\treturn this.pushStack( ret );\n-\t};\n-} );\n-var rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n-\n-var rcustomProp = /^--/;\n-\n-\n-var getStyles = function( elem ) {\n-\n-\t\t// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)\n-\t\t// IE throws on elements created in popups\n-\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n-\t\tvar view = elem.ownerDocument.defaultView;\n-\n-\t\tif ( !view || !view.opener ) {\n-\t\t\tview = window;\n-\t\t}\n-\n-\t\treturn view.getComputedStyle( elem );\n-\t};\n-\n-var swap = function( elem, options, callback ) {\n-\tvar ret, name,\n-\t\told = {};\n-\n-\t// Remember the old values, and insert the new ones\n-\tfor ( name in options ) {\n-\t\told[ name ] = elem.style[ name ];\n-\t\telem.style[ name ] = options[ name ];\n-\t}\n-\n-\tret = callback.call( elem );\n-\n-\t// Revert the old values\n-\tfor ( name in options ) {\n-\t\telem.style[ name ] = old[ name ];\n-\t}\n-\n-\treturn ret;\n-};\n-\n-\n-var rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n-\n-var whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\n-\n-\n-var rtrimCSS = new RegExp(\n-\t\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\",\n-\t\"g\"\n-);\n-\n-\n-\n-\n-( function() {\n-\n-\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n-\t// so they're executed at the same time to save the second computation.\n-\tfunction computeStyleTests() {\n-\n-\t\t// This is a singleton, we need to execute it only once\n-\t\tif ( !div ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n-\t\t\t\"margin-top:1px;padding:0;border:0\";\n-\t\tdiv.style.cssText =\n-\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n-\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n-\t\t\t\"width:60%;top:1%\";\n-\t\tdocumentElement.appendChild( container ).appendChild( div );\n-\n-\t\tvar divStyle = window.getComputedStyle( div );\n-\t\tpixelPositionVal = divStyle.top !== \"1%\";\n-\n-\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n-\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n-\n-\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n-\t\t// Some styles come back with percentage values, even though they shouldn't\n-\t\tdiv.style.right = \"60%\";\n-\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n-\n-\t\t// Support: IE 9 - 11 only\n-\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n-\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n-\n-\t\t// Support: IE 9 only\n-\t\t// Detect overflow:scroll screwiness (gh-3699)\n-\t\t// Support: Chrome <=64\n-\t\t// Don't get tricked when zoom affects offsetWidth (gh-4029)\n-\t\tdiv.style.position = \"absolute\";\n-\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;\n-\n-\t\tdocumentElement.removeChild( container );\n-\n-\t\t// Nullify the div so it wouldn't be stored in the memory and\n-\t\t// it will also be a sign that checks already performed\n-\t\tdiv = null;\n-\t}\n-\n-\tfunction roundPixelMeasures( measure ) {\n-\t\treturn Math.round( parseFloat( measure ) );\n-\t}\n-\n-\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n-\t\treliableTrDimensionsVal, reliableMarginLeftVal,\n-\t\tcontainer = document.createElement( \"div\" ),\n-\t\tdiv = document.createElement( \"div\" );\n-\n-\t// Finish early in limited (non-browser) environments\n-\tif ( !div.style ) {\n-\t\treturn;\n-\t}\n-\n-\t// Support: IE <=9 - 11 only\n-\t// Style of cloned element affects source element cloned (trac-8908)\n-\tdiv.style.backgroundClip = \"content-box\";\n-\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n-\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n-\n-\tjQuery.extend( support, {\n-\t\tboxSizingReliable: function() {\n-\t\t\tcomputeStyleTests();\n-\t\t\treturn boxSizingReliableVal;\n-\t\t},\n-\t\tpixelBoxStyles: function() {\n-\t\t\tcomputeStyleTests();\n-\t\t\treturn pixelBoxStylesVal;\n-\t\t},\n-\t\tpixelPosition: function() {\n-\t\t\tcomputeStyleTests();\n-\t\t\treturn pixelPositionVal;\n-\t\t},\n-\t\treliableMarginLeft: function() {\n-\t\t\tcomputeStyleTests();\n-\t\t\treturn reliableMarginLeftVal;\n-\t\t},\n-\t\tscrollboxSize: function() {\n-\t\t\tcomputeStyleTests();\n-\t\t\treturn scrollboxSizeVal;\n-\t\t},\n-\n-\t\t// Support: IE 9 - 11+, Edge 15 - 18+\n-\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n-\t\t// set in CSS while `offset*` properties report correct values.\n-\t\t// Behavior in IE 9 is more subtle than in newer versions & it passes\n-\t\t// some versions of this test; make sure not to make it pass there!\n-\t\t//\n-\t\t// Support: Firefox 70+\n-\t\t// Only Firefox includes border widths\n-\t\t// in computed dimensions. (gh-4529)\n-\t\treliableTrDimensions: function() {\n-\t\t\tvar table, tr, trChild, trStyle;\n-\t\t\tif ( reliableTrDimensionsVal == null ) {\n-\t\t\t\ttable = document.createElement( \"table\" );\n-\t\t\t\ttr = document.createElement( \"tr\" );\n-\t\t\t\ttrChild = document.createElement( \"div\" );\n-\n-\t\t\t\ttable.style.cssText = \"position:absolute;left:-11111px;border-collapse:separate\";\n-\t\t\t\ttr.style.cssText = \"border:1px solid\";\n-\n-\t\t\t\t// Support: Chrome 86+\n-\t\t\t\t// Height set through cssText does not get applied.\n-\t\t\t\t// Computed height then comes back as 0.\n-\t\t\t\ttr.style.height = \"1px\";\n-\t\t\t\ttrChild.style.height = \"9px\";\n-\n-\t\t\t\t// Support: Android 8 Chrome 86+\n-\t\t\t\t// In our bodyBackground.html iframe,\n-\t\t\t\t// display for all div elements is set to \"inline\",\n-\t\t\t\t// which causes a problem only in Android 8 Chrome 86.\n-\t\t\t\t// Ensuring the div is display: block\n-\t\t\t\t// gets around this issue.\n-\t\t\t\ttrChild.style.display = \"block\";\n-\n-\t\t\t\tdocumentElement\n-\t\t\t\t\t.appendChild( table )\n-\t\t\t\t\t.appendChild( tr )\n-\t\t\t\t\t.appendChild( trChild );\n-\n-\t\t\t\ttrStyle = window.getComputedStyle( tr );\n-\t\t\t\treliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +\n-\t\t\t\t\tparseInt( trStyle.borderTopWidth, 10 ) +\n-\t\t\t\t\tparseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;\n-\n-\t\t\t\tdocumentElement.removeChild( table );\n-\t\t\t}\n-\t\t\treturn reliableTrDimensionsVal;\n-\t\t}\n-\t} );\n-} )();\n-\n-\n-function curCSS( elem, name, computed ) {\n-\tvar width, minWidth, maxWidth, ret,\n-\t\tisCustomProp = rcustomProp.test( name ),\n-\n-\t\t// Support: Firefox 51+\n-\t\t// Retrieving style before computed somehow\n-\t\t// fixes an issue with getting wrong values\n-\t\t// on detached elements\n-\t\tstyle = elem.style;\n-\n-\tcomputed = computed || getStyles( elem );\n-\n-\t// getPropertyValue is needed for:\n-\t//   .css('filter') (IE 9 only, trac-12537)\n-\t//   .css('--customProperty) (gh-3144)\n-\tif ( computed ) {\n-\n-\t\t// Support: IE <=9 - 11+\n-\t\t// IE only supports `\"float\"` in `getPropertyValue`; in computed styles\n-\t\t// it's only available as `\"cssFloat\"`. We no longer modify properties\n-\t\t// sent to `.css()` apart from camelCasing, so we need to check both.\n-\t\t// Normally, this would create difference in behavior: if\n-\t\t// `getPropertyValue` returns an empty string, the value returned\n-\t\t// by `.css()` would be `undefined`. This is usually the case for\n-\t\t// disconnected elements. However, in IE even disconnected elements\n-\t\t// with no styles return `\"none\"` for `getPropertyValue( \"float\" )`\n-\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n-\n-\t\tif ( isCustomProp && ret ) {\n-\n-\t\t\t// Support: Firefox 105+, Chrome <=105+\n-\t\t\t// Spec requires trimming whitespace for custom properties (gh-4926).\n-\t\t\t// Firefox only trims leading whitespace. Chrome just collapses\n-\t\t\t// both leading & trailing whitespace to a single space.\n-\t\t\t//\n-\t\t\t// Fall back to `undefined` if empty string returned.\n-\t\t\t// This collapses a missing definition with property defined\n-\t\t\t// and set to an empty string but there's no standard API\n-\t\t\t// allowing us to differentiate them without a performance penalty\n-\t\t\t// and returning `undefined` aligns with older jQuery.\n-\t\t\t//\n-\t\t\t// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED\n-\t\t\t// as whitespace while CSS does not, but this is not a problem\n-\t\t\t// because CSS preprocessing replaces them with U+000A LINE FEED\n-\t\t\t// (which *is* CSS whitespace)\n-\t\t\t// https://www.w3.org/TR/css-syntax-3/#input-preprocessing\n-\t\t\tret = ret.replace( rtrimCSS, \"$1\" ) || undefined;\n-\t\t}\n-\n-\t\tif ( ret === \"\" && !isAttached( elem ) ) {\n-\t\t\tret = jQuery.style( elem, name );\n-\t\t}\n-\n-\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n-\t\t// Android Browser returns percentage for some values,\n-\t\t// but width seems to be reliably pixels.\n-\t\t// This is against the CSSOM draft spec:\n-\t\t// https://drafts.csswg.org/cssom/#resolved-values\n-\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n-\n-\t\t\t// Remember the original values\n-\t\t\twidth = style.width;\n-\t\t\tminWidth = style.minWidth;\n-\t\t\tmaxWidth = style.maxWidth;\n-\n-\t\t\t// Put in the new values to get a computed value out\n-\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n-\t\t\tret = computed.width;\n-\n-\t\t\t// Revert the changed values\n-\t\t\tstyle.width = width;\n-\t\t\tstyle.minWidth = minWidth;\n-\t\t\tstyle.maxWidth = maxWidth;\n-\t\t}\n-\t}\n-\n-\treturn ret !== undefined ?\n-\n-\t\t// Support: IE <=9 - 11 only\n-\t\t// IE returns zIndex value as an integer.\n-\t\tret + \"\" :\n-\t\tret;\n-}\n-\n-\n-function addGetHookIf( conditionFn, hookFn ) {\n-\n-\t// Define the hook, we'll check on the first run if it's really needed.\n-\treturn {\n-\t\tget: function() {\n-\t\t\tif ( conditionFn() ) {\n-\n-\t\t\t\t// Hook not needed (or it's not possible to use it due\n-\t\t\t\t// to missing dependency), remove it.\n-\t\t\t\tdelete this.get;\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n-\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n-\t\t}\n-\t};\n-}\n-\n-\n-var cssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n-\temptyStyle = document.createElement( \"div\" ).style,\n-\tvendorProps = {};\n-\n-// Return a vendor-prefixed property or undefined\n-function vendorPropName( name ) {\n-\n-\t// Check for vendor prefixed names\n-\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n-\t\ti = cssPrefixes.length;\n-\n-\twhile ( i-- ) {\n-\t\tname = cssPrefixes[ i ] + capName;\n-\t\tif ( name in emptyStyle ) {\n-\t\t\treturn name;\n-\t\t}\n-\t}\n-}\n-\n-// Return a potentially-mapped jQuery.cssProps or vendor prefixed property\n-function finalPropName( name ) {\n-\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n-\n-\tif ( final ) {\n-\t\treturn final;\n-\t}\n-\tif ( name in emptyStyle ) {\n-\t\treturn name;\n-\t}\n-\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n-}\n-\n-\n-var\n-\n-\t// Swappable if display is none or starts with table\n-\t// except \"table\", \"table-cell\", or \"table-caption\"\n-\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n-\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n-\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n-\tcssNormalTransform = {\n-\t\tletterSpacing: \"0\",\n-\t\tfontWeight: \"400\"\n-\t};\n-\n-function setPositiveNumber( _elem, value, subtract ) {\n-\n-\t// Any relative (+/-) values have already been\n-\t// normalized at this point\n-\tvar matches = rcssNum.exec( value );\n-\treturn matches ?\n-\n-\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n-\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n-\t\tvalue;\n-}\n-\n-function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n-\tvar i = dimension === \"width\" ? 1 : 0,\n-\t\textra = 0,\n-\t\tdelta = 0;\n-\n-\t// Adjustment may not be necessary\n-\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n-\t\treturn 0;\n-\t}\n-\n-\tfor ( ; i < 4; i += 2 ) {\n-\n-\t\t// Both box models exclude margin\n-\t\tif ( box === \"margin\" ) {\n-\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n-\t\t}\n-\n-\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n-\t\tif ( !isBorderBox ) {\n-\n-\t\t\t// Add padding\n-\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n-\n-\t\t\t// For \"border\" or \"margin\", add border\n-\t\t\tif ( box !== \"padding\" ) {\n-\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n-\n-\t\t\t// But still keep track of it otherwise\n-\t\t\t} else {\n-\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n-\t\t\t}\n-\n-\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n-\t\t// \"padding\" or \"margin\"\n-\t\t} else {\n-\n-\t\t\t// For \"content\", subtract padding\n-\t\t\tif ( box === \"content\" ) {\n-\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n-\t\t\t}\n-\n-\t\t\t// For \"content\" or \"padding\", subtract border\n-\t\t\tif ( box !== \"margin\" ) {\n-\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Account for positive content-box scroll gutter when requested by providing computedVal\n-\tif ( !isBorderBox && computedVal >= 0 ) {\n-\n-\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n-\t\t// Assuming integer scroll gutter, subtract the rest and round down\n-\t\tdelta += Math.max( 0, Math.ceil(\n-\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n-\t\t\tcomputedVal -\n-\t\t\tdelta -\n-\t\t\textra -\n-\t\t\t0.5\n-\n-\t\t// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n-\t\t// Use an explicit zero to avoid NaN (gh-3964)\n-\t\t) ) || 0;\n-\t}\n-\n-\treturn delta;\n-}\n-\n-function getWidthOrHeight( elem, dimension, extra ) {\n-\n-\t// Start with computed style\n-\tvar styles = getStyles( elem ),\n-\n-\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n-\t\t// Fake content-box until we know it's needed to know the true value.\n-\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n-\t\tisBorderBox = boxSizingNeeded &&\n-\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n-\t\tvalueIsBorderBox = isBorderBox,\n-\n-\t\tval = curCSS( elem, dimension, styles ),\n-\t\toffsetProp = \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n-\n-\t// Support: Firefox <=54\n-\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n-\tif ( rnumnonpx.test( val ) ) {\n-\t\tif ( !extra ) {\n-\t\t\treturn val;\n-\t\t}\n-\t\tval = \"auto\";\n-\t}\n-\n-\n-\t// Support: IE 9 - 11 only\n-\t// Use offsetWidth/offsetHeight for when box sizing is unreliable.\n-\t// In those cases, the computed value can be trusted to be border-box.\n-\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n-\n-\t\t// Support: IE 10 - 11+, Edge 15 - 18+\n-\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n-\t\t// set in CSS while `offset*` properties report correct values.\n-\t\t// Interestingly, in some cases IE 9 doesn't suffer from this issue.\n-\t\t!support.reliableTrDimensions() && nodeName( elem, \"tr\" ) ||\n-\n-\t\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n-\t\t// This happens for inline elements with no explicit setting (gh-3571)\n-\t\tval === \"auto\" ||\n-\n-\t\t// Support: Android <=4.1 - 4.3 only\n-\t\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n-\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) &&\n-\n-\t\t// Make sure the element is visible & connected\n-\t\telem.getClientRects().length ) {\n-\n-\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n-\n-\t\t// Where available, offsetWidth/offsetHeight approximate border box dimensions.\n-\t\t// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n-\t\t// retrieved value as a content box dimension.\n-\t\tvalueIsBorderBox = offsetProp in elem;\n-\t\tif ( valueIsBorderBox ) {\n-\t\t\tval = elem[ offsetProp ];\n-\t\t}\n-\t}\n-\n-\t// Normalize \"\" and auto\n-\tval = parseFloat( val ) || 0;\n-\n-\t// Adjust for the element's box model\n-\treturn ( val +\n-\t\tboxModelAdjustment(\n-\t\t\telem,\n-\t\t\tdimension,\n-\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n-\t\t\tvalueIsBorderBox,\n-\t\t\tstyles,\n-\n-\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n-\t\t\tval\n-\t\t)\n-\t) + \"px\";\n-}\n-\n-jQuery.extend( {\n-\n-\t// Add in style property hooks for overriding the default\n-\t// behavior of getting and setting a style property\n-\tcssHooks: {\n-\t\topacity: {\n-\t\t\tget: function( elem, computed ) {\n-\t\t\t\tif ( computed ) {\n-\n-\t\t\t\t\t// We should always get a number back from opacity\n-\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n-\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t},\n-\n-\t// Don't automatically add \"px\" to these possibly-unitless properties\n-\tcssNumber: {\n-\t\t\"animationIterationCount\": true,\n-\t\t\"columnCount\": true,\n-\t\t\"fillOpacity\": true,\n-\t\t\"flexGrow\": true,\n-\t\t\"flexShrink\": true,\n-\t\t\"fontWeight\": true,\n-\t\t\"gridArea\": true,\n-\t\t\"gridColumn\": true,\n-\t\t\"gridColumnEnd\": true,\n-\t\t\"gridColumnStart\": true,\n-\t\t\"gridRow\": true,\n-\t\t\"gridRowEnd\": true,\n-\t\t\"gridRowStart\": true,\n-\t\t\"lineHeight\": true,\n-\t\t\"opacity\": true,\n-\t\t\"order\": true,\n-\t\t\"orphans\": true,\n-\t\t\"widows\": true,\n-\t\t\"zIndex\": true,\n-\t\t\"zoom\": true\n-\t},\n-\n-\t// Add in properties whose names you wish to fix before\n-\t// setting or getting the value\n-\tcssProps: {},\n-\n-\t// Get and set the style property on a DOM Node\n-\tstyle: function( elem, name, value, extra ) {\n-\n-\t\t// Don't set styles on text and comment nodes\n-\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Make sure that we're working with the right name\n-\t\tvar ret, type, hooks,\n-\t\t\torigName = camelCase( name ),\n-\t\t\tisCustomProp = rcustomProp.test( name ),\n-\t\t\tstyle = elem.style;\n-\n-\t\t// Make sure that we're working with the right name. We don't\n-\t\t// want to query the value if it is a CSS custom property\n-\t\t// since they are user-defined.\n-\t\tif ( !isCustomProp ) {\n-\t\t\tname = finalPropName( origName );\n-\t\t}\n-\n-\t\t// Gets hook for the prefixed version, then unprefixed version\n-\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n-\n-\t\t// Check if we're setting a value\n-\t\tif ( value !== undefined ) {\n-\t\t\ttype = typeof value;\n-\n-\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (trac-7345)\n-\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n-\t\t\t\tvalue = adjustCSS( elem, name, ret );\n-\n-\t\t\t\t// Fixes bug trac-9237\n-\t\t\t\ttype = \"number\";\n-\t\t\t}\n-\n-\t\t\t// Make sure that null and NaN values aren't set (trac-7116)\n-\t\t\tif ( value == null || value !== value ) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n-\t\t\t// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n-\t\t\t// \"px\" to a few hardcoded values.\n-\t\t\tif ( type === \"number\" && !isCustomProp ) {\n-\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n-\t\t\t}\n-\n-\t\t\t// background-* props affect original clone's values\n-\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n-\t\t\t\tstyle[ name ] = \"inherit\";\n-\t\t\t}\n-\n-\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n-\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n-\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n-\n-\t\t\t\tif ( isCustomProp ) {\n-\t\t\t\t\tstyle.setProperty( name, value );\n-\t\t\t\t} else {\n-\t\t\t\t\tstyle[ name ] = value;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t} else {\n-\n-\t\t\t// If a hook was provided get the non-computed value from there\n-\t\t\tif ( hooks && \"get\" in hooks &&\n-\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n-\n-\t\t\t\treturn ret;\n-\t\t\t}\n-\n-\t\t\t// Otherwise just get the value from the style object\n-\t\t\treturn style[ name ];\n-\t\t}\n-\t},\n-\n-\tcss: function( elem, name, extra, styles ) {\n-\t\tvar val, num, hooks,\n-\t\t\torigName = camelCase( name ),\n-\t\t\tisCustomProp = rcustomProp.test( name );\n-\n-\t\t// Make sure that we're working with the right name. We don't\n-\t\t// want to modify the value if it is a CSS custom property\n-\t\t// since they are user-defined.\n-\t\tif ( !isCustomProp ) {\n-\t\t\tname = finalPropName( origName );\n-\t\t}\n-\n-\t\t// Try prefixed name followed by the unprefixed name\n-\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n-\n-\t\t// If a hook was provided get the computed value from there\n-\t\tif ( hooks && \"get\" in hooks ) {\n-\t\t\tval = hooks.get( elem, true, extra );\n-\t\t}\n-\n-\t\t// Otherwise, if a way to get the computed value exists, use that\n-\t\tif ( val === undefined ) {\n-\t\t\tval = curCSS( elem, name, styles );\n-\t\t}\n-\n-\t\t// Convert \"normal\" to computed value\n-\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n-\t\t\tval = cssNormalTransform[ name ];\n-\t\t}\n-\n-\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n-\t\tif ( extra === \"\" || extra ) {\n-\t\t\tnum = parseFloat( val );\n-\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n-\t\t}\n-\n-\t\treturn val;\n-\t}\n-} );\n-\n-jQuery.each( [ \"height\", \"width\" ], function( _i, dimension ) {\n-\tjQuery.cssHooks[ dimension ] = {\n-\t\tget: function( elem, computed, extra ) {\n-\t\t\tif ( computed ) {\n-\n-\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n-\t\t\t\t// but it must have a current display style that would benefit\n-\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n-\n-\t\t\t\t\t// Support: Safari 8+\n-\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n-\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n-\t\t\t\t\t// Support: IE <=11 only\n-\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n-\t\t\t\t\t// in IE throws an error.\n-\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n-\t\t\t\t\tswap( elem, cssShow, function() {\n-\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n-\t\t\t\t\t} ) :\n-\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n-\t\t\t}\n-\t\t},\n-\n-\t\tset: function( elem, value, extra ) {\n-\t\t\tvar matches,\n-\t\t\t\tstyles = getStyles( elem ),\n-\n-\t\t\t\t// Only read styles.position if the test has a chance to fail\n-\t\t\t\t// to avoid forcing a reflow.\n-\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n-\t\t\t\t\tstyles.position === \"absolute\",\n-\n-\t\t\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n-\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n-\t\t\t\tisBorderBox = boxSizingNeeded &&\n-\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n-\t\t\t\tsubtract = extra ?\n-\t\t\t\t\tboxModelAdjustment(\n-\t\t\t\t\t\telem,\n-\t\t\t\t\t\tdimension,\n-\t\t\t\t\t\textra,\n-\t\t\t\t\t\tisBorderBox,\n-\t\t\t\t\t\tstyles\n-\t\t\t\t\t) :\n-\t\t\t\t\t0;\n-\n-\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n-\t\t\t// faking a content-box to get border and padding (gh-3699)\n-\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n-\t\t\t\tsubtract -= Math.ceil(\n-\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n-\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n-\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n-\t\t\t\t\t0.5\n-\t\t\t\t);\n-\t\t\t}\n-\n-\t\t\t// Convert to pixels if value adjustment is needed\n-\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n-\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n-\n-\t\t\t\telem.style[ dimension ] = value;\n-\t\t\t\tvalue = jQuery.css( elem, dimension );\n-\t\t\t}\n-\n-\t\t\treturn setPositiveNumber( elem, value, subtract );\n-\t\t}\n-\t};\n-} );\n-\n-jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n-\tfunction( elem, computed ) {\n-\t\tif ( computed ) {\n-\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n-\t\t\t\telem.getBoundingClientRect().left -\n-\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n-\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n-\t\t\t\t\t} )\n-\t\t\t) + \"px\";\n-\t\t}\n-\t}\n-);\n-\n-// These hooks are used by animate to expand properties\n-jQuery.each( {\n-\tmargin: \"\",\n-\tpadding: \"\",\n-\tborder: \"Width\"\n-}, function( prefix, suffix ) {\n-\tjQuery.cssHooks[ prefix + suffix ] = {\n-\t\texpand: function( value ) {\n-\t\t\tvar i = 0,\n-\t\t\t\texpanded = {},\n-\n-\t\t\t\t// Assumes a single number if not a string\n-\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n-\n-\t\t\tfor ( ; i < 4; i++ ) {\n-\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n-\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n-\t\t\t}\n-\n-\t\t\treturn expanded;\n-\t\t}\n-\t};\n-\n-\tif ( prefix !== \"margin\" ) {\n-\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n-\t}\n-} );\n-\n-jQuery.fn.extend( {\n-\tcss: function( name, value ) {\n-\t\treturn access( this, function( elem, name, value ) {\n-\t\t\tvar styles, len,\n-\t\t\t\tmap = {},\n-\t\t\t\ti = 0;\n-\n-\t\t\tif ( Array.isArray( name ) ) {\n-\t\t\t\tstyles = getStyles( elem );\n-\t\t\t\tlen = name.length;\n-\n-\t\t\t\tfor ( ; i < len; i++ ) {\n-\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n-\t\t\t\t}\n-\n-\t\t\t\treturn map;\n-\t\t\t}\n-\n-\t\t\treturn value !== undefined ?\n-\t\t\t\tjQuery.style( elem, name, value ) :\n-\t\t\t\tjQuery.css( elem, name );\n-\t\t}, name, value, arguments.length > 1 );\n-\t}\n-} );\n-\n-\n-function Tween( elem, options, prop, end, easing ) {\n-\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n-}\n-jQuery.Tween = Tween;\n-\n-Tween.prototype = {\n-\tconstructor: Tween,\n-\tinit: function( elem, options, prop, end, easing, unit ) {\n-\t\tthis.elem = elem;\n-\t\tthis.prop = prop;\n-\t\tthis.easing = easing || jQuery.easing._default;\n-\t\tthis.options = options;\n-\t\tthis.start = this.now = this.cur();\n-\t\tthis.end = end;\n-\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n-\t},\n-\tcur: function() {\n-\t\tvar hooks = Tween.propHooks[ this.prop ];\n-\n-\t\treturn hooks && hooks.get ?\n-\t\t\thooks.get( this ) :\n-\t\t\tTween.propHooks._default.get( this );\n-\t},\n-\trun: function( percent ) {\n-\t\tvar eased,\n-\t\t\thooks = Tween.propHooks[ this.prop ];\n-\n-\t\tif ( this.options.duration ) {\n-\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n-\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n-\t\t\t);\n-\t\t} else {\n-\t\t\tthis.pos = eased = percent;\n-\t\t}\n-\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n-\n-\t\tif ( this.options.step ) {\n-\t\t\tthis.options.step.call( this.elem, this.now, this );\n-\t\t}\n-\n-\t\tif ( hooks && hooks.set ) {\n-\t\t\thooks.set( this );\n-\t\t} else {\n-\t\t\tTween.propHooks._default.set( this );\n-\t\t}\n-\t\treturn this;\n-\t}\n-};\n-\n-Tween.prototype.init.prototype = Tween.prototype;\n-\n-Tween.propHooks = {\n-\t_default: {\n-\t\tget: function( tween ) {\n-\t\t\tvar result;\n-\n-\t\t\t// Use a property on the element directly when it is not a DOM element,\n-\t\t\t// or when there is no matching style property that exists.\n-\t\t\tif ( tween.elem.nodeType !== 1 ||\n-\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n-\t\t\t\treturn tween.elem[ tween.prop ];\n-\t\t\t}\n-\n-\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n-\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n-\t\t\t// Simple values such as \"10px\" are parsed to Float;\n-\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n-\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n-\n-\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n-\t\t\treturn !result || result === \"auto\" ? 0 : result;\n-\t\t},\n-\t\tset: function( tween ) {\n-\n-\t\t\t// Use step hook for back compat.\n-\t\t\t// Use cssHook if its there.\n-\t\t\t// Use .style if available and use plain properties where available.\n-\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n-\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n-\t\t\t} else if ( tween.elem.nodeType === 1 && (\n-\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n-\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n-\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n-\t\t\t} else {\n-\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n-\t\t\t}\n-\t\t}\n-\t}\n-};\n-\n-// Support: IE <=9 only\n-// Panic based approach to setting things on disconnected nodes\n-Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n-\tset: function( tween ) {\n-\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n-\t\t\ttween.elem[ tween.prop ] = tween.now;\n-\t\t}\n-\t}\n-};\n-\n-jQuery.easing = {\n-\tlinear: function( p ) {\n-\t\treturn p;\n-\t},\n-\tswing: function( p ) {\n-\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n-\t},\n-\t_default: \"swing\"\n-};\n-\n-jQuery.fx = Tween.prototype.init;\n-\n-// Back compat <1.8 extension point\n-jQuery.fx.step = {};\n-\n-\n-\n-\n-var\n-\tfxNow, inProgress,\n-\trfxtypes = /^(?:toggle|show|hide)$/,\n-\trrun = /queueHooks$/;\n-\n-function schedule() {\n-\tif ( inProgress ) {\n-\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n-\t\t\twindow.requestAnimationFrame( schedule );\n-\t\t} else {\n-\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n-\t\t}\n-\n-\t\tjQuery.fx.tick();\n-\t}\n-}\n-\n-// Animations created synchronously will run synchronously\n-function createFxNow() {\n-\twindow.setTimeout( function() {\n-\t\tfxNow = undefined;\n-\t} );\n-\treturn ( fxNow = Date.now() );\n-}\n-\n-// Generate parameters to create a standard animation\n-function genFx( type, includeWidth ) {\n-\tvar which,\n-\t\ti = 0,\n-\t\tattrs = { height: type };\n-\n-\t// If we include width, step value is 1 to do all cssExpand values,\n-\t// otherwise step value is 2 to skip over Left and Right\n-\tincludeWidth = includeWidth ? 1 : 0;\n-\tfor ( ; i < 4; i += 2 - includeWidth ) {\n-\t\twhich = cssExpand[ i ];\n-\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n-\t}\n-\n-\tif ( includeWidth ) {\n-\t\tattrs.opacity = attrs.width = type;\n-\t}\n-\n-\treturn attrs;\n-}\n-\n-function createTween( value, prop, animation ) {\n-\tvar tween,\n-\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n-\t\tindex = 0,\n-\t\tlength = collection.length;\n-\tfor ( ; index < length; index++ ) {\n-\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n-\n-\t\t\t// We're done with this property\n-\t\t\treturn tween;\n-\t\t}\n-\t}\n-}\n-\n-function defaultPrefilter( elem, props, opts ) {\n-\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n-\t\tisBox = \"width\" in props || \"height\" in props,\n-\t\tanim = this,\n-\t\torig = {},\n-\t\tstyle = elem.style,\n-\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n-\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n-\n-\t// Queue-skipping animations hijack the fx hooks\n-\tif ( !opts.queue ) {\n-\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n-\t\tif ( hooks.unqueued == null ) {\n-\t\t\thooks.unqueued = 0;\n-\t\t\toldfire = hooks.empty.fire;\n-\t\t\thooks.empty.fire = function() {\n-\t\t\t\tif ( !hooks.unqueued ) {\n-\t\t\t\t\toldfire();\n-\t\t\t\t}\n-\t\t\t};\n-\t\t}\n-\t\thooks.unqueued++;\n-\n-\t\tanim.always( function() {\n-\n-\t\t\t// Ensure the complete handler is called before this completes\n-\t\t\tanim.always( function() {\n-\t\t\t\thooks.unqueued--;\n-\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n-\t\t\t\t\thooks.empty.fire();\n-\t\t\t\t}\n-\t\t\t} );\n-\t\t} );\n-\t}\n-\n-\t// Detect show/hide animations\n-\tfor ( prop in props ) {\n-\t\tvalue = props[ prop ];\n-\t\tif ( rfxtypes.test( value ) ) {\n-\t\t\tdelete props[ prop ];\n-\t\t\ttoggle = toggle || value === \"toggle\";\n-\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n-\n-\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n-\t\t\t\t// there is still data from a stopped show/hide\n-\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n-\t\t\t\t\thidden = true;\n-\n-\t\t\t\t// Ignore all other no-op show/hide data\n-\t\t\t\t} else {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n-\t\t}\n-\t}\n-\n-\t// Bail out if this is a no-op like .hide().hide()\n-\tpropTween = !jQuery.isEmptyObject( props );\n-\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n-\t\treturn;\n-\t}\n-\n-\t// Restrict \"overflow\" and \"display\" styles during box animations\n-\tif ( isBox && elem.nodeType === 1 ) {\n-\n-\t\t// Support: IE <=9 - 11, Edge 12 - 15\n-\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n-\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n-\t\t// the overflowX value there.\n-\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n-\n-\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n-\t\trestoreDisplay = dataShow && dataShow.display;\n-\t\tif ( restoreDisplay == null ) {\n-\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n-\t\t}\n-\t\tdisplay = jQuery.css( elem, \"display\" );\n-\t\tif ( display === \"none\" ) {\n-\t\t\tif ( restoreDisplay ) {\n-\t\t\t\tdisplay = restoreDisplay;\n-\t\t\t} else {\n-\n-\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n-\t\t\t\tshowHide( [ elem ], true );\n-\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n-\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n-\t\t\t\tshowHide( [ elem ] );\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Animate inline elements as inline-block\n-\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n-\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n-\n-\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n-\t\t\t\tif ( !propTween ) {\n-\t\t\t\t\tanim.done( function() {\n-\t\t\t\t\t\tstyle.display = restoreDisplay;\n-\t\t\t\t\t} );\n-\t\t\t\t\tif ( restoreDisplay == null ) {\n-\t\t\t\t\t\tdisplay = style.display;\n-\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tstyle.display = \"inline-block\";\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif ( opts.overflow ) {\n-\t\tstyle.overflow = \"hidden\";\n-\t\tanim.always( function() {\n-\t\t\tstyle.overflow = opts.overflow[ 0 ];\n-\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n-\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n-\t\t} );\n-\t}\n-\n-\t// Implement show/hide animations\n-\tpropTween = false;\n-\tfor ( prop in orig ) {\n-\n-\t\t// General show/hide setup for this element animation\n-\t\tif ( !propTween ) {\n-\t\t\tif ( dataShow ) {\n-\t\t\t\tif ( \"hidden\" in dataShow ) {\n-\t\t\t\t\thidden = dataShow.hidden;\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n-\t\t\t}\n-\n-\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n-\t\t\tif ( toggle ) {\n-\t\t\t\tdataShow.hidden = !hidden;\n-\t\t\t}\n-\n-\t\t\t// Show elements before animating them\n-\t\t\tif ( hidden ) {\n-\t\t\t\tshowHide( [ elem ], true );\n-\t\t\t}\n-\n-\t\t\t/* eslint-disable no-loop-func */\n-\n-\t\t\tanim.done( function() {\n-\n-\t\t\t\t/* eslint-enable no-loop-func */\n-\n-\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n-\t\t\t\tif ( !hidden ) {\n-\t\t\t\t\tshowHide( [ elem ] );\n-\t\t\t\t}\n-\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n-\t\t\t\tfor ( prop in orig ) {\n-\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n-\t\t\t\t}\n-\t\t\t} );\n-\t\t}\n-\n-\t\t// Per-property setup\n-\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n-\t\tif ( !( prop in dataShow ) ) {\n-\t\t\tdataShow[ prop ] = propTween.start;\n-\t\t\tif ( hidden ) {\n-\t\t\t\tpropTween.end = propTween.start;\n-\t\t\t\tpropTween.start = 0;\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-function propFilter( props, specialEasing ) {\n-\tvar index, name, easing, value, hooks;\n-\n-\t// camelCase, specialEasing and expand cssHook pass\n-\tfor ( index in props ) {\n-\t\tname = camelCase( index );\n-\t\teasing = specialEasing[ name ];\n-\t\tvalue = props[ index ];\n-\t\tif ( Array.isArray( value ) ) {\n-\t\t\teasing = value[ 1 ];\n-\t\t\tvalue = props[ index ] = value[ 0 ];\n-\t\t}\n-\n-\t\tif ( index !== name ) {\n-\t\t\tprops[ name ] = value;\n-\t\t\tdelete props[ index ];\n-\t\t}\n-\n-\t\thooks = jQuery.cssHooks[ name ];\n-\t\tif ( hooks && \"expand\" in hooks ) {\n-\t\t\tvalue = hooks.expand( value );\n-\t\t\tdelete props[ name ];\n-\n-\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n-\t\t\t// Reusing 'index' because we have the correct \"name\"\n-\t\t\tfor ( index in value ) {\n-\t\t\t\tif ( !( index in props ) ) {\n-\t\t\t\t\tprops[ index ] = value[ index ];\n-\t\t\t\t\tspecialEasing[ index ] = easing;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tspecialEasing[ name ] = easing;\n-\t\t}\n-\t}\n-}\n-\n-function Animation( elem, properties, options ) {\n-\tvar result,\n-\t\tstopped,\n-\t\tindex = 0,\n-\t\tlength = Animation.prefilters.length,\n-\t\tdeferred = jQuery.Deferred().always( function() {\n-\n-\t\t\t// Don't match elem in the :animated selector\n-\t\t\tdelete tick.elem;\n-\t\t} ),\n-\t\ttick = function() {\n-\t\t\tif ( stopped ) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvar currentTime = fxNow || createFxNow(),\n-\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n-\n-\t\t\t\t// Support: Android 2.3 only\n-\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)\n-\t\t\t\ttemp = remaining / animation.duration || 0,\n-\t\t\t\tpercent = 1 - temp,\n-\t\t\t\tindex = 0,\n-\t\t\t\tlength = animation.tweens.length;\n-\n-\t\t\tfor ( ; index < length; index++ ) {\n-\t\t\t\tanimation.tweens[ index ].run( percent );\n-\t\t\t}\n-\n-\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n-\n-\t\t\t// If there's more to do, yield\n-\t\t\tif ( percent < 1 && length ) {\n-\t\t\t\treturn remaining;\n-\t\t\t}\n-\n-\t\t\t// If this was an empty animation, synthesize a final progress notification\n-\t\t\tif ( !length ) {\n-\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n-\t\t\t}\n-\n-\t\t\t// Resolve the animation and report its conclusion\n-\t\t\tdeferred.resolveWith( elem, [ animation ] );\n-\t\t\treturn false;\n-\t\t},\n-\t\tanimation = deferred.promise( {\n-\t\t\telem: elem,\n-\t\t\tprops: jQuery.extend( {}, properties ),\n-\t\t\topts: jQuery.extend( true, {\n-\t\t\t\tspecialEasing: {},\n-\t\t\t\teasing: jQuery.easing._default\n-\t\t\t}, options ),\n-\t\t\toriginalProperties: properties,\n-\t\t\toriginalOptions: options,\n-\t\t\tstartTime: fxNow || createFxNow(),\n-\t\t\tduration: options.duration,\n-\t\t\ttweens: [],\n-\t\t\tcreateTween: function( prop, end ) {\n-\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n-\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n-\t\t\t\tanimation.tweens.push( tween );\n-\t\t\t\treturn tween;\n-\t\t\t},\n-\t\t\tstop: function( gotoEnd ) {\n-\t\t\t\tvar index = 0,\n-\n-\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n-\t\t\t\t\t// otherwise we skip this part\n-\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n-\t\t\t\tif ( stopped ) {\n-\t\t\t\t\treturn this;\n-\t\t\t\t}\n-\t\t\t\tstopped = true;\n-\t\t\t\tfor ( ; index < length; index++ ) {\n-\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n-\t\t\t\t}\n-\n-\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n-\t\t\t\tif ( gotoEnd ) {\n-\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n-\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n-\t\t\t\t} else {\n-\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n-\t\t\t\t}\n-\t\t\t\treturn this;\n-\t\t\t}\n-\t\t} ),\n-\t\tprops = animation.props;\n-\n-\tpropFilter( props, animation.opts.specialEasing );\n-\n-\tfor ( ; index < length; index++ ) {\n-\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n-\t\tif ( result ) {\n-\t\t\tif ( isFunction( result.stop ) ) {\n-\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n-\t\t\t\t\tresult.stop.bind( result );\n-\t\t\t}\n-\t\t\treturn result;\n-\t\t}\n-\t}\n-\n-\tjQuery.map( props, createTween, animation );\n-\n-\tif ( isFunction( animation.opts.start ) ) {\n-\t\tanimation.opts.start.call( elem, animation );\n-\t}\n-\n-\t// Attach callbacks from options\n-\tanimation\n-\t\t.progress( animation.opts.progress )\n-\t\t.done( animation.opts.done, animation.opts.complete )\n-\t\t.fail( animation.opts.fail )\n-\t\t.always( animation.opts.always );\n-\n-\tjQuery.fx.timer(\n-\t\tjQuery.extend( tick, {\n-\t\t\telem: elem,\n-\t\t\tanim: animation,\n-\t\t\tqueue: animation.opts.queue\n-\t\t} )\n-\t);\n-\n-\treturn animation;\n-}\n-\n-jQuery.Animation = jQuery.extend( Animation, {\n-\n-\ttweeners: {\n-\t\t\"*\": [ function( prop, value ) {\n-\t\t\tvar tween = this.createTween( prop, value );\n-\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n-\t\t\treturn tween;\n-\t\t} ]\n-\t},\n-\n-\ttweener: function( props, callback ) {\n-\t\tif ( isFunction( props ) ) {\n-\t\t\tcallback = props;\n-\t\t\tprops = [ \"*\" ];\n-\t\t} else {\n-\t\t\tprops = props.match( rnothtmlwhite );\n-\t\t}\n-\n-\t\tvar prop,\n-\t\t\tindex = 0,\n-\t\t\tlength = props.length;\n-\n-\t\tfor ( ; index < length; index++ ) {\n-\t\t\tprop = props[ index ];\n-\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n-\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n-\t\t}\n-\t},\n-\n-\tprefilters: [ defaultPrefilter ],\n-\n-\tprefilter: function( callback, prepend ) {\n-\t\tif ( prepend ) {\n-\t\t\tAnimation.prefilters.unshift( callback );\n-\t\t} else {\n-\t\t\tAnimation.prefilters.push( callback );\n-\t\t}\n-\t}\n-} );\n-\n-jQuery.speed = function( speed, easing, fn ) {\n-\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n-\t\tcomplete: fn || !fn && easing ||\n-\t\t\tisFunction( speed ) && speed,\n-\t\tduration: speed,\n-\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n-\t};\n-\n-\t// Go to the end state if fx are off\n-\tif ( jQuery.fx.off ) {\n-\t\topt.duration = 0;\n-\n-\t} else {\n-\t\tif ( typeof opt.duration !== \"number\" ) {\n-\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n-\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n-\n-\t\t\t} else {\n-\t\t\t\topt.duration = jQuery.fx.speeds._default;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n-\tif ( opt.queue == null || opt.queue === true ) {\n-\t\topt.queue = \"fx\";\n-\t}\n-\n-\t// Queueing\n-\topt.old = opt.complete;\n-\n-\topt.complete = function() {\n-\t\tif ( isFunction( opt.old ) ) {\n-\t\t\topt.old.call( this );\n-\t\t}\n-\n-\t\tif ( opt.queue ) {\n-\t\t\tjQuery.dequeue( this, opt.queue );\n-\t\t}\n-\t};\n-\n-\treturn opt;\n-};\n-\n-jQuery.fn.extend( {\n-\tfadeTo: function( speed, to, easing, callback ) {\n-\n-\t\t// Show any hidden elements after setting opacity to 0\n-\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n-\n-\t\t\t// Animate to the value specified\n-\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n-\t},\n-\tanimate: function( prop, speed, easing, callback ) {\n-\t\tvar empty = jQuery.isEmptyObject( prop ),\n-\t\t\toptall = jQuery.speed( speed, easing, callback ),\n-\t\t\tdoAnimation = function() {\n-\n-\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n-\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n-\n-\t\t\t\t// Empty animations, or finishing resolves immediately\n-\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n-\t\t\t\t\tanim.stop( true );\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\tdoAnimation.finish = doAnimation;\n-\n-\t\treturn empty || optall.queue === false ?\n-\t\t\tthis.each( doAnimation ) :\n-\t\t\tthis.queue( optall.queue, doAnimation );\n-\t},\n-\tstop: function( type, clearQueue, gotoEnd ) {\n-\t\tvar stopQueue = function( hooks ) {\n-\t\t\tvar stop = hooks.stop;\n-\t\t\tdelete hooks.stop;\n-\t\t\tstop( gotoEnd );\n-\t\t};\n-\n-\t\tif ( typeof type !== \"string\" ) {\n-\t\t\tgotoEnd = clearQueue;\n-\t\t\tclearQueue = type;\n-\t\t\ttype = undefined;\n-\t\t}\n-\t\tif ( clearQueue ) {\n-\t\t\tthis.queue( type || \"fx\", [] );\n-\t\t}\n-\n-\t\treturn this.each( function() {\n-\t\t\tvar dequeue = true,\n-\t\t\t\tindex = type != null && type + \"queueHooks\",\n-\t\t\t\ttimers = jQuery.timers,\n-\t\t\t\tdata = dataPriv.get( this );\n-\n-\t\t\tif ( index ) {\n-\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n-\t\t\t\t\tstopQueue( data[ index ] );\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tfor ( index in data ) {\n-\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n-\t\t\t\t\t\tstopQueue( data[ index ] );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tfor ( index = timers.length; index--; ) {\n-\t\t\t\tif ( timers[ index ].elem === this &&\n-\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n-\n-\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n-\t\t\t\t\tdequeue = false;\n-\t\t\t\t\ttimers.splice( index, 1 );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Start the next in the queue if the last step wasn't forced.\n-\t\t\t// Timers currently will call their complete callbacks, which\n-\t\t\t// will dequeue but only if they were gotoEnd.\n-\t\t\tif ( dequeue || !gotoEnd ) {\n-\t\t\t\tjQuery.dequeue( this, type );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\tfinish: function( type ) {\n-\t\tif ( type !== false ) {\n-\t\t\ttype = type || \"fx\";\n-\t\t}\n-\t\treturn this.each( function() {\n-\t\t\tvar index,\n-\t\t\t\tdata = dataPriv.get( this ),\n-\t\t\t\tqueue = data[ type + \"queue\" ],\n-\t\t\t\thooks = data[ type + \"queueHooks\" ],\n-\t\t\t\ttimers = jQuery.timers,\n-\t\t\t\tlength = queue ? queue.length : 0;\n-\n-\t\t\t// Enable finishing flag on private data\n-\t\t\tdata.finish = true;\n-\n-\t\t\t// Empty the queue first\n-\t\t\tjQuery.queue( this, type, [] );\n-\n-\t\t\tif ( hooks && hooks.stop ) {\n-\t\t\t\thooks.stop.call( this, true );\n-\t\t\t}\n-\n-\t\t\t// Look for any active animations, and finish them\n-\t\t\tfor ( index = timers.length; index--; ) {\n-\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n-\t\t\t\t\ttimers[ index ].anim.stop( true );\n-\t\t\t\t\ttimers.splice( index, 1 );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Look for any animations in the old queue and finish them\n-\t\t\tfor ( index = 0; index < length; index++ ) {\n-\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n-\t\t\t\t\tqueue[ index ].finish.call( this );\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Turn off finishing flag\n-\t\t\tdelete data.finish;\n-\t\t} );\n-\t}\n-} );\n-\n-jQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( _i, name ) {\n-\tvar cssFn = jQuery.fn[ name ];\n-\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n-\t\treturn speed == null || typeof speed === \"boolean\" ?\n-\t\t\tcssFn.apply( this, arguments ) :\n-\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n-\t};\n-} );\n-\n-// Generate shortcuts for custom animations\n-jQuery.each( {\n-\tslideDown: genFx( \"show\" ),\n-\tslideUp: genFx( \"hide\" ),\n-\tslideToggle: genFx( \"toggle\" ),\n-\tfadeIn: { opacity: \"show\" },\n-\tfadeOut: { opacity: \"hide\" },\n-\tfadeToggle: { opacity: \"toggle\" }\n-}, function( name, props ) {\n-\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n-\t\treturn this.animate( props, speed, easing, callback );\n-\t};\n-} );\n-\n-jQuery.timers = [];\n-jQuery.fx.tick = function() {\n-\tvar timer,\n-\t\ti = 0,\n-\t\ttimers = jQuery.timers;\n-\n-\tfxNow = Date.now();\n-\n-\tfor ( ; i < timers.length; i++ ) {\n-\t\ttimer = timers[ i ];\n-\n-\t\t// Run the timer and safely remove it when done (allowing for external removal)\n-\t\tif ( !timer() && timers[ i ] === timer ) {\n-\t\t\ttimers.splice( i--, 1 );\n-\t\t}\n-\t}\n-\n-\tif ( !timers.length ) {\n-\t\tjQuery.fx.stop();\n-\t}\n-\tfxNow = undefined;\n-};\n-\n-jQuery.fx.timer = function( timer ) {\n-\tjQuery.timers.push( timer );\n-\tjQuery.fx.start();\n-};\n-\n-jQuery.fx.interval = 13;\n-jQuery.fx.start = function() {\n-\tif ( inProgress ) {\n-\t\treturn;\n-\t}\n-\n-\tinProgress = true;\n-\tschedule();\n-};\n-\n-jQuery.fx.stop = function() {\n-\tinProgress = null;\n-};\n-\n-jQuery.fx.speeds = {\n-\tslow: 600,\n-\tfast: 200,\n-\n-\t// Default speed\n-\t_default: 400\n-};\n-\n-\n-// Based off of the plugin by Clint Helfers, with permission.\n-jQuery.fn.delay = function( time, type ) {\n-\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n-\ttype = type || \"fx\";\n-\n-\treturn this.queue( type, function( next, hooks ) {\n-\t\tvar timeout = window.setTimeout( next, time );\n-\t\thooks.stop = function() {\n-\t\t\twindow.clearTimeout( timeout );\n-\t\t};\n-\t} );\n-};\n-\n-\n-( function() {\n-\tvar input = document.createElement( \"input\" ),\n-\t\tselect = document.createElement( \"select\" ),\n-\t\topt = select.appendChild( document.createElement( \"option\" ) );\n-\n-\tinput.type = \"checkbox\";\n-\n-\t// Support: Android <=4.3 only\n-\t// Default value for a checkbox should be \"on\"\n-\tsupport.checkOn = input.value !== \"\";\n-\n-\t// Support: IE <=11 only\n-\t// Must access selectedIndex to make default options select\n-\tsupport.optSelected = opt.selected;\n-\n-\t// Support: IE <=11 only\n-\t// An input loses its value after becoming a radio\n-\tinput = document.createElement( \"input\" );\n-\tinput.value = \"t\";\n-\tinput.type = \"radio\";\n-\tsupport.radioValue = input.value === \"t\";\n-} )();\n-\n-\n-var boolHook,\n-\tattrHandle = jQuery.expr.attrHandle;\n-\n-jQuery.fn.extend( {\n-\tattr: function( name, value ) {\n-\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n-\t},\n-\n-\tremoveAttr: function( name ) {\n-\t\treturn this.each( function() {\n-\t\t\tjQuery.removeAttr( this, name );\n-\t\t} );\n-\t}\n-} );\n-\n-jQuery.extend( {\n-\tattr: function( elem, name, value ) {\n-\t\tvar ret, hooks,\n-\t\t\tnType = elem.nodeType;\n-\n-\t\t// Don't get/set attributes on text, comment and attribute nodes\n-\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Fallback to prop when attributes are not supported\n-\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n-\t\t\treturn jQuery.prop( elem, name, value );\n-\t\t}\n-\n-\t\t// Attribute hooks are determined by the lowercase version\n-\t\t// Grab necessary hook if one is defined\n-\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n-\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n-\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n-\t\t}\n-\n-\t\tif ( value !== undefined ) {\n-\t\t\tif ( value === null ) {\n-\t\t\t\tjQuery.removeAttr( elem, name );\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tif ( hooks && \"set\" in hooks &&\n-\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n-\t\t\t\treturn ret;\n-\t\t\t}\n-\n-\t\t\telem.setAttribute( name, value + \"\" );\n-\t\t\treturn value;\n-\t\t}\n-\n-\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n-\t\t\treturn ret;\n-\t\t}\n-\n-\t\tret = jQuery.find.attr( elem, name );\n-\n-\t\t// Non-existent attributes return null, we normalize to undefined\n-\t\treturn ret == null ? undefined : ret;\n-\t},\n-\n-\tattrHooks: {\n-\t\ttype: {\n-\t\t\tset: function( elem, value ) {\n-\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n-\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n-\t\t\t\t\tvar val = elem.value;\n-\t\t\t\t\telem.setAttribute( \"type\", value );\n-\t\t\t\t\tif ( val ) {\n-\t\t\t\t\t\telem.value = val;\n-\t\t\t\t\t}\n-\t\t\t\t\treturn value;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t},\n-\n-\tremoveAttr: function( elem, value ) {\n-\t\tvar name,\n-\t\t\ti = 0,\n-\n-\t\t\t// Attribute names can contain non-HTML whitespace characters\n-\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n-\t\t\tattrNames = value && value.match( rnothtmlwhite );\n-\n-\t\tif ( attrNames && elem.nodeType === 1 ) {\n-\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n-\t\t\t\telem.removeAttribute( name );\n-\t\t\t}\n-\t\t}\n-\t}\n-} );\n-\n-// Hooks for boolean attributes\n-boolHook = {\n-\tset: function( elem, value, name ) {\n-\t\tif ( value === false ) {\n-\n-\t\t\t// Remove boolean attributes when set to false\n-\t\t\tjQuery.removeAttr( elem, name );\n-\t\t} else {\n-\t\t\telem.setAttribute( name, name );\n-\t\t}\n-\t\treturn name;\n-\t}\n-};\n-\n-jQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( _i, name ) {\n-\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n-\n-\tattrHandle[ name ] = function( elem, name, isXML ) {\n-\t\tvar ret, handle,\n-\t\t\tlowercaseName = name.toLowerCase();\n-\n-\t\tif ( !isXML ) {\n-\n-\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n-\t\t\thandle = attrHandle[ lowercaseName ];\n-\t\t\tattrHandle[ lowercaseName ] = ret;\n-\t\t\tret = getter( elem, name, isXML ) != null ?\n-\t\t\t\tlowercaseName :\n-\t\t\t\tnull;\n-\t\t\tattrHandle[ lowercaseName ] = handle;\n-\t\t}\n-\t\treturn ret;\n-\t};\n-} );\n-\n-\n-\n-\n-var rfocusable = /^(?:input|select|textarea|button)$/i,\n-\trclickable = /^(?:a|area)$/i;\n-\n-jQuery.fn.extend( {\n-\tprop: function( name, value ) {\n-\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n-\t},\n-\n-\tremoveProp: function( name ) {\n-\t\treturn this.each( function() {\n-\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n-\t\t} );\n-\t}\n-} );\n-\n-jQuery.extend( {\n-\tprop: function( elem, name, value ) {\n-\t\tvar ret, hooks,\n-\t\t\tnType = elem.nodeType;\n-\n-\t\t// Don't get/set properties on text, comment and attribute nodes\n-\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n-\n-\t\t\t// Fix name and attach hooks\n-\t\t\tname = jQuery.propFix[ name ] || name;\n-\t\t\thooks = jQuery.propHooks[ name ];\n-\t\t}\n-\n-\t\tif ( value !== undefined ) {\n-\t\t\tif ( hooks && \"set\" in hooks &&\n-\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n-\t\t\t\treturn ret;\n-\t\t\t}\n-\n-\t\t\treturn ( elem[ name ] = value );\n-\t\t}\n-\n-\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n-\t\t\treturn ret;\n-\t\t}\n-\n-\t\treturn elem[ name ];\n-\t},\n-\n-\tpropHooks: {\n-\t\ttabIndex: {\n-\t\t\tget: function( elem ) {\n-\n-\t\t\t\t// Support: IE <=9 - 11 only\n-\t\t\t\t// elem.tabIndex doesn't always return the\n-\t\t\t\t// correct value when it hasn't been explicitly set\n-\t\t\t\t// Use proper attribute retrieval (trac-12072)\n-\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n-\n-\t\t\t\tif ( tabindex ) {\n-\t\t\t\t\treturn parseInt( tabindex, 10 );\n-\t\t\t\t}\n-\n-\t\t\t\tif (\n-\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n-\t\t\t\t\trclickable.test( elem.nodeName ) &&\n-\t\t\t\t\telem.href\n-\t\t\t\t) {\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\n-\t\t\t\treturn -1;\n-\t\t\t}\n-\t\t}\n-\t},\n-\n-\tpropFix: {\n-\t\t\"for\": \"htmlFor\",\n-\t\t\"class\": \"className\"\n-\t}\n-} );\n-\n-// Support: IE <=11 only\n-// Accessing the selectedIndex property\n-// forces the browser to respect setting selected\n-// on the option\n-// The getter ensures a default option is selected\n-// when in an optgroup\n-// eslint rule \"no-unused-expressions\" is disabled for this code\n-// since it considers such accessions noop\n-if ( !support.optSelected ) {\n-\tjQuery.propHooks.selected = {\n-\t\tget: function( elem ) {\n-\n-\t\t\t/* eslint no-unused-expressions: \"off\" */\n-\n-\t\t\tvar parent = elem.parentNode;\n-\t\t\tif ( parent && parent.parentNode ) {\n-\t\t\t\tparent.parentNode.selectedIndex;\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t},\n-\t\tset: function( elem ) {\n-\n-\t\t\t/* eslint no-unused-expressions: \"off\" */\n-\n-\t\t\tvar parent = elem.parentNode;\n-\t\t\tif ( parent ) {\n-\t\t\t\tparent.selectedIndex;\n-\n-\t\t\t\tif ( parent.parentNode ) {\n-\t\t\t\t\tparent.parentNode.selectedIndex;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-}\n-\n-jQuery.each( [\n-\t\"tabIndex\",\n-\t\"readOnly\",\n-\t\"maxLength\",\n-\t\"cellSpacing\",\n-\t\"cellPadding\",\n-\t\"rowSpan\",\n-\t\"colSpan\",\n-\t\"useMap\",\n-\t\"frameBorder\",\n-\t\"contentEditable\"\n-], function() {\n-\tjQuery.propFix[ this.toLowerCase() ] = this;\n-} );\n-\n-\n-\n-\n-\t// Strip and collapse whitespace according to HTML spec\n-\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n-\tfunction stripAndCollapse( value ) {\n-\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n-\t\treturn tokens.join( \" \" );\n-\t}\n-\n-\n-function getClass( elem ) {\n-\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n-}\n-\n-function classesToArray( value ) {\n-\tif ( Array.isArray( value ) ) {\n-\t\treturn value;\n-\t}\n-\tif ( typeof value === \"string\" ) {\n-\t\treturn value.match( rnothtmlwhite ) || [];\n-\t}\n-\treturn [];\n-}\n-\n-jQuery.fn.extend( {\n-\taddClass: function( value ) {\n-\t\tvar classNames, cur, curValue, className, i, finalValue;\n-\n-\t\tif ( isFunction( value ) ) {\n-\t\t\treturn this.each( function( j ) {\n-\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n-\t\t\t} );\n-\t\t}\n-\n-\t\tclassNames = classesToArray( value );\n-\n-\t\tif ( classNames.length ) {\n-\t\t\treturn this.each( function() {\n-\t\t\t\tcurValue = getClass( this );\n-\t\t\t\tcur = this.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n-\n-\t\t\t\tif ( cur ) {\n-\t\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n-\t\t\t\t\t\tclassName = classNames[ i ];\n-\t\t\t\t\t\tif ( cur.indexOf( \" \" + className + \" \" ) < 0 ) {\n-\t\t\t\t\t\t\tcur += className + \" \";\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n-\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n-\t\t\t\t\tif ( curValue !== finalValue ) {\n-\t\t\t\t\t\tthis.setAttribute( \"class\", finalValue );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} );\n-\t\t}\n-\n-\t\treturn this;\n-\t},\n-\n-\tremoveClass: function( value ) {\n-\t\tvar classNames, cur, curValue, className, i, finalValue;\n-\n-\t\tif ( isFunction( value ) ) {\n-\t\t\treturn this.each( function( j ) {\n-\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n-\t\t\t} );\n-\t\t}\n-\n-\t\tif ( !arguments.length ) {\n-\t\t\treturn this.attr( \"class\", \"\" );\n-\t\t}\n-\n-\t\tclassNames = classesToArray( value );\n-\n-\t\tif ( classNames.length ) {\n-\t\t\treturn this.each( function() {\n-\t\t\t\tcurValue = getClass( this );\n-\n-\t\t\t\t// This expression is here for better compressibility (see addClass)\n-\t\t\t\tcur = this.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n-\n-\t\t\t\tif ( cur ) {\n-\t\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n-\t\t\t\t\t\tclassName = classNames[ i ];\n-\n-\t\t\t\t\t\t// Remove *all* instances\n-\t\t\t\t\t\twhile ( cur.indexOf( \" \" + className + \" \" ) > -1 ) {\n-\t\t\t\t\t\t\tcur = cur.replace( \" \" + className + \" \", \" \" );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n-\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n-\t\t\t\t\tif ( curValue !== finalValue ) {\n-\t\t\t\t\t\tthis.setAttribute( \"class\", finalValue );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} );\n-\t\t}\n-\n-\t\treturn this;\n-\t},\n-\n-\ttoggleClass: function( value, stateVal ) {\n-\t\tvar classNames, className, i, self,\n-\t\t\ttype = typeof value,\n-\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n-\n-\t\tif ( isFunction( value ) ) {\n-\t\t\treturn this.each( function( i ) {\n-\t\t\t\tjQuery( this ).toggleClass(\n-\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n-\t\t\t\t\tstateVal\n-\t\t\t\t);\n-\t\t\t} );\n-\t\t}\n-\n-\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n-\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n-\t\t}\n-\n-\t\tclassNames = classesToArray( value );\n-\n-\t\treturn this.each( function() {\n-\t\t\tif ( isValidValue ) {\n-\n-\t\t\t\t// Toggle individual class names\n-\t\t\t\tself = jQuery( this );\n-\n-\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n-\t\t\t\t\tclassName = classNames[ i ];\n-\n-\t\t\t\t\t// Check each className given, space separated list\n-\t\t\t\t\tif ( self.hasClass( className ) ) {\n-\t\t\t\t\t\tself.removeClass( className );\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tself.addClass( className );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t// Toggle whole class name\n-\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n-\t\t\t\tclassName = getClass( this );\n-\t\t\t\tif ( className ) {\n-\n-\t\t\t\t\t// Store className if set\n-\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n-\t\t\t\t}\n-\n-\t\t\t\t// If the element has a class name or if we're passed `false`,\n-\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n-\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n-\t\t\t\t// falling back to the empty string if nothing was stored.\n-\t\t\t\tif ( this.setAttribute ) {\n-\t\t\t\t\tthis.setAttribute( \"class\",\n-\t\t\t\t\t\tclassName || value === false ?\n-\t\t\t\t\t\t\t\"\" :\n-\t\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\thasClass: function( selector ) {\n-\t\tvar className, elem,\n-\t\t\ti = 0;\n-\n-\t\tclassName = \" \" + selector + \" \";\n-\t\twhile ( ( elem = this[ i++ ] ) ) {\n-\t\t\tif ( elem.nodeType === 1 &&\n-\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-} );\n-\n-\n-\n-\n-var rreturn = /\\r/g;\n-\n-jQuery.fn.extend( {\n-\tval: function( value ) {\n-\t\tvar hooks, ret, valueIsFunction,\n-\t\t\telem = this[ 0 ];\n-\n-\t\tif ( !arguments.length ) {\n-\t\t\tif ( elem ) {\n-\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n-\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n-\n-\t\t\t\tif ( hooks &&\n-\t\t\t\t\t\"get\" in hooks &&\n-\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n-\t\t\t\t) {\n-\t\t\t\t\treturn ret;\n-\t\t\t\t}\n-\n-\t\t\t\tret = elem.value;\n-\n-\t\t\t\t// Handle most common string cases\n-\t\t\t\tif ( typeof ret === \"string\" ) {\n-\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n-\t\t\t\t}\n-\n-\t\t\t\t// Handle cases where value is null/undef or number\n-\t\t\t\treturn ret == null ? \"\" : ret;\n-\t\t\t}\n-\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tvalueIsFunction = isFunction( value );\n-\n-\t\treturn this.each( function( i ) {\n-\t\t\tvar val;\n-\n-\t\t\tif ( this.nodeType !== 1 ) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tif ( valueIsFunction ) {\n-\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n-\t\t\t} else {\n-\t\t\t\tval = value;\n-\t\t\t}\n-\n-\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n-\t\t\tif ( val == null ) {\n-\t\t\t\tval = \"\";\n-\n-\t\t\t} else if ( typeof val === \"number\" ) {\n-\t\t\t\tval += \"\";\n-\n-\t\t\t} else if ( Array.isArray( val ) ) {\n-\t\t\t\tval = jQuery.map( val, function( value ) {\n-\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n-\t\t\t\t} );\n-\t\t\t}\n-\n-\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n-\n-\t\t\t// If set returns undefined, fall back to normal setting\n-\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n-\t\t\t\tthis.value = val;\n-\t\t\t}\n-\t\t} );\n-\t}\n-} );\n-\n-jQuery.extend( {\n-\tvalHooks: {\n-\t\toption: {\n-\t\t\tget: function( elem ) {\n-\n-\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n-\t\t\t\treturn val != null ?\n-\t\t\t\t\tval :\n-\n-\t\t\t\t\t// Support: IE <=10 - 11 only\n-\t\t\t\t\t// option.text throws exceptions (trac-14686, trac-14858)\n-\t\t\t\t\t// Strip and collapse whitespace\n-\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n-\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n-\t\t\t}\n-\t\t},\n-\t\tselect: {\n-\t\t\tget: function( elem ) {\n-\t\t\t\tvar value, option, i,\n-\t\t\t\t\toptions = elem.options,\n-\t\t\t\t\tindex = elem.selectedIndex,\n-\t\t\t\t\tone = elem.type === \"select-one\",\n-\t\t\t\t\tvalues = one ? null : [],\n-\t\t\t\t\tmax = one ? index + 1 : options.length;\n-\n-\t\t\t\tif ( index < 0 ) {\n-\t\t\t\t\ti = max;\n-\n-\t\t\t\t} else {\n-\t\t\t\t\ti = one ? index : 0;\n-\t\t\t\t}\n-\n-\t\t\t\t// Loop through all the selected options\n-\t\t\t\tfor ( ; i < max; i++ ) {\n-\t\t\t\t\toption = options[ i ];\n-\n-\t\t\t\t\t// Support: IE <=9 only\n-\t\t\t\t\t// IE8-9 doesn't update selected after form reset (trac-2551)\n-\t\t\t\t\tif ( ( option.selected || i === index ) &&\n-\n-\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n-\t\t\t\t\t\t\t!option.disabled &&\n-\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n-\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n-\n-\t\t\t\t\t\t// Get the specific value for the option\n-\t\t\t\t\t\tvalue = jQuery( option ).val();\n-\n-\t\t\t\t\t\t// We don't need an array for one selects\n-\t\t\t\t\t\tif ( one ) {\n-\t\t\t\t\t\t\treturn value;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t// Multi-Selects return an array\n-\t\t\t\t\t\tvalues.push( value );\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\treturn values;\n-\t\t\t},\n-\n-\t\t\tset: function( elem, value ) {\n-\t\t\t\tvar optionSet, option,\n-\t\t\t\t\toptions = elem.options,\n-\t\t\t\t\tvalues = jQuery.makeArray( value ),\n-\t\t\t\t\ti = options.length;\n-\n-\t\t\t\twhile ( i-- ) {\n-\t\t\t\t\toption = options[ i ];\n-\n-\t\t\t\t\t/* eslint-disable no-cond-assign */\n-\n-\t\t\t\t\tif ( option.selected =\n-\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n-\t\t\t\t\t) {\n-\t\t\t\t\t\toptionSet = true;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t/* eslint-enable no-cond-assign */\n-\t\t\t\t}\n-\n-\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n-\t\t\t\tif ( !optionSet ) {\n-\t\t\t\t\telem.selectedIndex = -1;\n-\t\t\t\t}\n-\t\t\t\treturn values;\n-\t\t\t}\n-\t\t}\n-\t}\n-} );\n-\n-// Radios and checkboxes getter/setter\n-jQuery.each( [ \"radio\", \"checkbox\" ], function() {\n-\tjQuery.valHooks[ this ] = {\n-\t\tset: function( elem, value ) {\n-\t\t\tif ( Array.isArray( value ) ) {\n-\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n-\t\t\t}\n-\t\t}\n-\t};\n-\tif ( !support.checkOn ) {\n-\t\tjQuery.valHooks[ this ].get = function( elem ) {\n-\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n-\t\t};\n-\t}\n-} );\n-\n-\n-\n-\n-// Return jQuery for attributes-only inclusion\n-\n-\n-support.focusin = \"onfocusin\" in window;\n-\n-\n-var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n-\tstopPropagationCallback = function( e ) {\n-\t\te.stopPropagation();\n-\t};\n-\n-jQuery.extend( jQuery.event, {\n-\n-\ttrigger: function( event, data, elem, onlyHandlers ) {\n-\n-\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n-\t\t\teventPath = [ elem || document ],\n-\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n-\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n-\n-\t\tcur = lastElement = tmp = elem = elem || document;\n-\n-\t\t// Don't do events on text and comment nodes\n-\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n-\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif ( type.indexOf( \".\" ) > -1 ) {\n-\n-\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n-\t\t\tnamespaces = type.split( \".\" );\n-\t\t\ttype = namespaces.shift();\n-\t\t\tnamespaces.sort();\n-\t\t}\n-\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n-\n-\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n-\t\tevent = event[ jQuery.expando ] ?\n-\t\t\tevent :\n-\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n-\n-\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n-\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n-\t\tevent.namespace = namespaces.join( \".\" );\n-\t\tevent.rnamespace = event.namespace ?\n-\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n-\t\t\tnull;\n-\n-\t\t// Clean up the event in case it is being reused\n-\t\tevent.result = undefined;\n-\t\tif ( !event.target ) {\n-\t\t\tevent.target = elem;\n-\t\t}\n-\n-\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n-\t\tdata = data == null ?\n-\t\t\t[ event ] :\n-\t\t\tjQuery.makeArray( data, [ event ] );\n-\n-\t\t// Allow special events to draw outside the lines\n-\t\tspecial = jQuery.event.special[ type ] || {};\n-\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Determine event propagation path in advance, per W3C events spec (trac-9951)\n-\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)\n-\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n-\n-\t\t\tbubbleType = special.delegateType || type;\n-\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n-\t\t\t\tcur = cur.parentNode;\n-\t\t\t}\n-\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n-\t\t\t\teventPath.push( cur );\n-\t\t\t\ttmp = cur;\n-\t\t\t}\n-\n-\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n-\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n-\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Fire handlers on the event path\n-\t\ti = 0;\n-\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n-\t\t\tlastElement = cur;\n-\t\t\tevent.type = i > 1 ?\n-\t\t\t\tbubbleType :\n-\t\t\t\tspecial.bindType || type;\n-\n-\t\t\t// jQuery handler\n-\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || Object.create( null ) )[ event.type ] &&\n-\t\t\t\tdataPriv.get( cur, \"handle\" );\n-\t\t\tif ( handle ) {\n-\t\t\t\thandle.apply( cur, data );\n-\t\t\t}\n-\n-\t\t\t// Native handler\n-\t\t\thandle = ontype && cur[ ontype ];\n-\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n-\t\t\t\tevent.result = handle.apply( cur, data );\n-\t\t\t\tif ( event.result === false ) {\n-\t\t\t\t\tevent.preventDefault();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tevent.type = type;\n-\n-\t\t// If nobody prevented the default action, do it now\n-\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n-\n-\t\t\tif ( ( !special._default ||\n-\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n-\t\t\t\tacceptData( elem ) ) {\n-\n-\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n-\t\t\t\t// Don't do default actions on window, that's where global variables be (trac-6170)\n-\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n-\n-\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n-\t\t\t\t\ttmp = elem[ ontype ];\n-\n-\t\t\t\t\tif ( tmp ) {\n-\t\t\t\t\t\telem[ ontype ] = null;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n-\t\t\t\t\tjQuery.event.triggered = type;\n-\n-\t\t\t\t\tif ( event.isPropagationStopped() ) {\n-\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n-\t\t\t\t\t}\n-\n-\t\t\t\t\telem[ type ]();\n-\n-\t\t\t\t\tif ( event.isPropagationStopped() ) {\n-\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tjQuery.event.triggered = undefined;\n-\n-\t\t\t\t\tif ( tmp ) {\n-\t\t\t\t\t\telem[ ontype ] = tmp;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn event.result;\n-\t},\n-\n-\t// Piggyback on a donor event to simulate a different one\n-\t// Used only for `focus(in | out)` events\n-\tsimulate: function( type, elem, event ) {\n-\t\tvar e = jQuery.extend(\n-\t\t\tnew jQuery.Event(),\n-\t\t\tevent,\n-\t\t\t{\n-\t\t\t\ttype: type,\n-\t\t\t\tisSimulated: true\n-\t\t\t}\n-\t\t);\n-\n-\t\tjQuery.event.trigger( e, null, elem );\n-\t}\n-\n-} );\n-\n-jQuery.fn.extend( {\n-\n-\ttrigger: function( type, data ) {\n-\t\treturn this.each( function() {\n-\t\t\tjQuery.event.trigger( type, data, this );\n-\t\t} );\n-\t},\n-\ttriggerHandler: function( type, data ) {\n-\t\tvar elem = this[ 0 ];\n-\t\tif ( elem ) {\n-\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n-\t\t}\n-\t}\n-} );\n-\n-\n-// Support: Firefox <=44\n-// Firefox doesn't have focus(in | out) events\n-// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n-//\n-// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n-// focus(in | out) events fire after focus & blur events,\n-// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n-// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n-if ( !support.focusin ) {\n-\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n-\n-\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n-\t\tvar handler = function( event ) {\n-\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n-\t\t};\n-\n-\t\tjQuery.event.special[ fix ] = {\n-\t\t\tsetup: function() {\n-\n-\t\t\t\t// Handle: regular nodes (via `this.ownerDocument`), window\n-\t\t\t\t// (via `this.document`) & document (via `this`).\n-\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n-\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n-\n-\t\t\t\tif ( !attaches ) {\n-\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n-\t\t\t\t}\n-\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n-\t\t\t},\n-\t\t\tteardown: function() {\n-\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n-\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n-\n-\t\t\t\tif ( !attaches ) {\n-\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n-\t\t\t\t\tdataPriv.remove( doc, fix );\n-\n-\t\t\t\t} else {\n-\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t};\n-\t} );\n-}\n-var location = window.location;\n-\n-var nonce = { guid: Date.now() };\n-\n-var rquery = ( /\\?/ );\n-\n-\n-\n-// Cross-browser xml parsing\n-jQuery.parseXML = function( data ) {\n-\tvar xml, parserErrorElem;\n-\tif ( !data || typeof data !== \"string\" ) {\n-\t\treturn null;\n-\t}\n-\n-\t// Support: IE 9 - 11 only\n-\t// IE throws on parseFromString with invalid input.\n-\ttry {\n-\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n-\t} catch ( e ) {}\n-\n-\tparserErrorElem = xml && xml.getElementsByTagName( \"parsererror\" )[ 0 ];\n-\tif ( !xml || parserErrorElem ) {\n-\t\tjQuery.error( \"Invalid XML: \" + (\n-\t\t\tparserErrorElem ?\n-\t\t\t\tjQuery.map( parserErrorElem.childNodes, function( el ) {\n-\t\t\t\t\treturn el.textContent;\n-\t\t\t\t} ).join( \"\\n\" ) :\n-\t\t\t\tdata\n-\t\t) );\n-\t}\n-\treturn xml;\n-};\n-\n-\n-var\n-\trbracket = /\\[\\]$/,\n-\trCRLF = /\\r?\\n/g,\n-\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n-\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n-\n-function buildParams( prefix, obj, traditional, add ) {\n-\tvar name;\n-\n-\tif ( Array.isArray( obj ) ) {\n-\n-\t\t// Serialize array item.\n-\t\tjQuery.each( obj, function( i, v ) {\n-\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n-\n-\t\t\t\t// Treat each array item as a scalar.\n-\t\t\t\tadd( prefix, v );\n-\n-\t\t\t} else {\n-\n-\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n-\t\t\t\tbuildParams(\n-\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n-\t\t\t\t\tv,\n-\t\t\t\t\ttraditional,\n-\t\t\t\t\tadd\n-\t\t\t\t);\n-\t\t\t}\n-\t\t} );\n-\n-\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n-\n-\t\t// Serialize object item.\n-\t\tfor ( name in obj ) {\n-\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n-\t\t}\n-\n-\t} else {\n-\n-\t\t// Serialize scalar item.\n-\t\tadd( prefix, obj );\n-\t}\n-}\n-\n-// Serialize an array of form elements or a set of\n-// key/values into a query string\n-jQuery.param = function( a, traditional ) {\n-\tvar prefix,\n-\t\ts = [],\n-\t\tadd = function( key, valueOrFunction ) {\n-\n-\t\t\t// If value is a function, invoke it and use its return value\n-\t\t\tvar value = isFunction( valueOrFunction ) ?\n-\t\t\t\tvalueOrFunction() :\n-\t\t\t\tvalueOrFunction;\n-\n-\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n-\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n-\t\t};\n-\n-\tif ( a == null ) {\n-\t\treturn \"\";\n-\t}\n-\n-\t// If an array was passed in, assume that it is an array of form elements.\n-\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n-\n-\t\t// Serialize the form elements\n-\t\tjQuery.each( a, function() {\n-\t\t\tadd( this.name, this.value );\n-\t\t} );\n-\n-\t} else {\n-\n-\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n-\t\t// did it), otherwise encode params recursively.\n-\t\tfor ( prefix in a ) {\n-\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n-\t\t}\n-\t}\n-\n-\t// Return the resulting serialization\n-\treturn s.join( \"&\" );\n-};\n-\n-jQuery.fn.extend( {\n-\tserialize: function() {\n-\t\treturn jQuery.param( this.serializeArray() );\n-\t},\n-\tserializeArray: function() {\n-\t\treturn this.map( function() {\n-\n-\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n-\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n-\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n-\t\t} ).filter( function() {\n-\t\t\tvar type = this.type;\n-\n-\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n-\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n-\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n-\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n-\t\t} ).map( function( _i, elem ) {\n-\t\t\tvar val = jQuery( this ).val();\n-\n-\t\t\tif ( val == null ) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\tif ( Array.isArray( val ) ) {\n-\t\t\t\treturn jQuery.map( val, function( val ) {\n-\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n-\t\t\t\t} );\n-\t\t\t}\n-\n-\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n-\t\t} ).get();\n-\t}\n-} );\n-\n-\n-var\n-\tr20 = /%20/g,\n-\trhash = /#.*$/,\n-\trantiCache = /([?&])_=[^&]*/,\n-\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n-\n-\t// trac-7653, trac-8125, trac-8152: local protocol detection\n-\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n-\trnoContent = /^(?:GET|HEAD)$/,\n-\trprotocol = /^\\/\\//,\n-\n-\t/* Prefilters\n-\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n-\t * 2) These are called:\n-\t *    - BEFORE asking for a transport\n-\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n-\t * 3) key is the dataType\n-\t * 4) the catchall symbol \"*\" can be used\n-\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n-\t */\n-\tprefilters = {},\n-\n-\t/* Transports bindings\n-\t * 1) key is the dataType\n-\t * 2) the catchall symbol \"*\" can be used\n-\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n-\t */\n-\ttransports = {},\n-\n-\t// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression\n-\tallTypes = \"*/\".concat( \"*\" ),\n-\n-\t// Anchor tag for parsing the document origin\n-\toriginAnchor = document.createElement( \"a\" );\n-\n-originAnchor.href = location.href;\n-\n-// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n-function addToPrefiltersOrTransports( structure ) {\n-\n-\t// dataTypeExpression is optional and defaults to \"*\"\n-\treturn function( dataTypeExpression, func ) {\n-\n-\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n-\t\t\tfunc = dataTypeExpression;\n-\t\t\tdataTypeExpression = \"*\";\n-\t\t}\n-\n-\t\tvar dataType,\n-\t\t\ti = 0,\n-\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n-\n-\t\tif ( isFunction( func ) ) {\n-\n-\t\t\t// For each dataType in the dataTypeExpression\n-\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n-\n-\t\t\t\t// Prepend if requested\n-\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n-\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n-\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n-\n-\t\t\t\t// Otherwise append\n-\t\t\t\t} else {\n-\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-}\n-\n-// Base inspection function for prefilters and transports\n-function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n-\n-\tvar inspected = {},\n-\t\tseekingTransport = ( structure === transports );\n-\n-\tfunction inspect( dataType ) {\n-\t\tvar selected;\n-\t\tinspected[ dataType ] = true;\n-\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n-\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n-\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n-\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n-\n-\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n-\t\t\t\tinspect( dataTypeOrTransport );\n-\t\t\t\treturn false;\n-\t\t\t} else if ( seekingTransport ) {\n-\t\t\t\treturn !( selected = dataTypeOrTransport );\n-\t\t\t}\n-\t\t} );\n-\t\treturn selected;\n-\t}\n-\n-\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n-}\n-\n-// A special extend for ajax options\n-// that takes \"flat\" options (not to be deep extended)\n-// Fixes trac-9887\n-function ajaxExtend( target, src ) {\n-\tvar key, deep,\n-\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n-\n-\tfor ( key in src ) {\n-\t\tif ( src[ key ] !== undefined ) {\n-\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n-\t\t}\n-\t}\n-\tif ( deep ) {\n-\t\tjQuery.extend( true, target, deep );\n-\t}\n-\n-\treturn target;\n-}\n-\n-/* Handles responses to an ajax request:\n- * - finds the right dataType (mediates between content-type and expected dataType)\n- * - returns the corresponding response\n- */\n-function ajaxHandleResponses( s, jqXHR, responses ) {\n-\n-\tvar ct, type, finalDataType, firstDataType,\n-\t\tcontents = s.contents,\n-\t\tdataTypes = s.dataTypes;\n-\n-\t// Remove auto dataType and get content-type in the process\n-\twhile ( dataTypes[ 0 ] === \"*\" ) {\n-\t\tdataTypes.shift();\n-\t\tif ( ct === undefined ) {\n-\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n-\t\t}\n-\t}\n-\n-\t// Check if we're dealing with a known content-type\n-\tif ( ct ) {\n-\t\tfor ( type in contents ) {\n-\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n-\t\t\t\tdataTypes.unshift( type );\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Check to see if we have a response for the expected dataType\n-\tif ( dataTypes[ 0 ] in responses ) {\n-\t\tfinalDataType = dataTypes[ 0 ];\n-\t} else {\n-\n-\t\t// Try convertible dataTypes\n-\t\tfor ( type in responses ) {\n-\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n-\t\t\t\tfinalDataType = type;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tif ( !firstDataType ) {\n-\t\t\t\tfirstDataType = type;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Or just use first one\n-\t\tfinalDataType = finalDataType || firstDataType;\n-\t}\n-\n-\t// If we found a dataType\n-\t// We add the dataType to the list if needed\n-\t// and return the corresponding response\n-\tif ( finalDataType ) {\n-\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n-\t\t\tdataTypes.unshift( finalDataType );\n-\t\t}\n-\t\treturn responses[ finalDataType ];\n-\t}\n-}\n-\n-/* Chain conversions given the request and the original response\n- * Also sets the responseXXX fields on the jqXHR instance\n- */\n-function ajaxConvert( s, response, jqXHR, isSuccess ) {\n-\tvar conv2, current, conv, tmp, prev,\n-\t\tconverters = {},\n-\n-\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n-\t\tdataTypes = s.dataTypes.slice();\n-\n-\t// Create converters map with lowercased keys\n-\tif ( dataTypes[ 1 ] ) {\n-\t\tfor ( conv in s.converters ) {\n-\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n-\t\t}\n-\t}\n-\n-\tcurrent = dataTypes.shift();\n-\n-\t// Convert to each sequential dataType\n-\twhile ( current ) {\n-\n-\t\tif ( s.responseFields[ current ] ) {\n-\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n-\t\t}\n-\n-\t\t// Apply the dataFilter if provided\n-\t\tif ( !prev && isSuccess && s.dataFilter ) {\n-\t\t\tresponse = s.dataFilter( response, s.dataType );\n-\t\t}\n-\n-\t\tprev = current;\n-\t\tcurrent = dataTypes.shift();\n-\n-\t\tif ( current ) {\n-\n-\t\t\t// There's only work to do if current dataType is non-auto\n-\t\t\tif ( current === \"*\" ) {\n-\n-\t\t\t\tcurrent = prev;\n-\n-\t\t\t// Convert response if prev dataType is non-auto and differs from current\n-\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n-\n-\t\t\t\t// Seek a direct converter\n-\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n-\n-\t\t\t\t// If none found, seek a pair\n-\t\t\t\tif ( !conv ) {\n-\t\t\t\t\tfor ( conv2 in converters ) {\n-\n-\t\t\t\t\t\t// If conv2 outputs current\n-\t\t\t\t\t\ttmp = conv2.split( \" \" );\n-\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n-\n-\t\t\t\t\t\t\t// If prev can be converted to accepted input\n-\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n-\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n-\t\t\t\t\t\t\tif ( conv ) {\n-\n-\t\t\t\t\t\t\t\t// Condense equivalence converters\n-\t\t\t\t\t\t\t\tif ( conv === true ) {\n-\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n-\n-\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n-\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n-\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n-\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// Apply converter (if not an equivalence)\n-\t\t\t\tif ( conv !== true ) {\n-\n-\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n-\t\t\t\t\tif ( conv && s.throws ) {\n-\t\t\t\t\t\tresponse = conv( response );\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tresponse = conv( response );\n-\t\t\t\t\t\t} catch ( e ) {\n-\t\t\t\t\t\t\treturn {\n-\t\t\t\t\t\t\t\tstate: \"parsererror\",\n-\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n-\t\t\t\t\t\t\t};\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn { state: \"success\", data: response };\n-}\n-\n-jQuery.extend( {\n-\n-\t// Counter for holding the number of active queries\n-\tactive: 0,\n-\n-\t// Last-Modified header cache for next request\n-\tlastModified: {},\n-\tetag: {},\n-\n-\tajaxSettings: {\n-\t\turl: location.href,\n-\t\ttype: \"GET\",\n-\t\tisLocal: rlocalProtocol.test( location.protocol ),\n-\t\tglobal: true,\n-\t\tprocessData: true,\n-\t\tasync: true,\n-\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n-\n-\t\t/*\n-\t\ttimeout: 0,\n-\t\tdata: null,\n-\t\tdataType: null,\n-\t\tusername: null,\n-\t\tpassword: null,\n-\t\tcache: null,\n-\t\tthrows: false,\n-\t\ttraditional: false,\n-\t\theaders: {},\n-\t\t*/\n-\n-\t\taccepts: {\n-\t\t\t\"*\": allTypes,\n-\t\t\ttext: \"text/plain\",\n-\t\t\thtml: \"text/html\",\n-\t\t\txml: \"application/xml, text/xml\",\n-\t\t\tjson: \"application/json, text/javascript\"\n-\t\t},\n-\n-\t\tcontents: {\n-\t\t\txml: /\\bxml\\b/,\n-\t\t\thtml: /\\bhtml/,\n-\t\t\tjson: /\\bjson\\b/\n-\t\t},\n-\n-\t\tresponseFields: {\n-\t\t\txml: \"responseXML\",\n-\t\t\ttext: \"responseText\",\n-\t\t\tjson: \"responseJSON\"\n-\t\t},\n-\n-\t\t// Data converters\n-\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n-\t\tconverters: {\n-\n-\t\t\t// Convert anything to text\n-\t\t\t\"* text\": String,\n-\n-\t\t\t// Text to html (true = no transformation)\n-\t\t\t\"text html\": true,\n-\n-\t\t\t// Evaluate text as a json expression\n-\t\t\t\"text json\": JSON.parse,\n-\n-\t\t\t// Parse text as xml\n-\t\t\t\"text xml\": jQuery.parseXML\n-\t\t},\n-\n-\t\t// For options that shouldn't be deep extended:\n-\t\t// you can add your own custom options here if\n-\t\t// and when you create one that shouldn't be\n-\t\t// deep extended (see ajaxExtend)\n-\t\tflatOptions: {\n-\t\t\turl: true,\n-\t\t\tcontext: true\n-\t\t}\n-\t},\n-\n-\t// Creates a full fledged settings object into target\n-\t// with both ajaxSettings and settings fields.\n-\t// If target is omitted, writes into ajaxSettings.\n-\tajaxSetup: function( target, settings ) {\n-\t\treturn settings ?\n-\n-\t\t\t// Building a settings object\n-\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n-\n-\t\t\t// Extending ajaxSettings\n-\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n-\t},\n-\n-\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n-\tajaxTransport: addToPrefiltersOrTransports( transports ),\n-\n-\t// Main method\n-\tajax: function( url, options ) {\n-\n-\t\t// If url is an object, simulate pre-1.5 signature\n-\t\tif ( typeof url === \"object\" ) {\n-\t\t\toptions = url;\n-\t\t\turl = undefined;\n-\t\t}\n-\n-\t\t// Force options to be an object\n-\t\toptions = options || {};\n-\n-\t\tvar transport,\n-\n-\t\t\t// URL without anti-cache param\n-\t\t\tcacheURL,\n-\n-\t\t\t// Response headers\n-\t\t\tresponseHeadersString,\n-\t\t\tresponseHeaders,\n-\n-\t\t\t// timeout handle\n-\t\t\ttimeoutTimer,\n-\n-\t\t\t// Url cleanup var\n-\t\t\turlAnchor,\n-\n-\t\t\t// Request state (becomes false upon send and true upon completion)\n-\t\t\tcompleted,\n-\n-\t\t\t// To know if global events are to be dispatched\n-\t\t\tfireGlobals,\n-\n-\t\t\t// Loop variable\n-\t\t\ti,\n-\n-\t\t\t// uncached part of the url\n-\t\t\tuncached,\n-\n-\t\t\t// Create the final options object\n-\t\t\ts = jQuery.ajaxSetup( {}, options ),\n-\n-\t\t\t// Callbacks context\n-\t\t\tcallbackContext = s.context || s,\n-\n-\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n-\t\t\tglobalEventContext = s.context &&\n-\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n-\t\t\t\tjQuery( callbackContext ) :\n-\t\t\t\tjQuery.event,\n-\n-\t\t\t// Deferreds\n-\t\t\tdeferred = jQuery.Deferred(),\n-\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n-\n-\t\t\t// Status-dependent callbacks\n-\t\t\tstatusCode = s.statusCode || {},\n-\n-\t\t\t// Headers (they are sent all at once)\n-\t\t\trequestHeaders = {},\n-\t\t\trequestHeadersNames = {},\n-\n-\t\t\t// Default abort message\n-\t\t\tstrAbort = \"canceled\",\n-\n-\t\t\t// Fake xhr\n-\t\t\tjqXHR = {\n-\t\t\t\treadyState: 0,\n-\n-\t\t\t\t// Builds headers hashtable if needed\n-\t\t\t\tgetResponseHeader: function( key ) {\n-\t\t\t\t\tvar match;\n-\t\t\t\t\tif ( completed ) {\n-\t\t\t\t\t\tif ( !responseHeaders ) {\n-\t\t\t\t\t\t\tresponseHeaders = {};\n-\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n-\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + \" \" ] =\n-\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + \" \" ] || [] )\n-\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + \" \" ];\n-\t\t\t\t\t}\n-\t\t\t\t\treturn match == null ? null : match.join( \", \" );\n-\t\t\t\t},\n-\n-\t\t\t\t// Raw string\n-\t\t\t\tgetAllResponseHeaders: function() {\n-\t\t\t\t\treturn completed ? responseHeadersString : null;\n-\t\t\t\t},\n-\n-\t\t\t\t// Caches the header\n-\t\t\t\tsetRequestHeader: function( name, value ) {\n-\t\t\t\t\tif ( completed == null ) {\n-\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n-\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n-\t\t\t\t\t\trequestHeaders[ name ] = value;\n-\t\t\t\t\t}\n-\t\t\t\t\treturn this;\n-\t\t\t\t},\n-\n-\t\t\t\t// Overrides response content-type header\n-\t\t\t\toverrideMimeType: function( type ) {\n-\t\t\t\t\tif ( completed == null ) {\n-\t\t\t\t\t\ts.mimeType = type;\n-\t\t\t\t\t}\n-\t\t\t\t\treturn this;\n-\t\t\t\t},\n-\n-\t\t\t\t// Status-dependent callbacks\n-\t\t\t\tstatusCode: function( map ) {\n-\t\t\t\t\tvar code;\n-\t\t\t\t\tif ( map ) {\n-\t\t\t\t\t\tif ( completed ) {\n-\n-\t\t\t\t\t\t\t// Execute the appropriate callbacks\n-\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n-\t\t\t\t\t\t} else {\n-\n-\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n-\t\t\t\t\t\t\tfor ( code in map ) {\n-\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\treturn this;\n-\t\t\t\t},\n-\n-\t\t\t\t// Cancel the request\n-\t\t\t\tabort: function( statusText ) {\n-\t\t\t\t\tvar finalText = statusText || strAbort;\n-\t\t\t\t\tif ( transport ) {\n-\t\t\t\t\t\ttransport.abort( finalText );\n-\t\t\t\t\t}\n-\t\t\t\t\tdone( 0, finalText );\n-\t\t\t\t\treturn this;\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\t// Attach deferreds\n-\t\tdeferred.promise( jqXHR );\n-\n-\t\t// Add protocol if not provided (prefilters might expect it)\n-\t\t// Handle falsy url in the settings object (trac-10093: consistency with old signature)\n-\t\t// We also use the url parameter if available\n-\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n-\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n-\n-\t\t// Alias method option to type as per ticket trac-12004\n-\t\ts.type = options.method || options.type || s.method || s.type;\n-\n-\t\t// Extract dataTypes list\n-\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n-\n-\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n-\t\tif ( s.crossDomain == null ) {\n-\t\t\turlAnchor = document.createElement( \"a\" );\n-\n-\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n-\t\t\t// IE throws exception on accessing the href property if url is malformed,\n-\t\t\t// e.g. http://example.com:80x/\n-\t\t\ttry {\n-\t\t\t\turlAnchor.href = s.url;\n-\n-\t\t\t\t// Support: IE <=8 - 11 only\n-\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n-\t\t\t\turlAnchor.href = urlAnchor.href;\n-\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n-\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n-\t\t\t} catch ( e ) {\n-\n-\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n-\t\t\t\t// it can be rejected by the transport if it is invalid\n-\t\t\t\ts.crossDomain = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Convert data if not already a string\n-\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n-\t\t\ts.data = jQuery.param( s.data, s.traditional );\n-\t\t}\n-\n-\t\t// Apply prefilters\n-\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n-\n-\t\t// If request was aborted inside a prefilter, stop there\n-\t\tif ( completed ) {\n-\t\t\treturn jqXHR;\n-\t\t}\n-\n-\t\t// We can fire global events as of now if asked to\n-\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)\n-\t\tfireGlobals = jQuery.event && s.global;\n-\n-\t\t// Watch for a new set of requests\n-\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n-\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n-\t\t}\n-\n-\t\t// Uppercase the type\n-\t\ts.type = s.type.toUpperCase();\n-\n-\t\t// Determine if request has content\n-\t\ts.hasContent = !rnoContent.test( s.type );\n-\n-\t\t// Save the URL in case we're toying with the If-Modified-Since\n-\t\t// and/or If-None-Match header later on\n-\t\t// Remove hash to simplify url manipulation\n-\t\tcacheURL = s.url.replace( rhash, \"\" );\n-\n-\t\t// More options handling for requests with no content\n-\t\tif ( !s.hasContent ) {\n-\n-\t\t\t// Remember the hash so we can put it back\n-\t\t\tuncached = s.url.slice( cacheURL.length );\n-\n-\t\t\t// If data is available and should be processed, append data to url\n-\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n-\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n-\n-\t\t\t\t// trac-9682: remove data so that it's not used in an eventual retry\n-\t\t\t\tdelete s.data;\n-\t\t\t}\n-\n-\t\t\t// Add or update anti-cache param if needed\n-\t\t\tif ( s.cache === false ) {\n-\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n-\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce.guid++ ) +\n-\t\t\t\t\tuncached;\n-\t\t\t}\n-\n-\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n-\t\t\ts.url = cacheURL + uncached;\n-\n-\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n-\t\t} else if ( s.data && s.processData &&\n-\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n-\t\t\ts.data = s.data.replace( r20, \"+\" );\n-\t\t}\n-\n-\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n-\t\tif ( s.ifModified ) {\n-\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n-\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n-\t\t\t}\n-\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n-\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Set the correct header, if data is being sent\n-\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n-\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n-\t\t}\n-\n-\t\t// Set the Accepts header for the server, depending on the dataType\n-\t\tjqXHR.setRequestHeader(\n-\t\t\t\"Accept\",\n-\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n-\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n-\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n-\t\t\t\ts.accepts[ \"*\" ]\n-\t\t);\n-\n-\t\t// Check for headers option\n-\t\tfor ( i in s.headers ) {\n-\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n-\t\t}\n-\n-\t\t// Allow custom headers/mimetypes and early abort\n-\t\tif ( s.beforeSend &&\n-\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n-\n-\t\t\t// Abort if not done already and return\n-\t\t\treturn jqXHR.abort();\n-\t\t}\n-\n-\t\t// Aborting is no longer a cancellation\n-\t\tstrAbort = \"abort\";\n-\n-\t\t// Install callbacks on deferreds\n-\t\tcompleteDeferred.add( s.complete );\n-\t\tjqXHR.done( s.success );\n-\t\tjqXHR.fail( s.error );\n-\n-\t\t// Get transport\n-\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n-\n-\t\t// If no transport, we auto-abort\n-\t\tif ( !transport ) {\n-\t\t\tdone( -1, \"No Transport\" );\n-\t\t} else {\n-\t\t\tjqXHR.readyState = 1;\n-\n-\t\t\t// Send global event\n-\t\t\tif ( fireGlobals ) {\n-\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n-\t\t\t}\n-\n-\t\t\t// If request was aborted inside ajaxSend, stop there\n-\t\t\tif ( completed ) {\n-\t\t\t\treturn jqXHR;\n-\t\t\t}\n-\n-\t\t\t// Timeout\n-\t\t\tif ( s.async && s.timeout > 0 ) {\n-\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n-\t\t\t\t\tjqXHR.abort( \"timeout\" );\n-\t\t\t\t}, s.timeout );\n-\t\t\t}\n-\n-\t\t\ttry {\n-\t\t\t\tcompleted = false;\n-\t\t\t\ttransport.send( requestHeaders, done );\n-\t\t\t} catch ( e ) {\n-\n-\t\t\t\t// Rethrow post-completion exceptions\n-\t\t\t\tif ( completed ) {\n-\t\t\t\t\tthrow e;\n-\t\t\t\t}\n-\n-\t\t\t\t// Propagate others as results\n-\t\t\t\tdone( -1, e );\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Callback for when everything is done\n-\t\tfunction done( status, nativeStatusText, responses, headers ) {\n-\t\t\tvar isSuccess, success, error, response, modified,\n-\t\t\t\tstatusText = nativeStatusText;\n-\n-\t\t\t// Ignore repeat invocations\n-\t\t\tif ( completed ) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tcompleted = true;\n-\n-\t\t\t// Clear timeout if it exists\n-\t\t\tif ( timeoutTimer ) {\n-\t\t\t\twindow.clearTimeout( timeoutTimer );\n-\t\t\t}\n-\n-\t\t\t// Dereference transport for early garbage collection\n-\t\t\t// (no matter how long the jqXHR object will be used)\n-\t\t\ttransport = undefined;\n-\n-\t\t\t// Cache response headers\n-\t\t\tresponseHeadersString = headers || \"\";\n-\n-\t\t\t// Set readyState\n-\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n-\n-\t\t\t// Determine if successful\n-\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n-\n-\t\t\t// Get response data\n-\t\t\tif ( responses ) {\n-\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n-\t\t\t}\n-\n-\t\t\t// Use a noop converter for missing script but not if jsonp\n-\t\t\tif ( !isSuccess &&\n-\t\t\t\tjQuery.inArray( \"script\", s.dataTypes ) > -1 &&\n-\t\t\t\tjQuery.inArray( \"json\", s.dataTypes ) < 0 ) {\n-\t\t\t\ts.converters[ \"text script\" ] = function() {};\n-\t\t\t}\n-\n-\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n-\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n-\n-\t\t\t// If successful, handle type chaining\n-\t\t\tif ( isSuccess ) {\n-\n-\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n-\t\t\t\tif ( s.ifModified ) {\n-\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n-\t\t\t\t\tif ( modified ) {\n-\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n-\t\t\t\t\t}\n-\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n-\t\t\t\t\tif ( modified ) {\n-\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// if no content\n-\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n-\t\t\t\t\tstatusText = \"nocontent\";\n-\n-\t\t\t\t// if not modified\n-\t\t\t\t} else if ( status === 304 ) {\n-\t\t\t\t\tstatusText = \"notmodified\";\n-\n-\t\t\t\t// If we have data, let's convert it\n-\t\t\t\t} else {\n-\t\t\t\t\tstatusText = response.state;\n-\t\t\t\t\tsuccess = response.data;\n-\t\t\t\t\terror = response.error;\n-\t\t\t\t\tisSuccess = !error;\n-\t\t\t\t}\n-\t\t\t} else {\n-\n-\t\t\t\t// Extract error from statusText and normalize for non-aborts\n-\t\t\t\terror = statusText;\n-\t\t\t\tif ( status || !statusText ) {\n-\t\t\t\t\tstatusText = \"error\";\n-\t\t\t\t\tif ( status < 0 ) {\n-\t\t\t\t\t\tstatus = 0;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Set data for the fake xhr object\n-\t\t\tjqXHR.status = status;\n-\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n-\n-\t\t\t// Success/Error\n-\t\t\tif ( isSuccess ) {\n-\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n-\t\t\t} else {\n-\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n-\t\t\t}\n-\n-\t\t\t// Status-dependent callbacks\n-\t\t\tjqXHR.statusCode( statusCode );\n-\t\t\tstatusCode = undefined;\n-\n-\t\t\tif ( fireGlobals ) {\n-\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n-\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n-\t\t\t}\n-\n-\t\t\t// Complete\n-\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n-\n-\t\t\tif ( fireGlobals ) {\n-\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n-\n-\t\t\t\t// Handle the global AJAX counter\n-\t\t\t\tif ( !( --jQuery.active ) ) {\n-\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn jqXHR;\n-\t},\n-\n-\tgetJSON: function( url, data, callback ) {\n-\t\treturn jQuery.get( url, data, callback, \"json\" );\n-\t},\n-\n-\tgetScript: function( url, callback ) {\n-\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n-\t}\n-} );\n-\n-jQuery.each( [ \"get\", \"post\" ], function( _i, method ) {\n-\tjQuery[ method ] = function( url, data, callback, type ) {\n-\n-\t\t// Shift arguments if data argument was omitted\n-\t\tif ( isFunction( data ) ) {\n-\t\t\ttype = type || callback;\n-\t\t\tcallback = data;\n-\t\t\tdata = undefined;\n-\t\t}\n-\n-\t\t// The url can be an options object (which then must have .url)\n-\t\treturn jQuery.ajax( jQuery.extend( {\n-\t\t\turl: url,\n-\t\t\ttype: method,\n-\t\t\tdataType: type,\n-\t\t\tdata: data,\n-\t\t\tsuccess: callback\n-\t\t}, jQuery.isPlainObject( url ) && url ) );\n-\t};\n-} );\n-\n-jQuery.ajaxPrefilter( function( s ) {\n-\tvar i;\n-\tfor ( i in s.headers ) {\n-\t\tif ( i.toLowerCase() === \"content-type\" ) {\n-\t\t\ts.contentType = s.headers[ i ] || \"\";\n-\t\t}\n-\t}\n-} );\n-\n-\n-jQuery._evalUrl = function( url, options, doc ) {\n-\treturn jQuery.ajax( {\n-\t\turl: url,\n-\n-\t\t// Make this explicit, since user can override this through ajaxSetup (trac-11264)\n-\t\ttype: \"GET\",\n-\t\tdataType: \"script\",\n-\t\tcache: true,\n-\t\tasync: false,\n-\t\tglobal: false,\n-\n-\t\t// Only evaluate the response if it is successful (gh-4126)\n-\t\t// dataFilter is not invoked for failure responses, so using it instead\n-\t\t// of the default converter is kludgy but it works.\n-\t\tconverters: {\n-\t\t\t\"text script\": function() {}\n-\t\t},\n-\t\tdataFilter: function( response ) {\n-\t\t\tjQuery.globalEval( response, options, doc );\n-\t\t}\n-\t} );\n-};\n-\n-\n-jQuery.fn.extend( {\n-\twrapAll: function( html ) {\n-\t\tvar wrap;\n-\n-\t\tif ( this[ 0 ] ) {\n-\t\t\tif ( isFunction( html ) ) {\n-\t\t\t\thtml = html.call( this[ 0 ] );\n-\t\t\t}\n-\n-\t\t\t// The elements to wrap the target around\n-\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n-\n-\t\t\tif ( this[ 0 ].parentNode ) {\n-\t\t\t\twrap.insertBefore( this[ 0 ] );\n-\t\t\t}\n-\n-\t\t\twrap.map( function() {\n-\t\t\t\tvar elem = this;\n-\n-\t\t\t\twhile ( elem.firstElementChild ) {\n-\t\t\t\t\telem = elem.firstElementChild;\n-\t\t\t\t}\n-\n-\t\t\t\treturn elem;\n-\t\t\t} ).append( this );\n-\t\t}\n-\n-\t\treturn this;\n-\t},\n-\n-\twrapInner: function( html ) {\n-\t\tif ( isFunction( html ) ) {\n-\t\t\treturn this.each( function( i ) {\n-\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n-\t\t\t} );\n-\t\t}\n-\n-\t\treturn this.each( function() {\n-\t\t\tvar self = jQuery( this ),\n-\t\t\t\tcontents = self.contents();\n-\n-\t\t\tif ( contents.length ) {\n-\t\t\t\tcontents.wrapAll( html );\n-\n-\t\t\t} else {\n-\t\t\t\tself.append( html );\n-\t\t\t}\n-\t\t} );\n-\t},\n-\n-\twrap: function( html ) {\n-\t\tvar htmlIsFunction = isFunction( html );\n-\n-\t\treturn this.each( function( i ) {\n-\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n-\t\t} );\n-\t},\n-\n-\tunwrap: function( selector ) {\n-\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n-\t\t\tjQuery( this ).replaceWith( this.childNodes );\n-\t\t} );\n-\t\treturn this;\n-\t}\n-} );\n-\n-\n-jQuery.expr.pseudos.hidden = function( elem ) {\n-\treturn !jQuery.expr.pseudos.visible( elem );\n-};\n-jQuery.expr.pseudos.visible = function( elem ) {\n-\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n-};\n-\n-\n-\n-\n-jQuery.ajaxSettings.xhr = function() {\n-\ttry {\n-\t\treturn new window.XMLHttpRequest();\n-\t} catch ( e ) {}\n-};\n-\n-var xhrSuccessStatus = {\n-\n-\t\t// File protocol always yields status code 0, assume 200\n-\t\t0: 200,\n-\n-\t\t// Support: IE <=9 only\n-\t\t// trac-1450: sometimes IE returns 1223 when it should be 204\n-\t\t1223: 204\n-\t},\n-\txhrSupported = jQuery.ajaxSettings.xhr();\n-\n-support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n-support.ajax = xhrSupported = !!xhrSupported;\n-\n-jQuery.ajaxTransport( function( options ) {\n-\tvar callback, errorCallback;\n-\n-\t// Cross domain only allowed if supported through XMLHttpRequest\n-\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n-\t\treturn {\n-\t\t\tsend: function( headers, complete ) {\n-\t\t\t\tvar i,\n-\t\t\t\t\txhr = options.xhr();\n-\n-\t\t\t\txhr.open(\n-\t\t\t\t\toptions.type,\n-\t\t\t\t\toptions.url,\n-\t\t\t\t\toptions.async,\n-\t\t\t\t\toptions.username,\n-\t\t\t\t\toptions.password\n-\t\t\t\t);\n-\n-\t\t\t\t// Apply custom fields if provided\n-\t\t\t\tif ( options.xhrFields ) {\n-\t\t\t\t\tfor ( i in options.xhrFields ) {\n-\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// Override mime type if needed\n-\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n-\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n-\t\t\t\t}\n-\n-\t\t\t\t// X-Requested-With header\n-\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n-\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n-\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n-\t\t\t\t// For same-domain requests, won't change header if already provided.\n-\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n-\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n-\t\t\t\t}\n-\n-\t\t\t\t// Set headers\n-\t\t\t\tfor ( i in headers ) {\n-\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n-\t\t\t\t}\n-\n-\t\t\t\t// Callback\n-\t\t\t\tcallback = function( type ) {\n-\t\t\t\t\treturn function() {\n-\t\t\t\t\t\tif ( callback ) {\n-\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n-\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n-\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n-\n-\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n-\t\t\t\t\t\t\t\txhr.abort();\n-\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n-\n-\t\t\t\t\t\t\t\t// Support: IE <=9 only\n-\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n-\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n-\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n-\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tcomplete(\n-\n-\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see trac-8605, trac-14207\n-\t\t\t\t\t\t\t\t\t\txhr.status,\n-\t\t\t\t\t\t\t\t\t\txhr.statusText\n-\t\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tcomplete(\n-\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n-\t\t\t\t\t\t\t\t\txhr.statusText,\n-\n-\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n-\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n-\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n-\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n-\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n-\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n-\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n-\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n-\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t};\n-\t\t\t\t};\n-\n-\t\t\t\t// Listen to events\n-\t\t\t\txhr.onload = callback();\n-\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n-\n-\t\t\t\t// Support: IE 9 only\n-\t\t\t\t// Use onreadystatechange to replace onabort\n-\t\t\t\t// to handle uncaught aborts\n-\t\t\t\tif ( xhr.onabort !== undefined ) {\n-\t\t\t\t\txhr.onabort = errorCallback;\n-\t\t\t\t} else {\n-\t\t\t\t\txhr.onreadystatechange = function() {\n-\n-\t\t\t\t\t\t// Check readyState before timeout as it changes\n-\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n-\n-\t\t\t\t\t\t\t// Allow onerror to be called first,\n-\t\t\t\t\t\t\t// but that will not handle a native abort\n-\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n-\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n-\t\t\t\t\t\t\twindow.setTimeout( function() {\n-\t\t\t\t\t\t\t\tif ( callback ) {\n-\t\t\t\t\t\t\t\t\terrorCallback();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t};\n-\t\t\t\t}\n-\n-\t\t\t\t// Create the abort callback\n-\t\t\t\tcallback = callback( \"abort\" );\n-\n-\t\t\t\ttry {\n-\n-\t\t\t\t\t// Do send the request (this may raise an exception)\n-\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n-\t\t\t\t} catch ( e ) {\n-\n-\t\t\t\t\t// trac-14683: Only rethrow if this hasn't been notified as an error yet\n-\t\t\t\t\tif ( callback ) {\n-\t\t\t\t\t\tthrow e;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t},\n-\n-\t\t\tabort: function() {\n-\t\t\t\tif ( callback ) {\n-\t\t\t\t\tcallback();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t};\n-\t}\n-} );\n-\n-\n-\n-\n-// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n-jQuery.ajaxPrefilter( function( s ) {\n-\tif ( s.crossDomain ) {\n-\t\ts.contents.script = false;\n-\t}\n-} );\n-\n-// Install script dataType\n-jQuery.ajaxSetup( {\n-\taccepts: {\n-\t\tscript: \"text/javascript, application/javascript, \" +\n-\t\t\t\"application/ecmascript, application/x-ecmascript\"\n-\t},\n-\tcontents: {\n-\t\tscript: /\\b(?:java|ecma)script\\b/\n-\t},\n-\tconverters: {\n-\t\t\"text script\": function( text ) {\n-\t\t\tjQuery.globalEval( text );\n-\t\t\treturn text;\n-\t\t}\n-\t}\n-} );\n-\n-// Handle cache's special case and crossDomain\n-jQuery.ajaxPrefilter( \"script\", function( s ) {\n-\tif ( s.cache === undefined ) {\n-\t\ts.cache = false;\n-\t}\n-\tif ( s.crossDomain ) {\n-\t\ts.type = \"GET\";\n-\t}\n-} );\n-\n-// Bind script tag hack transport\n-jQuery.ajaxTransport( \"script\", function( s ) {\n-\n-\t// This transport only deals with cross domain or forced-by-attrs requests\n-\tif ( s.crossDomain || s.scriptAttrs ) {\n-\t\tvar script, callback;\n-\t\treturn {\n-\t\t\tsend: function( _, complete ) {\n-\t\t\t\tscript = jQuery( \"<script>\" )\n-\t\t\t\t\t.attr( s.scriptAttrs || {} )\n-\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n-\t\t\t\t\t.on( \"load error\", callback = function( evt ) {\n-\t\t\t\t\t\tscript.remove();\n-\t\t\t\t\t\tcallback = null;\n-\t\t\t\t\t\tif ( evt ) {\n-\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} );\n-\n-\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n-\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n-\t\t\t},\n-\t\t\tabort: function() {\n-\t\t\t\tif ( callback ) {\n-\t\t\t\t\tcallback();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t};\n-\t}\n-} );\n-\n-\n-\n-\n-var oldCallbacks = [],\n-\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n-\n-// Default jsonp settings\n-jQuery.ajaxSetup( {\n-\tjsonp: \"callback\",\n-\tjsonpCallback: function() {\n-\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce.guid++ ) );\n-\t\tthis[ callback ] = true;\n-\t\treturn callback;\n-\t}\n-} );\n-\n-// Detect, normalize options and install callbacks for jsonp requests\n-jQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n-\n-\tvar callbackName, overwritten, responseContainer,\n-\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n-\t\t\t\"url\" :\n-\t\t\ttypeof s.data === \"string\" &&\n-\t\t\t\t( s.contentType || \"\" )\n-\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n-\t\t\t\trjsonp.test( s.data ) && \"data\"\n-\t\t);\n-\n-\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n-\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n-\n-\t\t// Get callback name, remembering preexisting value associated with it\n-\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n-\t\t\ts.jsonpCallback() :\n-\t\t\ts.jsonpCallback;\n-\n-\t\t// Insert callback into url or form data\n-\t\tif ( jsonProp ) {\n-\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n-\t\t} else if ( s.jsonp !== false ) {\n-\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n-\t\t}\n-\n-\t\t// Use data converter to retrieve json after script execution\n-\t\ts.converters[ \"script json\" ] = function() {\n-\t\t\tif ( !responseContainer ) {\n-\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n-\t\t\t}\n-\t\t\treturn responseContainer[ 0 ];\n-\t\t};\n-\n-\t\t// Force json dataType\n-\t\ts.dataTypes[ 0 ] = \"json\";\n-\n-\t\t// Install callback\n-\t\toverwritten = window[ callbackName ];\n-\t\twindow[ callbackName ] = function() {\n-\t\t\tresponseContainer = arguments;\n-\t\t};\n-\n-\t\t// Clean-up function (fires after converters)\n-\t\tjqXHR.always( function() {\n-\n-\t\t\t// If previous value didn't exist - remove it\n-\t\t\tif ( overwritten === undefined ) {\n-\t\t\t\tjQuery( window ).removeProp( callbackName );\n-\n-\t\t\t// Otherwise restore preexisting value\n-\t\t\t} else {\n-\t\t\t\twindow[ callbackName ] = overwritten;\n-\t\t\t}\n-\n-\t\t\t// Save back as free\n-\t\t\tif ( s[ callbackName ] ) {\n-\n-\t\t\t\t// Make sure that re-using the options doesn't screw things around\n-\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n-\n-\t\t\t\t// Save the callback name for future use\n-\t\t\t\toldCallbacks.push( callbackName );\n-\t\t\t}\n-\n-\t\t\t// Call if it was a function and we have a response\n-\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n-\t\t\t\toverwritten( responseContainer[ 0 ] );\n-\t\t\t}\n-\n-\t\t\tresponseContainer = overwritten = undefined;\n-\t\t} );\n-\n-\t\t// Delegate to script\n-\t\treturn \"script\";\n-\t}\n-} );\n-\n-\n-\n-\n-// Support: Safari 8 only\n-// In Safari 8 documents created via document.implementation.createHTMLDocument\n-// collapse sibling forms: the second one becomes a child of the first one.\n-// Because of that, this security measure has to be disabled in Safari 8.\n-// https://bugs.webkit.org/show_bug.cgi?id=137337\n-support.createHTMLDocument = ( function() {\n-\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n-\tbody.innerHTML = \"<form></form><form></form>\";\n-\treturn body.childNodes.length === 2;\n-} )();\n-\n-\n-// Argument \"data\" should be string of html\n-// context (optional): If specified, the fragment will be created in this context,\n-// defaults to document\n-// keepScripts (optional): If true, will include scripts passed in the html string\n-jQuery.parseHTML = function( data, context, keepScripts ) {\n-\tif ( typeof data !== \"string\" ) {\n-\t\treturn [];\n-\t}\n-\tif ( typeof context === \"boolean\" ) {\n-\t\tkeepScripts = context;\n-\t\tcontext = false;\n-\t}\n-\n-\tvar base, parsed, scripts;\n-\n-\tif ( !context ) {\n-\n-\t\t// Stop scripts or inline event handlers from being executed immediately\n-\t\t// by using document.implementation\n-\t\tif ( support.createHTMLDocument ) {\n-\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n-\n-\t\t\t// Set the base href for the created document\n-\t\t\t// so any parsed elements with URLs\n-\t\t\t// are based on the document's URL (gh-2965)\n-\t\t\tbase = context.createElement( \"base\" );\n-\t\t\tbase.href = document.location.href;\n-\t\t\tcontext.head.appendChild( base );\n-\t\t} else {\n-\t\t\tcontext = document;\n-\t\t}\n-\t}\n-\n-\tparsed = rsingleTag.exec( data );\n-\tscripts = !keepScripts && [];\n-\n-\t// Single tag\n-\tif ( parsed ) {\n-\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n-\t}\n-\n-\tparsed = buildFragment( [ data ], context, scripts );\n-\n-\tif ( scripts && scripts.length ) {\n-\t\tjQuery( scripts ).remove();\n-\t}\n-\n-\treturn jQuery.merge( [], parsed.childNodes );\n-};\n-\n-\n-/**\n- * Load a url into a page\n- */\n-jQuery.fn.load = function( url, params, callback ) {\n-\tvar selector, type, response,\n-\t\tself = this,\n-\t\toff = url.indexOf( \" \" );\n-\n-\tif ( off > -1 ) {\n-\t\tselector = stripAndCollapse( url.slice( off ) );\n-\t\turl = url.slice( 0, off );\n-\t}\n-\n-\t// If it's a function\n-\tif ( isFunction( params ) ) {\n-\n-\t\t// We assume that it's the callback\n-\t\tcallback = params;\n-\t\tparams = undefined;\n-\n-\t// Otherwise, build a param string\n-\t} else if ( params && typeof params === \"object\" ) {\n-\t\ttype = \"POST\";\n-\t}\n-\n-\t// If we have elements to modify, make the request\n-\tif ( self.length > 0 ) {\n-\t\tjQuery.ajax( {\n-\t\t\turl: url,\n-\n-\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n-\t\t\t// Make value of this field explicit since\n-\t\t\t// user can override it through ajaxSetup method\n-\t\t\ttype: type || \"GET\",\n-\t\t\tdataType: \"html\",\n-\t\t\tdata: params\n-\t\t} ).done( function( responseText ) {\n-\n-\t\t\t// Save response for use in complete callback\n-\t\t\tresponse = arguments;\n-\n-\t\t\tself.html( selector ?\n-\n-\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n-\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n-\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n-\n-\t\t\t\t// Otherwise use the full result\n-\t\t\t\tresponseText );\n-\n-\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n-\t\t// but they are ignored because response was set above.\n-\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n-\t\t} ).always( callback && function( jqXHR, status ) {\n-\t\t\tself.each( function() {\n-\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n-\t\t\t} );\n-\t\t} );\n-\t}\n-\n-\treturn this;\n-};\n-\n-\n-\n-\n-jQuery.expr.pseudos.animated = function( elem ) {\n-\treturn jQuery.grep( jQuery.timers, function( fn ) {\n-\t\treturn elem === fn.elem;\n-\t} ).length;\n-};\n-\n-\n-\n-\n-jQuery.offset = {\n-\tsetOffset: function( elem, options, i ) {\n-\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n-\t\t\tposition = jQuery.css( elem, \"position\" ),\n-\t\t\tcurElem = jQuery( elem ),\n-\t\t\tprops = {};\n-\n-\t\t// Set position first, in-case top/left are set even on static elem\n-\t\tif ( position === \"static\" ) {\n-\t\t\telem.style.position = \"relative\";\n-\t\t}\n-\n-\t\tcurOffset = curElem.offset();\n-\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n-\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n-\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n-\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n-\n-\t\t// Need to be able to calculate position if either\n-\t\t// top or left is auto and position is either absolute or fixed\n-\t\tif ( calculatePosition ) {\n-\t\t\tcurPosition = curElem.position();\n-\t\t\tcurTop = curPosition.top;\n-\t\t\tcurLeft = curPosition.left;\n-\n-\t\t} else {\n-\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n-\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n-\t\t}\n-\n-\t\tif ( isFunction( options ) ) {\n-\n-\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n-\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n-\t\t}\n-\n-\t\tif ( options.top != null ) {\n-\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n-\t\t}\n-\t\tif ( options.left != null ) {\n-\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n-\t\t}\n-\n-\t\tif ( \"using\" in options ) {\n-\t\t\toptions.using.call( elem, props );\n-\n-\t\t} else {\n-\t\t\tcurElem.css( props );\n-\t\t}\n-\t}\n-};\n-\n-jQuery.fn.extend( {\n-\n-\t// offset() relates an element's border box to the document origin\n-\toffset: function( options ) {\n-\n-\t\t// Preserve chaining for setter\n-\t\tif ( arguments.length ) {\n-\t\t\treturn options === undefined ?\n-\t\t\t\tthis :\n-\t\t\t\tthis.each( function( i ) {\n-\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n-\t\t\t\t} );\n-\t\t}\n-\n-\t\tvar rect, win,\n-\t\t\telem = this[ 0 ];\n-\n-\t\tif ( !elem ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n-\t\t// Support: IE <=11 only\n-\t\t// Running getBoundingClientRect on a\n-\t\t// disconnected node in IE throws an error\n-\t\tif ( !elem.getClientRects().length ) {\n-\t\t\treturn { top: 0, left: 0 };\n-\t\t}\n-\n-\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n-\t\trect = elem.getBoundingClientRect();\n-\t\twin = elem.ownerDocument.defaultView;\n-\t\treturn {\n-\t\t\ttop: rect.top + win.pageYOffset,\n-\t\t\tleft: rect.left + win.pageXOffset\n-\t\t};\n-\t},\n-\n-\t// position() relates an element's margin box to its offset parent's padding box\n-\t// This corresponds to the behavior of CSS absolute positioning\n-\tposition: function() {\n-\t\tif ( !this[ 0 ] ) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tvar offsetParent, offset, doc,\n-\t\t\telem = this[ 0 ],\n-\t\t\tparentOffset = { top: 0, left: 0 };\n-\n-\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n-\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n-\n-\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n-\t\t\toffset = elem.getBoundingClientRect();\n-\n-\t\t} else {\n-\t\t\toffset = this.offset();\n-\n-\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n-\t\t\t// when a statically positioned element is identified\n-\t\t\tdoc = elem.ownerDocument;\n-\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n-\t\t\twhile ( offsetParent &&\n-\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n-\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n-\n-\t\t\t\toffsetParent = offsetParent.parentNode;\n-\t\t\t}\n-\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n-\n-\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n-\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n-\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n-\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Subtract parent offsets and element margins\n-\t\treturn {\n-\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n-\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n-\t\t};\n-\t},\n-\n-\t// This method will return documentElement in the following cases:\n-\t// 1) For the element inside the iframe without offsetParent, this method will return\n-\t//    documentElement of the parent window\n-\t// 2) For the hidden or detached element\n-\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n-\t//\n-\t// but those exceptions were never presented as a real life use-cases\n-\t// and might be considered as more preferable results.\n-\t//\n-\t// This logic, however, is not guaranteed and can change at any point in the future\n-\toffsetParent: function() {\n-\t\treturn this.map( function() {\n-\t\t\tvar offsetParent = this.offsetParent;\n-\n-\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n-\t\t\t\toffsetParent = offsetParent.offsetParent;\n-\t\t\t}\n-\n-\t\t\treturn offsetParent || documentElement;\n-\t\t} );\n-\t}\n-} );\n-\n-// Create scrollLeft and scrollTop methods\n-jQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n-\tvar top = \"pageYOffset\" === prop;\n-\n-\tjQuery.fn[ method ] = function( val ) {\n-\t\treturn access( this, function( elem, method, val ) {\n-\n-\t\t\t// Coalesce documents and windows\n-\t\t\tvar win;\n-\t\t\tif ( isWindow( elem ) ) {\n-\t\t\t\twin = elem;\n-\t\t\t} else if ( elem.nodeType === 9 ) {\n-\t\t\t\twin = elem.defaultView;\n-\t\t\t}\n-\n-\t\t\tif ( val === undefined ) {\n-\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n-\t\t\t}\n-\n-\t\t\tif ( win ) {\n-\t\t\t\twin.scrollTo(\n-\t\t\t\t\t!top ? val : win.pageXOffset,\n-\t\t\t\t\ttop ? val : win.pageYOffset\n-\t\t\t\t);\n-\n-\t\t\t} else {\n-\t\t\t\telem[ method ] = val;\n-\t\t\t}\n-\t\t}, method, val, arguments.length );\n-\t};\n-} );\n-\n-// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n-// Add the top/left cssHooks using jQuery.fn.position\n-// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n-// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n-// getComputedStyle returns percent when specified for top/left/bottom/right;\n-// rather than make the css module depend on the offset module, just check for it here\n-jQuery.each( [ \"top\", \"left\" ], function( _i, prop ) {\n-\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n-\t\tfunction( elem, computed ) {\n-\t\t\tif ( computed ) {\n-\t\t\t\tcomputed = curCSS( elem, prop );\n-\n-\t\t\t\t// If curCSS returns percentage, fallback to offset\n-\t\t\t\treturn rnumnonpx.test( computed ) ?\n-\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n-\t\t\t\t\tcomputed;\n-\t\t\t}\n-\t\t}\n-\t);\n-} );\n-\n-\n-// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n-jQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n-\tjQuery.each( {\n-\t\tpadding: \"inner\" + name,\n-\t\tcontent: type,\n-\t\t\"\": \"outer\" + name\n-\t}, function( defaultExtra, funcName ) {\n-\n-\t\t// Margin is only for outerHeight, outerWidth\n-\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n-\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n-\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n-\n-\t\t\treturn access( this, function( elem, type, value ) {\n-\t\t\t\tvar doc;\n-\n-\t\t\t\tif ( isWindow( elem ) ) {\n-\n-\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n-\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n-\t\t\t\t\t\telem[ \"inner\" + name ] :\n-\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n-\t\t\t\t}\n-\n-\t\t\t\t// Get document width or height\n-\t\t\t\tif ( elem.nodeType === 9 ) {\n-\t\t\t\t\tdoc = elem.documentElement;\n-\n-\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n-\t\t\t\t\t// whichever is greatest\n-\t\t\t\t\treturn Math.max(\n-\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n-\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n-\t\t\t\t\t\tdoc[ \"client\" + name ]\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\n-\t\t\t\treturn value === undefined ?\n-\n-\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n-\t\t\t\t\tjQuery.css( elem, type, extra ) :\n-\n-\t\t\t\t\t// Set width or height on the element\n-\t\t\t\t\tjQuery.style( elem, type, value, extra );\n-\t\t\t}, type, chainable ? margin : undefined, chainable );\n-\t\t};\n-\t} );\n-} );\n-\n-\n-jQuery.each( [\n-\t\"ajaxStart\",\n-\t\"ajaxStop\",\n-\t\"ajaxComplete\",\n-\t\"ajaxError\",\n-\t\"ajaxSuccess\",\n-\t\"ajaxSend\"\n-], function( _i, type ) {\n-\tjQuery.fn[ type ] = function( fn ) {\n-\t\treturn this.on( type, fn );\n-\t};\n-} );\n-\n-\n-\n-\n-jQuery.fn.extend( {\n-\n-\tbind: function( types, data, fn ) {\n-\t\treturn this.on( types, null, data, fn );\n-\t},\n-\tunbind: function( types, fn ) {\n-\t\treturn this.off( types, null, fn );\n-\t},\n-\n-\tdelegate: function( selector, types, data, fn ) {\n-\t\treturn this.on( types, selector, data, fn );\n-\t},\n-\tundelegate: function( selector, types, fn ) {\n-\n-\t\t// ( namespace ) or ( selector, types [, fn] )\n-\t\treturn arguments.length === 1 ?\n-\t\t\tthis.off( selector, \"**\" ) :\n-\t\t\tthis.off( types, selector || \"**\", fn );\n-\t},\n-\n-\thover: function( fnOver, fnOut ) {\n-\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n-\t}\n-} );\n-\n-jQuery.each(\n-\t( \"blur focus focusin focusout resize scroll click dblclick \" +\n-\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n-\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n-\tfunction( _i, name ) {\n-\n-\t\t// Handle event binding\n-\t\tjQuery.fn[ name ] = function( data, fn ) {\n-\t\t\treturn arguments.length > 0 ?\n-\t\t\t\tthis.on( name, null, data, fn ) :\n-\t\t\t\tthis.trigger( name );\n-\t\t};\n-\t}\n-);\n-\n-\n-\n-\n-// Support: Android <=4.0 only\n-// Make sure we trim BOM and NBSP\n-// Require that the \"whitespace run\" starts from a non-whitespace\n-// to avoid O(N^2) behavior when the engine would try matching \"\\s+$\" at each space position.\n-var rtrim = /^[\\s\\uFEFF\\xA0]+|([^\\s\\uFEFF\\xA0])[\\s\\uFEFF\\xA0]+$/g;\n-\n-// Bind a function to a context, optionally partially applying any\n-// arguments.\n-// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n-// However, it is not slated for removal any time soon\n-jQuery.proxy = function( fn, context ) {\n-\tvar tmp, args, proxy;\n-\n-\tif ( typeof context === \"string\" ) {\n-\t\ttmp = fn[ context ];\n-\t\tcontext = fn;\n-\t\tfn = tmp;\n-\t}\n-\n-\t// Quick check to determine if target is callable, in the spec\n-\t// this throws a TypeError, but we will just return undefined.\n-\tif ( !isFunction( fn ) ) {\n-\t\treturn undefined;\n-\t}\n-\n-\t// Simulated bind\n-\targs = slice.call( arguments, 2 );\n-\tproxy = function() {\n-\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n-\t};\n-\n-\t// Set the guid of unique handler to the same of original handler, so it can be removed\n-\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n-\n-\treturn proxy;\n-};\n-\n-jQuery.holdReady = function( hold ) {\n-\tif ( hold ) {\n-\t\tjQuery.readyWait++;\n-\t} else {\n-\t\tjQuery.ready( true );\n-\t}\n-};\n-jQuery.isArray = Array.isArray;\n-jQuery.parseJSON = JSON.parse;\n-jQuery.nodeName = nodeName;\n-jQuery.isFunction = isFunction;\n-jQuery.isWindow = isWindow;\n-jQuery.camelCase = camelCase;\n-jQuery.type = toType;\n-\n-jQuery.now = Date.now;\n-\n-jQuery.isNumeric = function( obj ) {\n-\n-\t// As of jQuery 3.0, isNumeric is limited to\n-\t// strings and numbers (primitives or objects)\n-\t// that can be coerced to finite numbers (gh-2662)\n-\tvar type = jQuery.type( obj );\n-\treturn ( type === \"number\" || type === \"string\" ) &&\n-\n-\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n-\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n-\t\t// subtraction forces infinities to NaN\n-\t\t!isNaN( obj - parseFloat( obj ) );\n-};\n-\n-jQuery.trim = function( text ) {\n-\treturn text == null ?\n-\t\t\"\" :\n-\t\t( text + \"\" ).replace( rtrim, \"$1\" );\n-};\n-\n-\n-\n-// Register as a named AMD module, since jQuery can be concatenated with other\n-// files that may use define, but not via a proper concatenation script that\n-// understands anonymous AMD modules. A named AMD is safest and most robust\n-// way to register. Lowercase jquery is used because AMD module names are\n-// derived from file names, and jQuery is normally delivered in a lowercase\n-// file name. Do this after creating the global so that if an AMD module wants\n-// to call noConflict to hide this version of jQuery, it will work.\n-\n-// Note that for maximum portability, libraries that are not jQuery should\n-// declare themselves as anonymous modules, and avoid setting a global if an\n-// AMD loader is present. jQuery is a special case. For more information, see\n-// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n-\n-if ( typeof define === \"function\" && define.amd ) {\n-\tdefine( \"jquery\", [], function() {\n-\t\treturn jQuery;\n-\t} );\n-}\n-\n-\n-\n-\n-var\n-\n-\t// Map over jQuery in case of overwrite\n-\t_jQuery = window.jQuery,\n-\n-\t// Map over the $ in case of overwrite\n-\t_$ = window.$;\n-\n-jQuery.noConflict = function( deep ) {\n-\tif ( window.$ === jQuery ) {\n-\t\twindow.$ = _$;\n-\t}\n-\n-\tif ( deep && window.jQuery === jQuery ) {\n-\t\twindow.jQuery = _jQuery;\n-\t}\n-\n-\treturn jQuery;\n-};\n-\n-// Expose jQuery and $ identifiers, even in AMD\n-// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)\n-// and CommonJS for browser emulators (trac-13566)\n-if ( typeof noGlobal === \"undefined\" ) {\n-\twindow.jQuery = window.$ = jQuery;\n-}\n-\n-\n-\n-\n-return jQuery;\n-} );\n+    function Kc(a) {\n+        return o.isWindow(a) ? a : 9 === a.nodeType && a.defaultView\n+    }\n+    o.offset = {\n+        setOffset: function(a, b, c) {\n+            var d, e, f, g, h, i, j, k = o.css(a, \"position\"),\n+                l = o(a),\n+                m = {};\n+            \"static\" === k && (a.style.position = \"relative\"), h = l.offset(), f = o.css(a, \"top\"), i = o.css(a, \"left\"), j = (\"absolute\" === k || \"fixed\" === k) && (f + i).indexOf(\"auto\") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), o.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), \"using\" in b ? b.using.call(a, m) : l.css(m)\n+        }\n+    }, o.fn.extend({\n+        offset: function(a) {\n+            if (arguments.length) return void 0 === a ? this : this.each(function(b) {\n+                o.offset.setOffset(this, a, b)\n+            });\n+            var b, c, d = this[0],\n+                e = {\n+                    top: 0,\n+                    left: 0\n+                },\n+                f = d && d.ownerDocument;\n+            if (f) return b = f.documentElement, o.contains(b, d) ? (typeof d.getBoundingClientRect !== U && (e = d.getBoundingClientRect()), c = Kc(f), {\n+                top: e.top + c.pageYOffset - b.clientTop,\n+                left: e.left + c.pageXOffset - b.clientLeft\n+            }) : e\n+        },\n+        position: function() {\n+            if (this[0]) {\n+                var a, b, c = this[0],\n+                    d = {\n+                        top: 0,\n+                        left: 0\n+                    };\n+                return \"fixed\" === o.css(c, \"position\") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), o.nodeName(a[0], \"html\") || (d = a.offset()), d.top += o.css(a[0], \"borderTopWidth\", !0), d.left += o.css(a[0], \"borderLeftWidth\", !0)), {\n+                    top: b.top - d.top - o.css(c, \"marginTop\", !0),\n+                    left: b.left - d.left - o.css(c, \"marginLeft\", !0)\n+                }\n+            }\n+        },\n+        offsetParent: function() {\n+            return this.map(function() {\n+                var a = this.offsetParent || Jc;\n+                while (a && !o.nodeName(a, \"html\") && \"static\" === o.css(a, \"position\")) a = a.offsetParent;\n+                return a || Jc\n+            })\n+        }\n+    }), o.each({\n+        scrollLeft: \"pageXOffset\",\n+        scrollTop: \"pageYOffset\"\n+    }, function(b, c) {\n+        var d = \"pageYOffset\" === c;\n+        o.fn[b] = function(e) {\n+            return J(this, function(b, e, f) {\n+                var g = Kc(b);\n+                return void 0 === f ? g ? g[c] : b[e] : void(g ? g.scrollTo(d ? a.pageXOffset : f, d ? f : a.pageYOffset) : b[e] = f)\n+            }, b, e, arguments.length, null)\n+        }\n+    }), o.each([\"top\", \"left\"], function(a, b) {\n+        o.cssHooks[b] = yb(l.pixelPosition, function(a, c) {\n+            return c ? (c = xb(a, b), vb.test(c) ? o(a).position()[b] + \"px\" : c) : void 0\n+        })\n+    }), o.each({\n+        Height: \"height\",\n+        Width: \"width\"\n+    }, function(a, b) {\n+        o.each({\n+            padding: \"inner\" + a,\n+            content: b,\n+            \"\": \"outer\" + a\n+        }, function(c, d) {\n+            o.fn[d] = function(d, e) {\n+                var f = arguments.length && (c || \"boolean\" != typeof d),\n+                    g = c || (d === !0 || e === !0 ? \"margin\" : \"border\");\n+                return J(this, function(b, c, d) {\n+                    var e;\n+                    return o.isWindow(b) ? b.document.documentElement[\"client\" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body[\"scroll\" + a], e[\"scroll\" + a], b.body[\"offset\" + a], e[\"offset\" + a], e[\"client\" + a])) : void 0 === d ? o.css(b, c, g) : o.style(b, c, d, g)\n+                }, b, f ? d : void 0, f, null)\n+            }\n+        })\n+    }), o.fn.size = function() {\n+        return this.length\n+    }, o.fn.andSelf = o.fn.addBack, \"function\" == typeof define && define.amd && define(\"jquery\", [], function() {\n+        return o\n+    });\n+    var Lc = a.jQuery,\n+        Mc = a.$;\n+    return o.noConflict = function(b) {\n+        return a.$ === o && (a.$ = Mc), b && a.jQuery === o && (a.jQuery = Lc), o\n+    }, typeof b === U && (a.jQuery = a.$ = o), o\n+});\n\\ No newline at end of file\n"
                }
            ],
            "date": 1674934780481,
            "name": "Commit-0",
            "content": "/*! jQuery v2.1.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */ ! function(a, b) {\n    \"object\" == typeof module && \"object\" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {\n        if (!a.document) throw new Error(\"jQuery requires a window with a document\");\n        return b(a)\n    } : b(a)\n}(\"undefined\" != typeof window ? window : this, function(a, b) {\n    var c = [],\n        d = c.slice,\n        e = c.concat,\n        f = c.push,\n        g = c.indexOf,\n        h = {},\n        i = h.toString,\n        j = h.hasOwnProperty,\n        k = \"\".trim,\n        l = {},\n        m = a.document,\n        n = \"2.1.0\",\n        o = function(a, b) {\n            return new o.fn.init(a, b)\n        },\n        p = /^-ms-/,\n        q = /-([\\da-z])/gi,\n        r = function(a, b) {\n            return b.toUpperCase()\n        };\n    o.fn = o.prototype = {\n        jquery: n,\n        constructor: o,\n        selector: \"\",\n        length: 0,\n        toArray: function() {\n            return d.call(this)\n        },\n        get: function(a) {\n            return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this)\n        },\n        pushStack: function(a) {\n            var b = o.merge(this.constructor(), a);\n            return b.prevObject = this, b.context = this.context, b\n        },\n        each: function(a, b) {\n            return o.each(this, a, b)\n        },\n        map: function(a) {\n            return this.pushStack(o.map(this, function(b, c) {\n                return a.call(b, c, b)\n            }))\n        },\n        slice: function() {\n            return this.pushStack(d.apply(this, arguments))\n        },\n        first: function() {\n            return this.eq(0)\n        },\n        last: function() {\n            return this.eq(-1)\n        },\n        eq: function(a) {\n            var b = this.length,\n                c = +a + (0 > a ? b : 0);\n            return this.pushStack(c >= 0 && b > c ? [this[c]] : [])\n        },\n        end: function() {\n            return this.prevObject || this.constructor(null)\n        },\n        push: f,\n        sort: c.sort,\n        splice: c.splice\n    }, o.extend = o.fn.extend = function() {\n        var a, b, c, d, e, f, g = arguments[0] || {},\n            h = 1,\n            i = arguments.length,\n            j = !1;\n        for (\"boolean\" == typeof g && (j = g, g = arguments[h] || {}, h++), \"object\" == typeof g || o.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)\n            if (null != (a = arguments[h]))\n                for (b in a) c = g[b], d = a[b], g !== d && (j && d && (o.isPlainObject(d) || (e = o.isArray(d))) ? (e ? (e = !1, f = c && o.isArray(c) ? c : []) : f = c && o.isPlainObject(c) ? c : {}, g[b] = o.extend(j, f, d)) : void 0 !== d && (g[b] = d));\n        return g\n    }, o.extend({\n        expando: \"jQuery\" + (n + Math.random()).replace(/\\D/g, \"\"),\n        isReady: !0,\n        error: function(a) {\n            throw new Error(a)\n        },\n        noop: function() {},\n        isFunction: function(a) {\n            return \"function\" === o.type(a)\n        },\n        isArray: Array.isArray,\n        isWindow: function(a) {\n            return null != a && a === a.window\n        },\n        isNumeric: function(a) {\n            return a - parseFloat(a) >= 0\n        },\n        isPlainObject: function(a) {\n            if (\"object\" !== o.type(a) || a.nodeType || o.isWindow(a)) return !1;\n            try {\n                if (a.constructor && !j.call(a.constructor.prototype, \"isPrototypeOf\")) return !1\n            } catch (b) {\n                return !1\n            }\n            return !0\n        },\n        isEmptyObject: function(a) {\n            var b;\n            for (b in a) return !1;\n            return !0\n        },\n        type: function(a) {\n            return null == a ? a + \"\" : \"object\" == typeof a || \"function\" == typeof a ? h[i.call(a)] || \"object\" : typeof a\n        },\n        globalEval: function(a) {\n            var b, c = eval;\n            a = o.trim(a), a && (1 === a.indexOf(\"use strict\") ? (b = m.createElement(\"script\"), b.text = a, m.head.appendChild(b).parentNode.removeChild(b)) : c(a))\n        },\n        camelCase: function(a) {\n            return a.replace(p, \"ms-\").replace(q, r)\n        },\n        nodeName: function(a, b) {\n            return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()\n        },\n        each: function(a, b, c) {\n            var d, e = 0,\n                f = a.length,\n                g = s(a);\n            if (c) {\n                if (g) {\n                    for (; f > e; e++)\n                        if (d = b.apply(a[e], c), d === !1) break\n                } else\n                    for (e in a)\n                        if (d = b.apply(a[e], c), d === !1) break\n            } else if (g) {\n                for (; f > e; e++)\n                    if (d = b.call(a[e], e, a[e]), d === !1) break\n            } else\n                for (e in a)\n                    if (d = b.call(a[e], e, a[e]), d === !1) break;\n            return a\n        },\n        trim: function(a) {\n            return null == a ? \"\" : k.call(a)\n        },\n        makeArray: function(a, b) {\n            var c = b || [];\n            return null != a && (s(Object(a)) ? o.merge(c, \"string\" == typeof a ? [a] : a) : f.call(c, a)), c\n        },\n        inArray: function(a, b, c) {\n            return null == b ? -1 : g.call(b, a, c)\n        },\n        merge: function(a, b) {\n            for (var c = +b.length, d = 0, e = a.length; c > d; d++) a[e++] = b[d];\n            return a.length = e, a\n        },\n        grep: function(a, b, c) {\n            for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);\n            return e\n        },\n        map: function(a, b, c) {\n            var d, f = 0,\n                g = a.length,\n                h = s(a),\n                i = [];\n            if (h)\n                for (; g > f; f++) d = b(a[f], f, c), null != d && i.push(d);\n            else\n                for (f in a) d = b(a[f], f, c), null != d && i.push(d);\n            return e.apply([], i)\n        },\n        guid: 1,\n        proxy: function(a, b) {\n            var c, e, f;\n            return \"string\" == typeof b && (c = a[b], b = a, a = c), o.isFunction(a) ? (e = d.call(arguments, 2), f = function() {\n                return a.apply(b || this, e.concat(d.call(arguments)))\n            }, f.guid = a.guid = a.guid || o.guid++, f) : void 0\n        },\n        now: Date.now,\n        support: l\n    }), o.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(a, b) {\n        h[\"[object \" + b + \"]\"] = b.toLowerCase()\n    });\n\n    function s(a) {\n        var b = a.length,\n            c = o.type(a);\n        return \"function\" === c || o.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : \"array\" === c || 0 === b || \"number\" == typeof b && b > 0 && b - 1 in a\n    }\n    var t = function(a) {\n        var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s = \"sizzle\" + -new Date,\n            t = a.document,\n            u = 0,\n            v = 0,\n            w = eb(),\n            x = eb(),\n            y = eb(),\n            z = function(a, b) {\n                return a === b && (j = !0), 0\n            },\n            A = \"undefined\",\n            B = 1 << 31,\n            C = {}.hasOwnProperty,\n            D = [],\n            E = D.pop,\n            F = D.push,\n            G = D.push,\n            H = D.slice,\n            I = D.indexOf || function(a) {\n                for (var b = 0, c = this.length; c > b; b++)\n                    if (this[b] === a) return b;\n                return -1\n            },\n            J = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n            K = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n            L = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n            M = L.replace(\"w\", \"w#\"),\n            N = \"\\\\[\" + K + \"*(\" + L + \")\" + K + \"*(?:([*^$|!~]?=)\" + K + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + M + \")|)|)\" + K + \"*\\\\]\",\n            O = \":(\" + L + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + N.replace(3, 8) + \")*)|.*)\\\\)|)\",\n            P = new RegExp(\"^\" + K + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + K + \"+$\", \"g\"),\n            Q = new RegExp(\"^\" + K + \"*,\" + K + \"*\"),\n            R = new RegExp(\"^\" + K + \"*([>+~]|\" + K + \")\" + K + \"*\"),\n            S = new RegExp(\"=\" + K + \"*([^\\\\]'\\\"]*?)\" + K + \"*\\\\]\", \"g\"),\n            T = new RegExp(O),\n            U = new RegExp(\"^\" + M + \"$\"),\n            V = {\n                ID: new RegExp(\"^#(\" + L + \")\"),\n                CLASS: new RegExp(\"^\\\\.(\" + L + \")\"),\n                TAG: new RegExp(\"^(\" + L.replace(\"w\", \"w*\") + \")\"),\n                ATTR: new RegExp(\"^\" + N),\n                PSEUDO: new RegExp(\"^\" + O),\n                CHILD: new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + K + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + K + \"*(?:([+-]|)\" + K + \"*(\\\\d+)|))\" + K + \"*\\\\)|)\", \"i\"),\n                bool: new RegExp(\"^(?:\" + J + \")$\", \"i\"),\n                needsContext: new RegExp(\"^\" + K + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + K + \"*((?:-\\\\d)?\\\\d*)\" + K + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n            },\n            W = /^(?:input|select|textarea|button)$/i,\n            X = /^h\\d$/i,\n            Y = /^[^{]+\\{\\s*\\[native \\w/,\n            Z = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n            $ = /[+~]/,\n            _ = /'|\\\\/g,\n            ab = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + K + \"?|(\" + K + \")|.)\", \"ig\"),\n            bb = function(a, b, c) {\n                var d = \"0x\" + b - 65536;\n                return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)\n            };\n        try {\n            G.apply(D = H.call(t.childNodes), t.childNodes), D[t.childNodes.length].nodeType\n        } catch (cb) {\n            G = {\n                apply: D.length ? function(a, b) {\n                    F.apply(a, H.call(b))\n                } : function(a, b) {\n                    var c = a.length,\n                        d = 0;\n                    while (a[c++] = b[d++]);\n                    a.length = c - 1\n                }\n            }\n        }\n\n        function db(a, b, d, e) {\n            var f, g, h, i, j, m, p, q, u, v;\n            if ((b ? b.ownerDocument || b : t) !== l && k(b), b = b || l, d = d || [], !a || \"string\" != typeof a) return d;\n            if (1 !== (i = b.nodeType) && 9 !== i) return [];\n            if (n && !e) {\n                if (f = Z.exec(a))\n                    if (h = f[1]) {\n                        if (9 === i) {\n                            if (g = b.getElementById(h), !g || !g.parentNode) return d;\n                            if (g.id === h) return d.push(g), d\n                        } else if (b.ownerDocument && (g = b.ownerDocument.getElementById(h)) && r(b, g) && g.id === h) return d.push(g), d\n                    } else {\n                        if (f[2]) return G.apply(d, b.getElementsByTagName(a)), d;\n                        if ((h = f[3]) && c.getElementsByClassName && b.getElementsByClassName) return G.apply(d, b.getElementsByClassName(h)), d\n                    }\n                if (c.qsa && (!o || !o.test(a))) {\n                    if (q = p = s, u = b, v = 9 === i && a, 1 === i && \"object\" !== b.nodeName.toLowerCase()) {\n                        m = ob(a), (p = b.getAttribute(\"id\")) ? q = p.replace(_, \"\\\\$&\") : b.setAttribute(\"id\", q), q = \"[id='\" + q + \"'] \", j = m.length;\n                        while (j--) m[j] = q + pb(m[j]);\n                        u = $.test(a) && mb(b.parentNode) || b, v = m.join(\",\")\n                    }\n                    if (v) try {\n                        return G.apply(d, u.querySelectorAll(v)), d\n                    } catch (w) {} finally {\n                        p || b.removeAttribute(\"id\")\n                    }\n                }\n            }\n            return xb(a.replace(P, \"$1\"), b, d, e)\n        }\n\n        function eb() {\n            var a = [];\n\n            function b(c, e) {\n                return a.push(c + \" \") > d.cacheLength && delete b[a.shift()], b[c + \" \"] = e\n            }\n            return b\n        }\n\n        function fb(a) {\n            return a[s] = !0, a\n        }\n\n        function gb(a) {\n            var b = l.createElement(\"div\");\n            try {\n                return !!a(b)\n            } catch (c) {\n                return !1\n            } finally {\n                b.parentNode && b.parentNode.removeChild(b), b = null\n            }\n        }\n\n        function hb(a, b) {\n            var c = a.split(\"|\"),\n                e = a.length;\n            while (e--) d.attrHandle[c[e]] = b\n        }\n\n        function ib(a, b) {\n            var c = b && a,\n                d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || B) - (~a.sourceIndex || B);\n            if (d) return d;\n            if (c)\n                while (c = c.nextSibling)\n                    if (c === b) return -1;\n            return a ? 1 : -1\n        }\n\n        function jb(a) {\n            return function(b) {\n                var c = b.nodeName.toLowerCase();\n                return \"input\" === c && b.type === a\n            }\n        }\n\n        function kb(a) {\n            return function(b) {\n                var c = b.nodeName.toLowerCase();\n                return (\"input\" === c || \"button\" === c) && b.type === a\n            }\n        }\n\n        function lb(a) {\n            return fb(function(b) {\n                return b = +b, fb(function(c, d) {\n                    var e, f = a([], c.length, b),\n                        g = f.length;\n                    while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e]))\n                })\n            })\n        }\n\n        function mb(a) {\n            return a && typeof a.getElementsByTagName !== A && a\n        }\n        c = db.support = {}, f = db.isXML = function(a) {\n            var b = a && (a.ownerDocument || a).documentElement;\n            return b ? \"HTML\" !== b.nodeName : !1\n        }, k = db.setDocument = function(a) {\n            var b, e = a ? a.ownerDocument || a : t,\n                g = e.defaultView;\n            return e !== l && 9 === e.nodeType && e.documentElement ? (l = e, m = e.documentElement, n = !f(e), g && g !== g.top && (g.addEventListener ? g.addEventListener(\"unload\", function() {\n                k()\n            }, !1) : g.attachEvent && g.attachEvent(\"onunload\", function() {\n                k()\n            })), c.attributes = gb(function(a) {\n                return a.className = \"i\", !a.getAttribute(\"className\")\n            }), c.getElementsByTagName = gb(function(a) {\n                return a.appendChild(e.createComment(\"\")), !a.getElementsByTagName(\"*\").length\n            }), c.getElementsByClassName = Y.test(e.getElementsByClassName) && gb(function(a) {\n                return a.innerHTML = \"<div class='a'></div><div class='a i'></div>\", a.firstChild.className = \"i\", 2 === a.getElementsByClassName(\"i\").length\n            }), c.getById = gb(function(a) {\n                return m.appendChild(a).id = s, !e.getElementsByName || !e.getElementsByName(s).length\n            }), c.getById ? (d.find.ID = function(a, b) {\n                if (typeof b.getElementById !== A && n) {\n                    var c = b.getElementById(a);\n                    return c && c.parentNode ? [c] : []\n                }\n            }, d.filter.ID = function(a) {\n                var b = a.replace(ab, bb);\n                return function(a) {\n                    return a.getAttribute(\"id\") === b\n                }\n            }) : (delete d.find.ID, d.filter.ID = function(a) {\n                var b = a.replace(ab, bb);\n                return function(a) {\n                    var c = typeof a.getAttributeNode !== A && a.getAttributeNode(\"id\");\n                    return c && c.value === b\n                }\n            }), d.find.TAG = c.getElementsByTagName ? function(a, b) {\n                return typeof b.getElementsByTagName !== A ? b.getElementsByTagName(a) : void 0\n            } : function(a, b) {\n                var c, d = [],\n                    e = 0,\n                    f = b.getElementsByTagName(a);\n                if (\"*\" === a) {\n                    while (c = f[e++]) 1 === c.nodeType && d.push(c);\n                    return d\n                }\n                return f\n            }, d.find.CLASS = c.getElementsByClassName && function(a, b) {\n                return typeof b.getElementsByClassName !== A && n ? b.getElementsByClassName(a) : void 0\n            }, p = [], o = [], (c.qsa = Y.test(e.querySelectorAll)) && (gb(function(a) {\n                a.innerHTML = \"<select t=''><option selected=''></option></select>\", a.querySelectorAll(\"[t^='']\").length && o.push(\"[*^$]=\" + K + \"*(?:''|\\\"\\\")\"), a.querySelectorAll(\"[selected]\").length || o.push(\"\\\\[\" + K + \"*(?:value|\" + J + \")\"), a.querySelectorAll(\":checked\").length || o.push(\":checked\")\n            }), gb(function(a) {\n                var b = e.createElement(\"input\");\n                b.setAttribute(\"type\", \"hidden\"), a.appendChild(b).setAttribute(\"name\", \"D\"), a.querySelectorAll(\"[name=d]\").length && o.push(\"name\" + K + \"*[*^$|!~]?=\"), a.querySelectorAll(\":enabled\").length || o.push(\":enabled\", \":disabled\"), a.querySelectorAll(\"*,:x\"), o.push(\",.*:\")\n            })), (c.matchesSelector = Y.test(q = m.webkitMatchesSelector || m.mozMatchesSelector || m.oMatchesSelector || m.msMatchesSelector)) && gb(function(a) {\n                c.disconnectedMatch = q.call(a, \"div\"), q.call(a, \"[s!='']:x\"), p.push(\"!=\", O)\n            }), o = o.length && new RegExp(o.join(\"|\")), p = p.length && new RegExp(p.join(\"|\")), b = Y.test(m.compareDocumentPosition), r = b || Y.test(m.contains) ? function(a, b) {\n                var c = 9 === a.nodeType ? a.documentElement : a,\n                    d = b && b.parentNode;\n                return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))\n            } : function(a, b) {\n                if (b)\n                    while (b = b.parentNode)\n                        if (b === a) return !0;\n                return !1\n            }, z = b ? function(a, b) {\n                if (a === b) return j = !0, 0;\n                var d = !a.compareDocumentPosition - !b.compareDocumentPosition;\n                return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === e || a.ownerDocument === t && r(t, a) ? -1 : b === e || b.ownerDocument === t && r(t, b) ? 1 : i ? I.call(i, a) - I.call(i, b) : 0 : 4 & d ? -1 : 1)\n            } : function(a, b) {\n                if (a === b) return j = !0, 0;\n                var c, d = 0,\n                    f = a.parentNode,\n                    g = b.parentNode,\n                    h = [a],\n                    k = [b];\n                if (!f || !g) return a === e ? -1 : b === e ? 1 : f ? -1 : g ? 1 : i ? I.call(i, a) - I.call(i, b) : 0;\n                if (f === g) return ib(a, b);\n                c = a;\n                while (c = c.parentNode) h.unshift(c);\n                c = b;\n                while (c = c.parentNode) k.unshift(c);\n                while (h[d] === k[d]) d++;\n                return d ? ib(h[d], k[d]) : h[d] === t ? -1 : k[d] === t ? 1 : 0\n            }, e) : l\n        }, db.matches = function(a, b) {\n            return db(a, null, null, b)\n        }, db.matchesSelector = function(a, b) {\n            if ((a.ownerDocument || a) !== l && k(a), b = b.replace(S, \"='$1']\"), !(!c.matchesSelector || !n || p && p.test(b) || o && o.test(b))) try {\n                var d = q.call(a, b);\n                if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d\n            } catch (e) {}\n            return db(b, l, null, [a]).length > 0\n        }, db.contains = function(a, b) {\n            return (a.ownerDocument || a) !== l && k(a), r(a, b)\n        }, db.attr = function(a, b) {\n            (a.ownerDocument || a) !== l && k(a);\n            var e = d.attrHandle[b.toLowerCase()],\n                f = e && C.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !n) : void 0;\n            return void 0 !== f ? f : c.attributes || !n ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null\n        }, db.error = function(a) {\n            throw new Error(\"Syntax error, unrecognized expression: \" + a)\n        }, db.uniqueSort = function(a) {\n            var b, d = [],\n                e = 0,\n                f = 0;\n            if (j = !c.detectDuplicates, i = !c.sortStable && a.slice(0), a.sort(z), j) {\n                while (b = a[f++]) b === a[f] && (e = d.push(f));\n                while (e--) a.splice(d[e], 1)\n            }\n            return i = null, a\n        }, e = db.getText = function(a) {\n            var b, c = \"\",\n                d = 0,\n                f = a.nodeType;\n            if (f) {\n                if (1 === f || 9 === f || 11 === f) {\n                    if (\"string\" == typeof a.textContent) return a.textContent;\n                    for (a = a.firstChild; a; a = a.nextSibling) c += e(a)\n                } else if (3 === f || 4 === f) return a.nodeValue\n            } else\n                while (b = a[d++]) c += e(b);\n            return c\n        }, d = db.selectors = {\n            cacheLength: 50,\n            createPseudo: fb,\n            match: V,\n            attrHandle: {},\n            find: {},\n            relative: {\n                \">\": {\n                    dir: \"parentNode\",\n                    first: !0\n                },\n                \" \": {\n                    dir: \"parentNode\"\n                },\n                \"+\": {\n                    dir: \"previousSibling\",\n                    first: !0\n                },\n                \"~\": {\n                    dir: \"previousSibling\"\n                }\n            },\n            preFilter: {\n                ATTR: function(a) {\n                    return a[1] = a[1].replace(ab, bb), a[3] = (a[4] || a[5] || \"\").replace(ab, bb), \"~=\" === a[2] && (a[3] = \" \" + a[3] + \" \"), a.slice(0, 4)\n                },\n                CHILD: function(a) {\n                    return a[1] = a[1].toLowerCase(), \"nth\" === a[1].slice(0, 3) ? (a[3] || db.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * (\"even\" === a[3] || \"odd\" === a[3])), a[5] = +(a[7] + a[8] || \"odd\" === a[3])) : a[3] && db.error(a[0]), a\n                },\n                PSEUDO: function(a) {\n                    var b, c = !a[5] && a[2];\n                    return V.CHILD.test(a[0]) ? null : (a[3] && void 0 !== a[4] ? a[2] = a[4] : c && T.test(c) && (b = ob(c, !0)) && (b = c.indexOf(\")\", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))\n                }\n            },\n            filter: {\n                TAG: function(a) {\n                    var b = a.replace(ab, bb).toLowerCase();\n                    return \"*\" === a ? function() {\n                        return !0\n                    } : function(a) {\n                        return a.nodeName && a.nodeName.toLowerCase() === b\n                    }\n                },\n                CLASS: function(a) {\n                    var b = w[a + \" \"];\n                    return b || (b = new RegExp(\"(^|\" + K + \")\" + a + \"(\" + K + \"|$)\")) && w(a, function(a) {\n                        return b.test(\"string\" == typeof a.className && a.className || typeof a.getAttribute !== A && a.getAttribute(\"class\") || \"\")\n                    })\n                },\n                ATTR: function(a, b, c) {\n                    return function(d) {\n                        var e = db.attr(d, a);\n                        return null == e ? \"!=\" === b : b ? (e += \"\", \"=\" === b ? e === c : \"!=\" === b ? e !== c : \"^=\" === b ? c && 0 === e.indexOf(c) : \"*=\" === b ? c && e.indexOf(c) > -1 : \"$=\" === b ? c && e.slice(-c.length) === c : \"~=\" === b ? (\" \" + e + \" \").indexOf(c) > -1 : \"|=\" === b ? e === c || e.slice(0, c.length + 1) === c + \"-\" : !1) : !0\n                    }\n                },\n                CHILD: function(a, b, c, d, e) {\n                    var f = \"nth\" !== a.slice(0, 3),\n                        g = \"last\" !== a.slice(-4),\n                        h = \"of-type\" === b;\n                    return 1 === d && 0 === e ? function(a) {\n                        return !!a.parentNode\n                    } : function(b, c, i) {\n                        var j, k, l, m, n, o, p = f !== g ? \"nextSibling\" : \"previousSibling\",\n                            q = b.parentNode,\n                            r = h && b.nodeName.toLowerCase(),\n                            t = !i && !h;\n                        if (q) {\n                            if (f) {\n                                while (p) {\n                                    l = b;\n                                    while (l = l[p])\n                                        if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;\n                                    o = p = \"only\" === a && !o && \"nextSibling\"\n                                }\n                                return !0\n                            }\n                            if (o = [g ? q.firstChild : q.lastChild], g && t) {\n                                k = q[s] || (q[s] = {}), j = k[a] || [], n = j[0] === u && j[1], m = j[0] === u && j[2], l = n && q.childNodes[n];\n                                while (l = ++n && l && l[p] || (m = n = 0) || o.pop())\n                                    if (1 === l.nodeType && ++m && l === b) {\n                                        k[a] = [u, n, m];\n                                        break\n                                    }\n                            } else if (t && (j = (b[s] || (b[s] = {}))[a]) && j[0] === u) m = j[1];\n                            else\n                                while (l = ++n && l && l[p] || (m = n = 0) || o.pop())\n                                    if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) && ++m && (t && ((l[s] || (l[s] = {}))[a] = [u, m]), l === b)) break;\n                            return m -= e, m === d || m % d === 0 && m / d >= 0\n                        }\n                    }\n                },\n                PSEUDO: function(a, b) {\n                    var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || db.error(\"unsupported pseudo: \" + a);\n                    return e[s] ? e(b) : e.length > 1 ? (c = [a, a, \"\", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? fb(function(a, c) {\n                        var d, f = e(a, b),\n                            g = f.length;\n                        while (g--) d = I.call(a, f[g]), a[d] = !(c[d] = f[g])\n                    }) : function(a) {\n                        return e(a, 0, c)\n                    }) : e\n                }\n            },\n            pseudos: {\n                not: fb(function(a) {\n                    var b = [],\n                        c = [],\n                        d = g(a.replace(P, \"$1\"));\n                    return d[s] ? fb(function(a, b, c, e) {\n                        var f, g = d(a, null, e, []),\n                            h = a.length;\n                        while (h--)(f = g[h]) && (a[h] = !(b[h] = f))\n                    }) : function(a, e, f) {\n                        return b[0] = a, d(b, null, f, c), !c.pop()\n                    }\n                }),\n                has: fb(function(a) {\n                    return function(b) {\n                        return db(a, b).length > 0\n                    }\n                }),\n                contains: fb(function(a) {\n                    return function(b) {\n                        return (b.textContent || b.innerText || e(b)).indexOf(a) > -1\n                    }\n                }),\n                lang: fb(function(a) {\n                    return U.test(a || \"\") || db.error(\"unsupported lang: \" + a), a = a.replace(ab, bb).toLowerCase(),\n                        function(b) {\n                            var c;\n                            do\n                                if (c = n ? b.lang : b.getAttribute(\"xml:lang\") || b.getAttribute(\"lang\")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + \"-\"); while ((b = b.parentNode) && 1 === b.nodeType);\n                            return !1\n                        }\n                }),\n                target: function(b) {\n                    var c = a.location && a.location.hash;\n                    return c && c.slice(1) === b.id\n                },\n                root: function(a) {\n                    return a === m\n                },\n                focus: function(a) {\n                    return a === l.activeElement && (!l.hasFocus || l.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)\n                },\n                enabled: function(a) {\n                    return a.disabled === !1\n                },\n                disabled: function(a) {\n                    return a.disabled === !0\n                },\n                checked: function(a) {\n                    var b = a.nodeName.toLowerCase();\n                    return \"input\" === b && !!a.checked || \"option\" === b && !!a.selected\n                },\n                selected: function(a) {\n                    return a.parentNode && a.parentNode.selectedIndex, a.selected === !0\n                },\n                empty: function(a) {\n                    for (a = a.firstChild; a; a = a.nextSibling)\n                        if (a.nodeType < 6) return !1;\n                    return !0\n                },\n                parent: function(a) {\n                    return !d.pseudos.empty(a)\n                },\n                header: function(a) {\n                    return X.test(a.nodeName)\n                },\n                input: function(a) {\n                    return W.test(a.nodeName)\n                },\n                button: function(a) {\n                    var b = a.nodeName.toLowerCase();\n                    return \"input\" === b && \"button\" === a.type || \"button\" === b\n                },\n                text: function(a) {\n                    var b;\n                    return \"input\" === a.nodeName.toLowerCase() && \"text\" === a.type && (null == (b = a.getAttribute(\"type\")) || \"text\" === b.toLowerCase())\n                },\n                first: lb(function() {\n                    return [0]\n                }),\n                last: lb(function(a, b) {\n                    return [b - 1]\n                }),\n                eq: lb(function(a, b, c) {\n                    return [0 > c ? c + b : c]\n                }),\n                even: lb(function(a, b) {\n                    for (var c = 0; b > c; c += 2) a.push(c);\n                    return a\n                }),\n                odd: lb(function(a, b) {\n                    for (var c = 1; b > c; c += 2) a.push(c);\n                    return a\n                }),\n                lt: lb(function(a, b, c) {\n                    for (var d = 0 > c ? c + b : c; --d >= 0;) a.push(d);\n                    return a\n                }),\n                gt: lb(function(a, b, c) {\n                    for (var d = 0 > c ? c + b : c; ++d < b;) a.push(d);\n                    return a\n                })\n            }\n        }, d.pseudos.nth = d.pseudos.eq;\n        for (b in {\n                radio: !0,\n                checkbox: !0,\n                file: !0,\n                password: !0,\n                image: !0\n            }) d.pseudos[b] = jb(b);\n        for (b in {\n                submit: !0,\n                reset: !0\n            }) d.pseudos[b] = kb(b);\n\n        function nb() {}\n        nb.prototype = d.filters = d.pseudos, d.setFilters = new nb;\n\n        function ob(a, b) {\n            var c, e, f, g, h, i, j, k = x[a + \" \"];\n            if (k) return b ? 0 : k.slice(0);\n            h = a, i = [], j = d.preFilter;\n            while (h) {\n                (!c || (e = Q.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = R.exec(h)) && (c = e.shift(), f.push({\n                    value: c,\n                    type: e[0].replace(P, \" \")\n                }), h = h.slice(c.length));\n                for (g in d.filter) !(e = V[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({\n                    value: c,\n                    type: g,\n                    matches: e\n                }), h = h.slice(c.length));\n                if (!c) break\n            }\n            return b ? h.length : h ? db.error(a) : x(a, i).slice(0)\n        }\n\n        function pb(a) {\n            for (var b = 0, c = a.length, d = \"\"; c > b; b++) d += a[b].value;\n            return d\n        }\n\n        function qb(a, b, c) {\n            var d = b.dir,\n                e = c && \"parentNode\" === d,\n                f = v++;\n            return b.first ? function(b, c, f) {\n                while (b = b[d])\n                    if (1 === b.nodeType || e) return a(b, c, f)\n            } : function(b, c, g) {\n                var h, i, j = [u, f];\n                if (g) {\n                    while (b = b[d])\n                        if ((1 === b.nodeType || e) && a(b, c, g)) return !0\n                } else\n                    while (b = b[d])\n                        if (1 === b.nodeType || e) {\n                            if (i = b[s] || (b[s] = {}), (h = i[d]) && h[0] === u && h[1] === f) return j[2] = h[2];\n                            if (i[d] = j, j[2] = a(b, c, g)) return !0\n                        }\n            }\n        }\n\n        function rb(a) {\n            return a.length > 1 ? function(b, c, d) {\n                var e = a.length;\n                while (e--)\n                    if (!a[e](b, c, d)) return !1;\n                return !0\n            } : a[0]\n        }\n\n        function sb(a, b, c, d, e) {\n            for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)(f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h));\n            return g\n        }\n\n        function tb(a, b, c, d, e, f) {\n            return d && !d[s] && (d = tb(d)), e && !e[s] && (e = tb(e, f)), fb(function(f, g, h, i) {\n                var j, k, l, m = [],\n                    n = [],\n                    o = g.length,\n                    p = f || wb(b || \"*\", h.nodeType ? [h] : h, []),\n                    q = !a || !f && b ? p : sb(p, m, a, h, i),\n                    r = c ? e || (f ? a : o || d) ? [] : g : q;\n                if (c && c(q, r, h, i), d) {\n                    j = sb(r, n), d(j, [], h, i), k = j.length;\n                    while (k--)(l = j[k]) && (r[n[k]] = !(q[n[k]] = l))\n                }\n                if (f) {\n                    if (e || a) {\n                        if (e) {\n                            j = [], k = r.length;\n                            while (k--)(l = r[k]) && j.push(q[k] = l);\n                            e(null, r = [], j, i)\n                        }\n                        k = r.length;\n                        while (k--)(l = r[k]) && (j = e ? I.call(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l))\n                    }\n                } else r = sb(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : G.apply(g, r)\n            })\n        }\n\n        function ub(a) {\n            for (var b, c, e, f = a.length, g = d.relative[a[0].type], i = g || d.relative[\" \"], j = g ? 1 : 0, k = qb(function(a) {\n                    return a === b\n                }, i, !0), l = qb(function(a) {\n                    return I.call(b, a) > -1\n                }, i, !0), m = [function(a, c, d) {\n                    return !g && (d || c !== h) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d))\n                }]; f > j; j++)\n                if (c = d.relative[a[j].type]) m = [qb(rb(m), c)];\n                else {\n                    if (c = d.filter[a[j].type].apply(null, a[j].matches), c[s]) {\n                        for (e = ++j; f > e; e++)\n                            if (d.relative[a[e].type]) break;\n                        return tb(j > 1 && rb(m), j > 1 && pb(a.slice(0, j - 1).concat({\n                            value: \" \" === a[j - 2].type ? \"*\" : \"\"\n                        })).replace(P, \"$1\"), c, e > j && ub(a.slice(j, e)), f > e && ub(a = a.slice(e)), f > e && pb(a))\n                    }\n                    m.push(c)\n                }\n            return rb(m)\n        }\n\n        function vb(a, b) {\n            var c = b.length > 0,\n                e = a.length > 0,\n                f = function(f, g, i, j, k) {\n                    var m, n, o, p = 0,\n                        q = \"0\",\n                        r = f && [],\n                        s = [],\n                        t = h,\n                        v = f || e && d.find.TAG(\"*\", k),\n                        w = u += null == t ? 1 : Math.random() || .1,\n                        x = v.length;\n                    for (k && (h = g !== l && g); q !== x && null != (m = v[q]); q++) {\n                        if (e && m) {\n                            n = 0;\n                            while (o = a[n++])\n                                if (o(m, g, i)) {\n                                    j.push(m);\n                                    break\n                                }\n                            k && (u = w)\n                        }\n                        c && ((m = !o && m) && p--, f && r.push(m))\n                    }\n                    if (p += q, c && q !== p) {\n                        n = 0;\n                        while (o = b[n++]) o(r, s, g, i);\n                        if (f) {\n                            if (p > 0)\n                                while (q--) r[q] || s[q] || (s[q] = E.call(j));\n                            s = sb(s)\n                        }\n                        G.apply(j, s), k && !f && s.length > 0 && p + b.length > 1 && db.uniqueSort(j)\n                    }\n                    return k && (u = w, h = t), r\n                };\n            return c ? fb(f) : f\n        }\n        g = db.compile = function(a, b) {\n            var c, d = [],\n                e = [],\n                f = y[a + \" \"];\n            if (!f) {\n                b || (b = ob(a)), c = b.length;\n                while (c--) f = ub(b[c]), f[s] ? d.push(f) : e.push(f);\n                f = y(a, vb(e, d))\n            }\n            return f\n        };\n\n        function wb(a, b, c) {\n            for (var d = 0, e = b.length; e > d; d++) db(a, b[d], c);\n            return c\n        }\n\n        function xb(a, b, e, f) {\n            var h, i, j, k, l, m = ob(a);\n            if (!f && 1 === m.length) {\n                if (i = m[0] = m[0].slice(0), i.length > 2 && \"ID\" === (j = i[0]).type && c.getById && 9 === b.nodeType && n && d.relative[i[1].type]) {\n                    if (b = (d.find.ID(j.matches[0].replace(ab, bb), b) || [])[0], !b) return e;\n                    a = a.slice(i.shift().value.length)\n                }\n                h = V.needsContext.test(a) ? 0 : i.length;\n                while (h--) {\n                    if (j = i[h], d.relative[k = j.type]) break;\n                    if ((l = d.find[k]) && (f = l(j.matches[0].replace(ab, bb), $.test(i[0].type) && mb(b.parentNode) || b))) {\n                        if (i.splice(h, 1), a = f.length && pb(i), !a) return G.apply(e, f), e;\n                        break\n                    }\n                }\n            }\n            return g(a, m)(f, b, !n, e, $.test(a) && mb(b.parentNode) || b), e\n        }\n        return c.sortStable = s.split(\"\").sort(z).join(\"\") === s, c.detectDuplicates = !!j, k(), c.sortDetached = gb(function(a) {\n            return 1 & a.compareDocumentPosition(l.createElement(\"div\"))\n        }), gb(function(a) {\n            return a.innerHTML = \"<a href='#'></a>\", \"#\" === a.firstChild.getAttribute(\"href\")\n        }) || hb(\"type|href|height|width\", function(a, b, c) {\n            return c ? void 0 : a.getAttribute(b, \"type\" === b.toLowerCase() ? 1 : 2)\n        }), c.attributes && gb(function(a) {\n            return a.innerHTML = \"<input/>\", a.firstChild.setAttribute(\"value\", \"\"), \"\" === a.firstChild.getAttribute(\"value\")\n        }) || hb(\"value\", function(a, b, c) {\n            return c || \"input\" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue\n        }), gb(function(a) {\n            return null == a.getAttribute(\"disabled\")\n        }) || hb(J, function(a, b, c) {\n            var d;\n            return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null\n        }), db\n    }(a);\n    o.find = t, o.expr = t.selectors, o.expr[\":\"] = o.expr.pseudos, o.unique = t.uniqueSort, o.text = t.getText, o.isXMLDoc = t.isXML, o.contains = t.contains;\n    var u = o.expr.match.needsContext,\n        v = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n        w = /^.[^:#\\[\\.,]*$/;\n\n    function x(a, b, c) {\n        if (o.isFunction(b)) return o.grep(a, function(a, d) {\n            return !!b.call(a, d, a) !== c\n        });\n        if (b.nodeType) return o.grep(a, function(a) {\n            return a === b !== c\n        });\n        if (\"string\" == typeof b) {\n            if (w.test(b)) return o.filter(b, a, c);\n            b = o.filter(b, a)\n        }\n        return o.grep(a, function(a) {\n            return g.call(b, a) >= 0 !== c\n        })\n    }\n    o.filter = function(a, b, c) {\n        var d = b[0];\n        return c && (a = \":not(\" + a + \")\"), 1 === b.length && 1 === d.nodeType ? o.find.matchesSelector(d, a) ? [d] : [] : o.find.matches(a, o.grep(b, function(a) {\n            return 1 === a.nodeType\n        }))\n    }, o.fn.extend({\n        find: function(a) {\n            var b, c = this.length,\n                d = [],\n                e = this;\n            if (\"string\" != typeof a) return this.pushStack(o(a).filter(function() {\n                for (b = 0; c > b; b++)\n                    if (o.contains(e[b], this)) return !0\n            }));\n            for (b = 0; c > b; b++) o.find(a, e[b], d);\n            return d = this.pushStack(c > 1 ? o.unique(d) : d), d.selector = this.selector ? this.selector + \" \" + a : a, d\n        },\n        filter: function(a) {\n            return this.pushStack(x(this, a || [], !1))\n        },\n        not: function(a) {\n            return this.pushStack(x(this, a || [], !0))\n        },\n        is: function(a) {\n            return !!x(this, \"string\" == typeof a && u.test(a) ? o(a) : a || [], !1).length\n        }\n    });\n    var y, z = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n        A = o.fn.init = function(a, b) {\n            var c, d;\n            if (!a) return this;\n            if (\"string\" == typeof a) {\n                if (c = \"<\" === a[0] && \">\" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : z.exec(a), !c || !c[1] && b) return !b || b.jquery ? (b || y).find(a) : this.constructor(b).find(a);\n                if (c[1]) {\n                    if (b = b instanceof o ? b[0] : b, o.merge(this, o.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : m, !0)), v.test(c[1]) && o.isPlainObject(b))\n                        for (c in b) o.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);\n                    return this\n                }\n                return d = m.getElementById(c[2]), d && d.parentNode && (this.length = 1, this[0] = d), this.context = m, this.selector = a, this\n            }\n            return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : o.isFunction(a) ? \"undefined\" != typeof y.ready ? y.ready(a) : a(o) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), o.makeArray(a, this))\n        };\n    A.prototype = o.fn, y = o(m);\n    var B = /^(?:parents|prev(?:Until|All))/,\n        C = {\n            children: !0,\n            contents: !0,\n            next: !0,\n            prev: !0\n        };\n    o.extend({\n        dir: function(a, b, c) {\n            var d = [],\n                e = void 0 !== c;\n            while ((a = a[b]) && 9 !== a.nodeType)\n                if (1 === a.nodeType) {\n                    if (e && o(a).is(c)) break;\n                    d.push(a)\n                }\n            return d\n        },\n        sibling: function(a, b) {\n            for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);\n            return c\n        }\n    }), o.fn.extend({\n        has: function(a) {\n            var b = o(a, this),\n                c = b.length;\n            return this.filter(function() {\n                for (var a = 0; c > a; a++)\n                    if (o.contains(this, b[a])) return !0\n            })\n        },\n        closest: function(a, b) {\n            for (var c, d = 0, e = this.length, f = [], g = u.test(a) || \"string\" != typeof a ? o(a, b || this.context) : 0; e > d; d++)\n                for (c = this[d]; c && c !== b; c = c.parentNode)\n                    if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && o.find.matchesSelector(c, a))) {\n                        f.push(c);\n                        break\n                    }\n            return this.pushStack(f.length > 1 ? o.unique(f) : f)\n        },\n        index: function(a) {\n            return a ? \"string\" == typeof a ? g.call(o(a), this[0]) : g.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1\n        },\n        add: function(a, b) {\n            return this.pushStack(o.unique(o.merge(this.get(), o(a, b))))\n        },\n        addBack: function(a) {\n            return this.add(null == a ? this.prevObject : this.prevObject.filter(a))\n        }\n    });\n\n    function D(a, b) {\n        while ((a = a[b]) && 1 !== a.nodeType);\n        return a\n    }\n    o.each({\n        parent: function(a) {\n            var b = a.parentNode;\n            return b && 11 !== b.nodeType ? b : null\n        },\n        parents: function(a) {\n            return o.dir(a, \"parentNode\")\n        },\n        parentsUntil: function(a, b, c) {\n            return o.dir(a, \"parentNode\", c)\n        },\n        next: function(a) {\n            return D(a, \"nextSibling\")\n        },\n        prev: function(a) {\n            return D(a, \"previousSibling\")\n        },\n        nextAll: function(a) {\n            return o.dir(a, \"nextSibling\")\n        },\n        prevAll: function(a) {\n            return o.dir(a, \"previousSibling\")\n        },\n        nextUntil: function(a, b, c) {\n            return o.dir(a, \"nextSibling\", c)\n        },\n        prevUntil: function(a, b, c) {\n            return o.dir(a, \"previousSibling\", c)\n        },\n        siblings: function(a) {\n            return o.sibling((a.parentNode || {}).firstChild, a)\n        },\n        children: function(a) {\n            return o.sibling(a.firstChild)\n        },\n        contents: function(a) {\n            return a.contentDocument || o.merge([], a.childNodes)\n        }\n    }, function(a, b) {\n        o.fn[a] = function(c, d) {\n            var e = o.map(this, b, c);\n            return \"Until\" !== a.slice(-5) && (d = c), d && \"string\" == typeof d && (e = o.filter(d, e)), this.length > 1 && (C[a] || o.unique(e), B.test(a) && e.reverse()), this.pushStack(e)\n        }\n    });\n    var E = /\\S+/g,\n        F = {};\n\n    function G(a) {\n        var b = F[a] = {};\n        return o.each(a.match(E) || [], function(a, c) {\n            b[c] = !0\n        }), b\n    }\n    o.Callbacks = function(a) {\n        a = \"string\" == typeof a ? F[a] || G(a) : o.extend({}, a);\n        var b, c, d, e, f, g, h = [],\n            i = !a.once && [],\n            j = function(l) {\n                for (b = a.memory && l, c = !0, g = e || 0, e = 0, f = h.length, d = !0; h && f > g; g++)\n                    if (h[g].apply(l[0], l[1]) === !1 && a.stopOnFalse) {\n                        b = !1;\n                        break\n                    }\n                d = !1, h && (i ? i.length && j(i.shift()) : b ? h = [] : k.disable())\n            },\n            k = {\n                add: function() {\n                    if (h) {\n                        var c = h.length;\n                        ! function g(b) {\n                            o.each(b, function(b, c) {\n                                var d = o.type(c);\n                                \"function\" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && \"string\" !== d && g(c)\n                            })\n                        }(arguments), d ? f = h.length : b && (e = c, j(b))\n                    }\n                    return this\n                },\n                remove: function() {\n                    return h && o.each(arguments, function(a, b) {\n                        var c;\n                        while ((c = o.inArray(b, h, c)) > -1) h.splice(c, 1), d && (f >= c && f--, g >= c && g--)\n                    }), this\n                },\n                has: function(a) {\n                    return a ? o.inArray(a, h) > -1 : !(!h || !h.length)\n                },\n                empty: function() {\n                    return h = [], f = 0, this\n                },\n                disable: function() {\n                    return h = i = b = void 0, this\n                },\n                disabled: function() {\n                    return !h\n                },\n                lock: function() {\n                    return i = void 0, b || k.disable(), this\n                },\n                locked: function() {\n                    return !i\n                },\n                fireWith: function(a, b) {\n                    return !h || c && !i || (b = b || [], b = [a, b.slice ? b.slice() : b], d ? i.push(b) : j(b)), this\n                },\n                fire: function() {\n                    return k.fireWith(this, arguments), this\n                },\n                fired: function() {\n                    return !!c\n                }\n            };\n        return k\n    }, o.extend({\n        Deferred: function(a) {\n            var b = [\n                    [\"resolve\", \"done\", o.Callbacks(\"once memory\"), \"resolved\"],\n                    [\"reject\", \"fail\", o.Callbacks(\"once memory\"), \"rejected\"],\n                    [\"notify\", \"progress\", o.Callbacks(\"memory\")]\n                ],\n                c = \"pending\",\n                d = {\n                    state: function() {\n                        return c\n                    },\n                    always: function() {\n                        return e.done(arguments).fail(arguments), this\n                    },\n                    then: function() {\n                        var a = arguments;\n                        return o.Deferred(function(c) {\n                            o.each(b, function(b, f) {\n                                var g = o.isFunction(a[b]) && a[b];\n                                e[f[1]](function() {\n                                    var a = g && g.apply(this, arguments);\n                                    a && o.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + \"With\"](this === d ? c.promise() : this, g ? [a] : arguments)\n                                })\n                            }), a = null\n                        }).promise()\n                    },\n                    promise: function(a) {\n                        return null != a ? o.extend(a, d) : d\n                    }\n                },\n                e = {};\n            return d.pipe = d.then, o.each(b, function(a, f) {\n                var g = f[2],\n                    h = f[3];\n                d[f[1]] = g.add, h && g.add(function() {\n                    c = h\n                }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {\n                    return e[f[0] + \"With\"](this === e ? d : this, arguments), this\n                }, e[f[0] + \"With\"] = g.fireWith\n            }), d.promise(e), a && a.call(e, e), e\n        },\n        when: function(a) {\n            var b = 0,\n                c = d.call(arguments),\n                e = c.length,\n                f = 1 !== e || a && o.isFunction(a.promise) ? e : 0,\n                g = 1 === f ? a : o.Deferred(),\n                h = function(a, b, c) {\n                    return function(e) {\n                        b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c)\n                    }\n                },\n                i, j, k;\n            if (e > 1)\n                for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++) c[b] && o.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;\n            return f || g.resolveWith(k, c), g.promise()\n        }\n    });\n    var H;\n    o.fn.ready = function(a) {\n        return o.ready.promise().done(a), this\n    }, o.extend({\n        isReady: !1,\n        readyWait: 1,\n        holdReady: function(a) {\n            a ? o.readyWait++ : o.ready(!0)\n        },\n        ready: function(a) {\n            (a === !0 ? --o.readyWait : o.isReady) || (o.isReady = !0, a !== !0 && --o.readyWait > 0 || (H.resolveWith(m, [o]), o.fn.trigger && o(m).trigger(\"ready\").off(\"ready\")))\n        }\n    });\n\n    function I() {\n        m.removeEventListener(\"DOMContentLoaded\", I, !1), a.removeEventListener(\"load\", I, !1), o.ready()\n    }\n    o.ready.promise = function(b) {\n        return H || (H = o.Deferred(), \"complete\" === m.readyState ? setTimeout(o.ready) : (m.addEventListener(\"DOMContentLoaded\", I, !1), a.addEventListener(\"load\", I, !1))), H.promise(b)\n    }, o.ready.promise();\n    var J = o.access = function(a, b, c, d, e, f, g) {\n        var h = 0,\n            i = a.length,\n            j = null == c;\n        if (\"object\" === o.type(c)) {\n            e = !0;\n            for (h in c) o.access(a, b, h, c[h], !0, f, g)\n        } else if (void 0 !== d && (e = !0, o.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {\n                return j.call(o(a), c)\n            })), b))\n            for (; i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));\n        return e ? a : j ? b.call(a) : i ? b(a[0], c) : f\n    };\n    o.acceptData = function(a) {\n        return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType\n    };\n\n    function K() {\n        Object.defineProperty(this.cache = {}, 0, {\n            get: function() {\n                return {}\n            }\n        }), this.expando = o.expando + Math.random()\n    }\n    K.uid = 1, K.accepts = o.acceptData, K.prototype = {\n        key: function(a) {\n            if (!K.accepts(a)) return 0;\n            var b = {},\n                c = a[this.expando];\n            if (!c) {\n                c = K.uid++;\n                try {\n                    b[this.expando] = {\n                        value: c\n                    }, Object.defineProperties(a, b)\n                } catch (d) {\n                    b[this.expando] = c, o.extend(a, b)\n                }\n            }\n            return this.cache[c] || (this.cache[c] = {}), c\n        },\n        set: function(a, b, c) {\n            var d, e = this.key(a),\n                f = this.cache[e];\n            if (\"string\" == typeof b) f[b] = c;\n            else if (o.isEmptyObject(f)) o.extend(this.cache[e], b);\n            else\n                for (d in b) f[d] = b[d];\n            return f\n        },\n        get: function(a, b) {\n            var c = this.cache[this.key(a)];\n            return void 0 === b ? c : c[b]\n        },\n        access: function(a, b, c) {\n            var d;\n            return void 0 === b || b && \"string\" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, o.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b)\n        },\n        remove: function(a, b) {\n            var c, d, e, f = this.key(a),\n                g = this.cache[f];\n            if (void 0 === b) this.cache[f] = {};\n            else {\n                o.isArray(b) ? d = b.concat(b.map(o.camelCase)) : (e = o.camelCase(b), b in g ? d = [b, e] : (d = e, d = d in g ? [d] : d.match(E) || [])), c = d.length;\n                while (c--) delete g[d[c]]\n            }\n        },\n        hasData: function(a) {\n            return !o.isEmptyObject(this.cache[a[this.expando]] || {})\n        },\n        discard: function(a) {\n            a[this.expando] && delete this.cache[a[this.expando]]\n        }\n    };\n    var L = new K,\n        M = new K,\n        N = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n        O = /([A-Z])/g;\n\n    function P(a, b, c) {\n        var d;\n        if (void 0 === c && 1 === a.nodeType)\n            if (d = \"data-\" + b.replace(O, \"-$1\").toLowerCase(), c = a.getAttribute(d), \"string\" == typeof c) {\n                try {\n                    c = \"true\" === c ? !0 : \"false\" === c ? !1 : \"null\" === c ? null : +c + \"\" === c ? +c : N.test(c) ? o.parseJSON(c) : c\n                } catch (e) {}\n                M.set(a, b, c)\n            } else c = void 0;\n        return c\n    }\n    o.extend({\n        hasData: function(a) {\n            return M.hasData(a) || L.hasData(a)\n        },\n        data: function(a, b, c) {\n            return M.access(a, b, c)\n        },\n        removeData: function(a, b) {\n            M.remove(a, b)\n        },\n        _data: function(a, b, c) {\n            return L.access(a, b, c)\n        },\n        _removeData: function(a, b) {\n            L.remove(a, b)\n        }\n    }), o.fn.extend({\n        data: function(a, b) {\n            var c, d, e, f = this[0],\n                g = f && f.attributes;\n            if (void 0 === a) {\n                if (this.length && (e = M.get(f), 1 === f.nodeType && !L.get(f, \"hasDataAttrs\"))) {\n                    c = g.length;\n                    while (c--) d = g[c].name, 0 === d.indexOf(\"data-\") && (d = o.camelCase(d.slice(5)), P(f, d, e[d]));\n                    L.set(f, \"hasDataAttrs\", !0)\n                }\n                return e\n            }\n            return \"object\" == typeof a ? this.each(function() {\n                M.set(this, a)\n            }) : J(this, function(b) {\n                var c, d = o.camelCase(a);\n                if (f && void 0 === b) {\n                    if (c = M.get(f, a), void 0 !== c) return c;\n                    if (c = M.get(f, d), void 0 !== c) return c;\n                    if (c = P(f, d, void 0), void 0 !== c) return c\n                } else this.each(function() {\n                    var c = M.get(this, d);\n                    M.set(this, d, b), -1 !== a.indexOf(\"-\") && void 0 !== c && M.set(this, a, b)\n                })\n            }, null, b, arguments.length > 1, null, !0)\n        },\n        removeData: function(a) {\n            return this.each(function() {\n                M.remove(this, a)\n            })\n        }\n    }), o.extend({\n        queue: function(a, b, c) {\n            var d;\n            return a ? (b = (b || \"fx\") + \"queue\", d = L.get(a, b), c && (!d || o.isArray(c) ? d = L.access(a, b, o.makeArray(c)) : d.push(c)), d || []) : void 0\n        },\n        dequeue: function(a, b) {\n            b = b || \"fx\";\n            var c = o.queue(a, b),\n                d = c.length,\n                e = c.shift(),\n                f = o._queueHooks(a, b),\n                g = function() {\n                    o.dequeue(a, b)\n                };\n            \"inprogress\" === e && (e = c.shift(), d--), e && (\"fx\" === b && c.unshift(\"inprogress\"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()\n        },\n        _queueHooks: function(a, b) {\n            var c = b + \"queueHooks\";\n            return L.get(a, c) || L.access(a, c, {\n                empty: o.Callbacks(\"once memory\").add(function() {\n                    L.remove(a, [b + \"queue\", c])\n                })\n            })\n        }\n    }), o.fn.extend({\n        queue: function(a, b) {\n            var c = 2;\n            return \"string\" != typeof a && (b = a, a = \"fx\", c--), arguments.length < c ? o.queue(this[0], a) : void 0 === b ? this : this.each(function() {\n                var c = o.queue(this, a, b);\n                o._queueHooks(this, a), \"fx\" === a && \"inprogress\" !== c[0] && o.dequeue(this, a)\n            })\n        },\n        dequeue: function(a) {\n            return this.each(function() {\n                o.dequeue(this, a)\n            })\n        },\n        clearQueue: function(a) {\n            return this.queue(a || \"fx\", [])\n        },\n        promise: function(a, b) {\n            var c, d = 1,\n                e = o.Deferred(),\n                f = this,\n                g = this.length,\n                h = function() {\n                    --d || e.resolveWith(f, [f])\n                };\n            \"string\" != typeof a && (b = a, a = void 0), a = a || \"fx\";\n            while (g--) c = L.get(f[g], a + \"queueHooks\"), c && c.empty && (d++, c.empty.add(h));\n            return h(), e.promise(b)\n        }\n    });\n    var Q = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n        R = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n        S = function(a, b) {\n            return a = b || a, \"none\" === o.css(a, \"display\") || !o.contains(a.ownerDocument, a)\n        },\n        T = /^(?:checkbox|radio)$/i;\n    ! function() {\n        var a = m.createDocumentFragment(),\n            b = a.appendChild(m.createElement(\"div\"));\n        b.innerHTML = \"<input type='radio' checked='checked' name='t'/>\", l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = \"<textarea>x</textarea>\", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue\n    }();\n    var U = \"undefined\";\n    l.focusinBubbles = \"onfocusin\" in a;\n    var V = /^key/,\n        W = /^(?:mouse|contextmenu)|click/,\n        X = /^(?:focusinfocus|focusoutblur)$/,\n        Y = /^([^.]*)(?:\\.(.+)|)$/;\n\n    function Z() {\n        return !0\n    }\n\n    function $() {\n        return !1\n    }\n\n    function _() {\n        try {\n            return m.activeElement\n        } catch (a) {}\n    }\n    o.event = {\n        global: {},\n        add: function(a, b, c, d, e) {\n            var f, g, h, i, j, k, l, m, n, p, q, r = L.get(a);\n            if (r) {\n                c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = o.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function(b) {\n                    return typeof o !== U && o.event.triggered !== b.type ? o.event.dispatch.apply(a, arguments) : void 0\n                }), b = (b || \"\").match(E) || [\"\"], j = b.length;\n                while (j--) h = Y.exec(b[j]) || [], n = q = h[1], p = (h[2] || \"\").split(\".\").sort(), n && (l = o.event.special[n] || {}, n = (e ? l.delegateType : l.bindType) || n, l = o.event.special[n] || {}, k = o.extend({\n                    type: n,\n                    origType: q,\n                    data: d,\n                    handler: c,\n                    guid: c.guid,\n                    selector: e,\n                    needsContext: e && o.expr.match.needsContext.test(e),\n                    namespace: p.join(\".\")\n                }, f), (m = i[n]) || (m = i[n] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(n, g, !1)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), o.event.global[n] = !0)\n            }\n        },\n        remove: function(a, b, c, d, e) {\n            var f, g, h, i, j, k, l, m, n, p, q, r = L.hasData(a) && L.get(a);\n            if (r && (i = r.events)) {\n                b = (b || \"\").match(E) || [\"\"], j = b.length;\n                while (j--)\n                    if (h = Y.exec(b[j]) || [], n = q = h[1], p = (h[2] || \"\").split(\".\").sort(), n) {\n                        l = o.event.special[n] || {}, n = (d ? l.delegateType : l.bindType) || n, m = i[n] || [], h = h[2] && new RegExp(\"(^|\\\\.)\" + p.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"), g = f = m.length;\n                        while (f--) k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && (\"**\" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));\n                        g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || o.removeEvent(a, n, r.handle), delete i[n])\n                    } else\n                        for (n in i) o.event.remove(a, n + b[j], c, d, !0);\n                o.isEmptyObject(i) && (delete r.handle, L.remove(a, \"events\"))\n            }\n        },\n        trigger: function(b, c, d, e) {\n            var f, g, h, i, k, l, n, p = [d || m],\n                q = j.call(b, \"type\") ? b.type : b,\n                r = j.call(b, \"namespace\") ? b.namespace.split(\".\") : [];\n            if (g = h = d = d || m, 3 !== d.nodeType && 8 !== d.nodeType && !X.test(q + o.event.triggered) && (q.indexOf(\".\") >= 0 && (r = q.split(\".\"), q = r.shift(), r.sort()), k = q.indexOf(\":\") < 0 && \"on\" + q, b = b[o.expando] ? b : new o.Event(q, \"object\" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = r.join(\".\"), b.namespace_re = b.namespace ? new RegExp(\"(^|\\\\.)\" + r.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : o.makeArray(c, [b]), n = o.event.special[q] || {}, e || !n.trigger || n.trigger.apply(d, c) !== !1)) {\n                if (!e && !n.noBubble && !o.isWindow(d)) {\n                    for (i = n.delegateType || q, X.test(i + q) || (g = g.parentNode); g; g = g.parentNode) p.push(g), h = g;\n                    h === (d.ownerDocument || m) && p.push(h.defaultView || h.parentWindow || a)\n                }\n                f = 0;\n                while ((g = p[f++]) && !b.isPropagationStopped()) b.type = f > 1 ? i : n.bindType || q, l = (L.get(g, \"events\") || {})[b.type] && L.get(g, \"handle\"), l && l.apply(g, c), l = k && g[k], l && l.apply && o.acceptData(g) && (b.result = l.apply(g, c), b.result === !1 && b.preventDefault());\n                return b.type = q, e || b.isDefaultPrevented() || n._default && n._default.apply(p.pop(), c) !== !1 || !o.acceptData(d) || k && o.isFunction(d[q]) && !o.isWindow(d) && (h = d[k], h && (d[k] = null), o.event.triggered = q, d[q](), o.event.triggered = void 0, h && (d[k] = h)), b.result\n            }\n        },\n        dispatch: function(a) {\n            a = o.event.fix(a);\n            var b, c, e, f, g, h = [],\n                i = d.call(arguments),\n                j = (L.get(this, \"events\") || {})[a.type] || [],\n                k = o.event.special[a.type] || {};\n            if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {\n                h = o.event.handlers.call(this, a, j), b = 0;\n                while ((f = h[b++]) && !a.isPropagationStopped()) {\n                    a.currentTarget = f.elem, c = 0;\n                    while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped())(!a.namespace_re || a.namespace_re.test(g.namespace)) && (a.handleObj = g, a.data = g.data, e = ((o.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== e && (a.result = e) === !1 && (a.preventDefault(), a.stopPropagation()))\n                }\n                return k.postDispatch && k.postDispatch.call(this, a), a.result\n            }\n        },\n        handlers: function(a, b) {\n            var c, d, e, f, g = [],\n                h = b.delegateCount,\n                i = a.target;\n            if (h && i.nodeType && (!a.button || \"click\" !== a.type))\n                for (; i !== this; i = i.parentNode || this)\n                    if (i.disabled !== !0 || \"click\" !== a.type) {\n                        for (d = [], c = 0; h > c; c++) f = b[c], e = f.selector + \" \", void 0 === d[e] && (d[e] = f.needsContext ? o(e, this).index(i) >= 0 : o.find(e, this, null, [i]).length), d[e] && d.push(f);\n                        d.length && g.push({\n                            elem: i,\n                            handlers: d\n                        })\n                    }\n            return h < b.length && g.push({\n                elem: this,\n                handlers: b.slice(h)\n            }), g\n        },\n        props: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n        fixHooks: {},\n        keyHooks: {\n            props: \"char charCode key keyCode\".split(\" \"),\n            filter: function(a, b) {\n                return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a\n            }\n        },\n        mouseHooks: {\n            props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n            filter: function(a, b) {\n                var c, d, e, f = b.button;\n                return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || m, d = c.documentElement, e = c.body, a.pageX = b.clientX + (d && d.scrollLeft || e && e.scrollLeft || 0) - (d && d.clientLeft || e && e.clientLeft || 0), a.pageY = b.clientY + (d && d.scrollTop || e && e.scrollTop || 0) - (d && d.clientTop || e && e.clientTop || 0)), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a\n            }\n        },\n        fix: function(a) {\n            if (a[o.expando]) return a;\n            var b, c, d, e = a.type,\n                f = a,\n                g = this.fixHooks[e];\n            g || (this.fixHooks[e] = g = W.test(e) ? this.mouseHooks : V.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new o.Event(f), b = d.length;\n            while (b--) c = d[b], a[c] = f[c];\n            return a.target || (a.target = m), 3 === a.target.nodeType && (a.target = a.target.parentNode), g.filter ? g.filter(a, f) : a\n        },\n        special: {\n            load: {\n                noBubble: !0\n            },\n            focus: {\n                trigger: function() {\n                    return this !== _() && this.focus ? (this.focus(), !1) : void 0\n                },\n                delegateType: \"focusin\"\n            },\n            blur: {\n                trigger: function() {\n                    return this === _() && this.blur ? (this.blur(), !1) : void 0\n                },\n                delegateType: \"focusout\"\n            },\n            click: {\n                trigger: function() {\n                    return \"checkbox\" === this.type && this.click && o.nodeName(this, \"input\") ? (this.click(), !1) : void 0\n                },\n                _default: function(a) {\n                    return o.nodeName(a.target, \"a\")\n                }\n            },\n            beforeunload: {\n                postDispatch: function(a) {\n                    void 0 !== a.result && (a.originalEvent.returnValue = a.result)\n                }\n            }\n        },\n        simulate: function(a, b, c, d) {\n            var e = o.extend(new o.Event, c, {\n                type: a,\n                isSimulated: !0,\n                originalEvent: {}\n            });\n            d ? o.event.trigger(e, null, b) : o.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault()\n        }\n    }, o.removeEvent = function(a, b, c) {\n        a.removeEventListener && a.removeEventListener(b, c, !1)\n    }, o.Event = function(a, b) {\n        return this instanceof o.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.getPreventDefault && a.getPreventDefault() ? Z : $) : this.type = a, b && o.extend(this, b), this.timeStamp = a && a.timeStamp || o.now(), void(this[o.expando] = !0)) : new o.Event(a, b)\n    }, o.Event.prototype = {\n        isDefaultPrevented: $,\n        isPropagationStopped: $,\n        isImmediatePropagationStopped: $,\n        preventDefault: function() {\n            var a = this.originalEvent;\n            this.isDefaultPrevented = Z, a && a.preventDefault && a.preventDefault()\n        },\n        stopPropagation: function() {\n            var a = this.originalEvent;\n            this.isPropagationStopped = Z, a && a.stopPropagation && a.stopPropagation()\n        },\n        stopImmediatePropagation: function() {\n            this.isImmediatePropagationStopped = Z, this.stopPropagation()\n        }\n    }, o.each({\n        mouseenter: \"mouseover\",\n        mouseleave: \"mouseout\"\n    }, function(a, b) {\n        o.event.special[a] = {\n            delegateType: b,\n            bindType: b,\n            handle: function(a) {\n                var c, d = this,\n                    e = a.relatedTarget,\n                    f = a.handleObj;\n                return (!e || e !== d && !o.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c\n            }\n        }\n    }), l.focusinBubbles || o.each({\n        focus: \"focusin\",\n        blur: \"focusout\"\n    }, function(a, b) {\n        var c = function(a) {\n            o.event.simulate(b, a.target, o.event.fix(a), !0)\n        };\n        o.event.special[b] = {\n            setup: function() {\n                var d = this.ownerDocument || this,\n                    e = L.access(d, b);\n                e || d.addEventListener(a, c, !0), L.access(d, b, (e || 0) + 1)\n            },\n            teardown: function() {\n                var d = this.ownerDocument || this,\n                    e = L.access(d, b) - 1;\n                e ? L.access(d, b, e) : (d.removeEventListener(a, c, !0), L.remove(d, b))\n            }\n        }\n    }), o.fn.extend({\n        on: function(a, b, c, d, e) {\n            var f, g;\n            if (\"object\" == typeof a) {\n                \"string\" != typeof b && (c = c || b, b = void 0);\n                for (g in a) this.on(g, b, c, a[g], e);\n                return this\n            }\n            if (null == c && null == d ? (d = b, c = b = void 0) : null == d && (\"string\" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = $;\n            else if (!d) return this;\n            return 1 === e && (f = d, d = function(a) {\n                return o().off(a), f.apply(this, arguments)\n            }, d.guid = f.guid || (f.guid = o.guid++)), this.each(function() {\n                o.event.add(this, a, d, c, b)\n            })\n        },\n        one: function(a, b, c, d) {\n            return this.on(a, b, c, d, 1)\n        },\n        off: function(a, b, c) {\n            var d, e;\n            if (a && a.preventDefault && a.handleObj) return d = a.handleObj, o(a.delegateTarget).off(d.namespace ? d.origType + \".\" + d.namespace : d.origType, d.selector, d.handler), this;\n            if (\"object\" == typeof a) {\n                for (e in a) this.off(e, b, a[e]);\n                return this\n            }\n            return (b === !1 || \"function\" == typeof b) && (c = b, b = void 0), c === !1 && (c = $), this.each(function() {\n                o.event.remove(this, a, c, b)\n            })\n        },\n        trigger: function(a, b) {\n            return this.each(function() {\n                o.event.trigger(a, b, this)\n            })\n        },\n        triggerHandler: function(a, b) {\n            var c = this[0];\n            return c ? o.event.trigger(a, b, c, !0) : void 0\n        }\n    });\n    var ab = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n        bb = /<([\\w:]+)/,\n        cb = /<|&#?\\w+;/,\n        db = /<(?:script|style|link)/i,\n        eb = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n        fb = /^$|\\/(?:java|ecma)script/i,\n        gb = /^true\\/(.*)/,\n        hb = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n        ib = {\n            option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n            thead: [1, \"<table>\", \"</table>\"],\n            col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n            tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n            td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n            _default: [0, \"\", \"\"]\n        };\n    ib.optgroup = ib.option, ib.tbody = ib.tfoot = ib.colgroup = ib.caption = ib.thead, ib.th = ib.td;\n\n    function jb(a, b) {\n        return o.nodeName(a, \"table\") && o.nodeName(11 !== b.nodeType ? b : b.firstChild, \"tr\") ? a.getElementsByTagName(\"tbody\")[0] || a.appendChild(a.ownerDocument.createElement(\"tbody\")) : a\n    }\n\n    function kb(a) {\n        return a.type = (null !== a.getAttribute(\"type\")) + \"/\" + a.type, a\n    }\n\n    function lb(a) {\n        var b = gb.exec(a.type);\n        return b ? a.type = b[1] : a.removeAttribute(\"type\"), a\n    }\n\n    function mb(a, b) {\n        for (var c = 0, d = a.length; d > c; c++) L.set(a[c], \"globalEval\", !b || L.get(b[c], \"globalEval\"))\n    }\n\n    function nb(a, b) {\n        var c, d, e, f, g, h, i, j;\n        if (1 === b.nodeType) {\n            if (L.hasData(a) && (f = L.access(a), g = L.set(b, f), j = f.events)) {\n                delete g.handle, g.events = {};\n                for (e in j)\n                    for (c = 0, d = j[e].length; d > c; c++) o.event.add(b, e, j[e][c])\n            }\n            M.hasData(a) && (h = M.access(a), i = o.extend({}, h), M.set(b, i))\n        }\n    }\n\n    function ob(a, b) {\n        var c = a.getElementsByTagName ? a.getElementsByTagName(b || \"*\") : a.querySelectorAll ? a.querySelectorAll(b || \"*\") : [];\n        return void 0 === b || b && o.nodeName(a, b) ? o.merge([a], c) : c\n    }\n\n    function pb(a, b) {\n        var c = b.nodeName.toLowerCase();\n        \"input\" === c && T.test(a.type) ? b.checked = a.checked : (\"input\" === c || \"textarea\" === c) && (b.defaultValue = a.defaultValue)\n    }\n    o.extend({\n        clone: function(a, b, c) {\n            var d, e, f, g, h = a.cloneNode(!0),\n                i = o.contains(a.ownerDocument, a);\n            if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || o.isXMLDoc(a)))\n                for (g = ob(h), f = ob(a), d = 0, e = f.length; e > d; d++) pb(f[d], g[d]);\n            if (b)\n                if (c)\n                    for (f = f || ob(a), g = g || ob(h), d = 0, e = f.length; e > d; d++) nb(f[d], g[d]);\n                else nb(a, h);\n            return g = ob(h, \"script\"), g.length > 0 && mb(g, !i && ob(a, \"script\")), h\n        },\n        buildFragment: function(a, b, c, d) {\n            for (var e, f, g, h, i, j, k = b.createDocumentFragment(), l = [], m = 0, n = a.length; n > m; m++)\n                if (e = a[m], e || 0 === e)\n                    if (\"object\" === o.type(e)) o.merge(l, e.nodeType ? [e] : e);\n                    else if (cb.test(e)) {\n                f = f || k.appendChild(b.createElement(\"div\")), g = (bb.exec(e) || [\"\", \"\"])[1].toLowerCase(), h = ib[g] || ib._default, f.innerHTML = h[1] + e.replace(ab, \"<$1></$2>\") + h[2], j = h[0];\n                while (j--) f = f.lastChild;\n                o.merge(l, f.childNodes), f = k.firstChild, f.textContent = \"\"\n            } else l.push(b.createTextNode(e));\n            k.textContent = \"\", m = 0;\n            while (e = l[m++])\n                if ((!d || -1 === o.inArray(e, d)) && (i = o.contains(e.ownerDocument, e), f = ob(k.appendChild(e), \"script\"), i && mb(f), c)) {\n                    j = 0;\n                    while (e = f[j++]) fb.test(e.type || \"\") && c.push(e)\n                }\n            return k\n        },\n        cleanData: function(a) {\n            for (var b, c, d, e, f, g, h = o.event.special, i = 0; void 0 !== (c = a[i]); i++) {\n                if (o.acceptData(c) && (f = c[L.expando], f && (b = L.cache[f]))) {\n                    if (d = Object.keys(b.events || {}), d.length)\n                        for (g = 0; void 0 !== (e = d[g]); g++) h[e] ? o.event.remove(c, e) : o.removeEvent(c, e, b.handle);\n                    L.cache[f] && delete L.cache[f]\n                }\n                delete M.cache[c[M.expando]]\n            }\n        }\n    }), o.fn.extend({\n        text: function(a) {\n            return J(this, function(a) {\n                return void 0 === a ? o.text(this) : this.empty().each(function() {\n                    (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = a)\n                })\n            }, null, a, arguments.length)\n        },\n        append: function() {\n            return this.domManip(arguments, function(a) {\n                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n                    var b = jb(this, a);\n                    b.appendChild(a)\n                }\n            })\n        },\n        prepend: function() {\n            return this.domManip(arguments, function(a) {\n                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n                    var b = jb(this, a);\n                    b.insertBefore(a, b.firstChild)\n                }\n            })\n        },\n        before: function() {\n            return this.domManip(arguments, function(a) {\n                this.parentNode && this.parentNode.insertBefore(a, this)\n            })\n        },\n        after: function() {\n            return this.domManip(arguments, function(a) {\n                this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)\n            })\n        },\n        remove: function(a, b) {\n            for (var c, d = a ? o.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || o.cleanData(ob(c)), c.parentNode && (b && o.contains(c.ownerDocument, c) && mb(ob(c, \"script\")), c.parentNode.removeChild(c));\n            return this\n        },\n        empty: function() {\n            for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (o.cleanData(ob(a, !1)), a.textContent = \"\");\n            return this\n        },\n        clone: function(a, b) {\n            return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function() {\n                return o.clone(this, a, b)\n            })\n        },\n        html: function(a) {\n            return J(this, function(a) {\n                var b = this[0] || {},\n                    c = 0,\n                    d = this.length;\n                if (void 0 === a && 1 === b.nodeType) return b.innerHTML;\n                if (\"string\" == typeof a && !db.test(a) && !ib[(bb.exec(a) || [\"\", \"\"])[1].toLowerCase()]) {\n                    a = a.replace(ab, \"<$1></$2>\");\n                    try {\n                        for (; d > c; c++) b = this[c] || {}, 1 === b.nodeType && (o.cleanData(ob(b, !1)), b.innerHTML = a);\n                        b = 0\n                    } catch (e) {}\n                }\n                b && this.empty().append(a)\n            }, null, a, arguments.length)\n        },\n        replaceWith: function() {\n            var a = arguments[0];\n            return this.domManip(arguments, function(b) {\n                a = this.parentNode, o.cleanData(ob(this)), a && a.replaceChild(b, this)\n            }), a && (a.length || a.nodeType) ? this : this.remove()\n        },\n        detach: function(a) {\n            return this.remove(a, !0)\n        },\n        domManip: function(a, b) {\n            a = e.apply([], a);\n            var c, d, f, g, h, i, j = 0,\n                k = this.length,\n                m = this,\n                n = k - 1,\n                p = a[0],\n                q = o.isFunction(p);\n            if (q || k > 1 && \"string\" == typeof p && !l.checkClone && eb.test(p)) return this.each(function(c) {\n                var d = m.eq(c);\n                q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b)\n            });\n            if (k && (c = o.buildFragment(a, this[0].ownerDocument, !1, this), d = c.firstChild, 1 === c.childNodes.length && (c = d), d)) {\n                for (f = o.map(ob(c, \"script\"), kb), g = f.length; k > j; j++) h = c, j !== n && (h = o.clone(h, !0, !0), g && o.merge(f, ob(h, \"script\"))), b.call(this[j], h, j);\n                if (g)\n                    for (i = f[f.length - 1].ownerDocument, o.map(f, lb), j = 0; g > j; j++) h = f[j], fb.test(h.type || \"\") && !L.access(h, \"globalEval\") && o.contains(i, h) && (h.src ? o._evalUrl && o._evalUrl(h.src) : o.globalEval(h.textContent.replace(hb, \"\")))\n            }\n            return this\n        }\n    }), o.each({\n        appendTo: \"append\",\n        prependTo: \"prepend\",\n        insertBefore: \"before\",\n        insertAfter: \"after\",\n        replaceAll: \"replaceWith\"\n    }, function(a, b) {\n        o.fn[a] = function(a) {\n            for (var c, d = [], e = o(a), g = e.length - 1, h = 0; g >= h; h++) c = h === g ? this : this.clone(!0), o(e[h])[b](c), f.apply(d, c.get());\n            return this.pushStack(d)\n        }\n    });\n    var qb, rb = {};\n\n    function sb(b, c) {\n        var d = o(c.createElement(b)).appendTo(c.body),\n            e = a.getDefaultComputedStyle ? a.getDefaultComputedStyle(d[0]).display : o.css(d[0], \"display\");\n        return d.detach(), e\n    }\n\n    function tb(a) {\n        var b = m,\n            c = rb[a];\n        return c || (c = sb(a, b), \"none\" !== c && c || (qb = (qb || o(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement), b = qb[0].contentDocument, b.write(), b.close(), c = sb(a, b), qb.detach()), rb[a] = c), c\n    }\n    var ub = /^margin/,\n        vb = new RegExp(\"^(\" + Q + \")(?!px)[a-z%]+$\", \"i\"),\n        wb = function(a) {\n            return a.ownerDocument.defaultView.getComputedStyle(a, null)\n        };\n\n    function xb(a, b, c) {\n        var d, e, f, g, h = a.style;\n        return c = c || wb(a), c && (g = c.getPropertyValue(b) || c[b]), c && (\"\" !== g || o.contains(a.ownerDocument, a) || (g = o.style(a, b)), vb.test(g) && ub.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + \"\" : g\n    }\n\n    function yb(a, b) {\n        return {\n            get: function() {\n                return a() ? void delete this.get : (this.get = b).apply(this, arguments)\n            }\n        }\n    }! function() {\n        var b, c, d = \"padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box\",\n            e = m.documentElement,\n            f = m.createElement(\"div\"),\n            g = m.createElement(\"div\");\n        g.style.backgroundClip = \"content-box\", g.cloneNode(!0).style.backgroundClip = \"\", l.clearCloneStyle = \"content-box\" === g.style.backgroundClip, f.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\", f.appendChild(g);\n\n        function h() {\n            g.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%\", e.appendChild(f);\n            var d = a.getComputedStyle(g, null);\n            b = \"1%\" !== d.top, c = \"4px\" === d.width, e.removeChild(f)\n        }\n        a.getComputedStyle && o.extend(l, {\n            pixelPosition: function() {\n                return h(), b\n            },\n            boxSizingReliable: function() {\n                return null == c && h(), c\n            },\n            reliableMarginRight: function() {\n                var b, c = g.appendChild(m.createElement(\"div\"));\n                return c.style.cssText = g.style.cssText = d, c.style.marginRight = c.style.width = \"0\", g.style.width = \"1px\", e.appendChild(f), b = !parseFloat(a.getComputedStyle(c, null).marginRight), e.removeChild(f), g.innerHTML = \"\", b\n            }\n        })\n    }(), o.swap = function(a, b, c, d) {\n        var e, f, g = {};\n        for (f in b) g[f] = a.style[f], a.style[f] = b[f];\n        e = c.apply(a, d || []);\n        for (f in b) a.style[f] = g[f];\n        return e\n    };\n    var zb = /^(none|table(?!-c[ea]).+)/,\n        Ab = new RegExp(\"^(\" + Q + \")(.*)$\", \"i\"),\n        Bb = new RegExp(\"^([+-])=(\" + Q + \")\", \"i\"),\n        Cb = {\n            position: \"absolute\",\n            visibility: \"hidden\",\n            display: \"block\"\n        },\n        Db = {\n            letterSpacing: 0,\n            fontWeight: 400\n        },\n        Eb = [\"Webkit\", \"O\", \"Moz\", \"ms\"];\n\n    function Fb(a, b) {\n        if (b in a) return b;\n        var c = b[0].toUpperCase() + b.slice(1),\n            d = b,\n            e = Eb.length;\n        while (e--)\n            if (b = Eb[e] + c, b in a) return b;\n        return d\n    }\n\n    function Gb(a, b, c) {\n        var d = Ab.exec(b);\n        return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || \"px\") : b\n    }\n\n    function Hb(a, b, c, d, e) {\n        for (var f = c === (d ? \"border\" : \"content\") ? 4 : \"width\" === b ? 1 : 0, g = 0; 4 > f; f += 2) \"margin\" === c && (g += o.css(a, c + R[f], !0, e)), d ? (\"content\" === c && (g -= o.css(a, \"padding\" + R[f], !0, e)), \"margin\" !== c && (g -= o.css(a, \"border\" + R[f] + \"Width\", !0, e))) : (g += o.css(a, \"padding\" + R[f], !0, e), \"padding\" !== c && (g += o.css(a, \"border\" + R[f] + \"Width\", !0, e)));\n        return g\n    }\n\n    function Ib(a, b, c) {\n        var d = !0,\n            e = \"width\" === b ? a.offsetWidth : a.offsetHeight,\n            f = wb(a),\n            g = \"border-box\" === o.css(a, \"boxSizing\", !1, f);\n        if (0 >= e || null == e) {\n            if (e = xb(a, b, f), (0 > e || null == e) && (e = a.style[b]), vb.test(e)) return e;\n            d = g && (l.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0\n        }\n        return e + Hb(a, b, c || (g ? \"border\" : \"content\"), d, f) + \"px\"\n    }\n\n    function Jb(a, b) {\n        for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = L.get(d, \"olddisplay\"), c = d.style.display, b ? (f[g] || \"none\" !== c || (d.style.display = \"\"), \"\" === d.style.display && S(d) && (f[g] = L.access(d, \"olddisplay\", tb(d.nodeName)))) : f[g] || (e = S(d), (c && \"none\" !== c || !e) && L.set(d, \"olddisplay\", e ? c : o.css(d, \"display\"))));\n        for (g = 0; h > g; g++) d = a[g], d.style && (b && \"none\" !== d.style.display && \"\" !== d.style.display || (d.style.display = b ? f[g] || \"\" : \"none\"));\n        return a\n    }\n    o.extend({\n        cssHooks: {\n            opacity: {\n                get: function(a, b) {\n                    if (b) {\n                        var c = xb(a, \"opacity\");\n                        return \"\" === c ? \"1\" : c\n                    }\n                }\n            }\n        },\n        cssNumber: {\n            columnCount: !0,\n            fillOpacity: !0,\n            fontWeight: !0,\n            lineHeight: !0,\n            opacity: !0,\n            order: !0,\n            orphans: !0,\n            widows: !0,\n            zIndex: !0,\n            zoom: !0\n        },\n        cssProps: {\n            \"float\": \"cssFloat\"\n        },\n        style: function(a, b, c, d) {\n            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {\n                var e, f, g, h = o.camelCase(b),\n                    i = a.style;\n                return b = o.cssProps[h] || (o.cssProps[h] = Fb(i, h)), g = o.cssHooks[b] || o.cssHooks[h], void 0 === c ? g && \"get\" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c, \"string\" === f && (e = Bb.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(o.css(a, b)), f = \"number\"), null != c && c === c && (\"number\" !== f || o.cssNumber[h] || (c += \"px\"), l.clearCloneStyle || \"\" !== c || 0 !== b.indexOf(\"background\") || (i[b] = \"inherit\"), g && \"set\" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = \"\", i[b] = c)), void 0)\n            }\n        },\n        css: function(a, b, c, d) {\n            var e, f, g, h = o.camelCase(b);\n            return b = o.cssProps[h] || (o.cssProps[h] = Fb(a.style, h)), g = o.cssHooks[b] || o.cssHooks[h], g && \"get\" in g && (e = g.get(a, !0, c)), void 0 === e && (e = xb(a, b, d)), \"normal\" === e && b in Db && (e = Db[b]), \"\" === c || c ? (f = parseFloat(e), c === !0 || o.isNumeric(f) ? f || 0 : e) : e\n        }\n    }), o.each([\"height\", \"width\"], function(a, b) {\n        o.cssHooks[b] = {\n            get: function(a, c, d) {\n                return c ? 0 === a.offsetWidth && zb.test(o.css(a, \"display\")) ? o.swap(a, Cb, function() {\n                    return Ib(a, b, d)\n                }) : Ib(a, b, d) : void 0\n            },\n            set: function(a, c, d) {\n                var e = d && wb(a);\n                return Gb(a, c, d ? Hb(a, b, d, \"border-box\" === o.css(a, \"boxSizing\", !1, e), e) : 0)\n            }\n        }\n    }), o.cssHooks.marginRight = yb(l.reliableMarginRight, function(a, b) {\n        return b ? o.swap(a, {\n            display: \"inline-block\"\n        }, xb, [a, \"marginRight\"]) : void 0\n    }), o.each({\n        margin: \"\",\n        padding: \"\",\n        border: \"Width\"\n    }, function(a, b) {\n        o.cssHooks[a + b] = {\n            expand: function(c) {\n                for (var d = 0, e = {}, f = \"string\" == typeof c ? c.split(\" \") : [c]; 4 > d; d++) e[a + R[d] + b] = f[d] || f[d - 2] || f[0];\n                return e\n            }\n        }, ub.test(a) || (o.cssHooks[a + b].set = Gb)\n    }), o.fn.extend({\n        css: function(a, b) {\n            return J(this, function(a, b, c) {\n                var d, e, f = {},\n                    g = 0;\n                if (o.isArray(b)) {\n                    for (d = wb(a), e = b.length; e > g; g++) f[b[g]] = o.css(a, b[g], !1, d);\n                    return f\n                }\n                return void 0 !== c ? o.style(a, b, c) : o.css(a, b)\n            }, a, b, arguments.length > 1)\n        },\n        show: function() {\n            return Jb(this, !0)\n        },\n        hide: function() {\n            return Jb(this)\n        },\n        toggle: function(a) {\n            return \"boolean\" == typeof a ? a ? this.show() : this.hide() : this.each(function() {\n                S(this) ? o(this).show() : o(this).hide()\n            })\n        }\n    });\n\n    function Kb(a, b, c, d, e) {\n        return new Kb.prototype.init(a, b, c, d, e)\n    }\n    o.Tween = Kb, Kb.prototype = {\n        constructor: Kb,\n        init: function(a, b, c, d, e, f) {\n            this.elem = a, this.prop = c, this.easing = e || \"swing\", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (o.cssNumber[c] ? \"\" : \"px\")\n        },\n        cur: function() {\n            var a = Kb.propHooks[this.prop];\n            return a && a.get ? a.get(this) : Kb.propHooks._default.get(this)\n        },\n        run: function(a) {\n            var b, c = Kb.propHooks[this.prop];\n            return this.pos = b = this.options.duration ? o.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Kb.propHooks._default.set(this), this\n        }\n    }, Kb.prototype.init.prototype = Kb.prototype, Kb.propHooks = {\n        _default: {\n            get: function(a) {\n                var b;\n                return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = o.css(a.elem, a.prop, \"\"), b && \"auto\" !== b ? b : 0) : a.elem[a.prop]\n            },\n            set: function(a) {\n                o.fx.step[a.prop] ? o.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[o.cssProps[a.prop]] || o.cssHooks[a.prop]) ? o.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now\n            }\n        }\n    }, Kb.propHooks.scrollTop = Kb.propHooks.scrollLeft = {\n        set: function(a) {\n            a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)\n        }\n    }, o.easing = {\n        linear: function(a) {\n            return a\n        },\n        swing: function(a) {\n            return .5 - Math.cos(a * Math.PI) / 2\n        }\n    }, o.fx = Kb.prototype.init, o.fx.step = {};\n    var Lb, Mb, Nb = /^(?:toggle|show|hide)$/,\n        Ob = new RegExp(\"^(?:([+-])=|)(\" + Q + \")([a-z%]*)$\", \"i\"),\n        Pb = /queueHooks$/,\n        Qb = [Vb],\n        Rb = {\n            \"*\": [function(a, b) {\n                var c = this.createTween(a, b),\n                    d = c.cur(),\n                    e = Ob.exec(b),\n                    f = e && e[3] || (o.cssNumber[a] ? \"\" : \"px\"),\n                    g = (o.cssNumber[a] || \"px\" !== f && +d) && Ob.exec(o.css(c.elem, a)),\n                    h = 1,\n                    i = 20;\n                if (g && g[3] !== f) {\n                    f = f || g[3], e = e || [], g = +d || 1;\n                    do h = h || \".5\", g /= h, o.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) && 1 !== h && --i)\n                }\n                return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c\n            }]\n        };\n\n    function Sb() {\n        return setTimeout(function() {\n            Lb = void 0\n        }), Lb = o.now()\n    }\n\n    function Tb(a, b) {\n        var c, d = 0,\n            e = {\n                height: a\n            };\n        for (b = b ? 1 : 0; 4 > d; d += 2 - b) c = R[d], e[\"margin\" + c] = e[\"padding\" + c] = a;\n        return b && (e.opacity = e.width = a), e\n    }\n\n    function Ub(a, b, c) {\n        for (var d, e = (Rb[b] || []).concat(Rb[\"*\"]), f = 0, g = e.length; g > f; f++)\n            if (d = e[f].call(c, b, a)) return d\n    }\n\n    function Vb(a, b, c) {\n        var d, e, f, g, h, i, j, k = this,\n            l = {},\n            m = a.style,\n            n = a.nodeType && S(a),\n            p = L.get(a, \"fxshow\");\n        c.queue || (h = o._queueHooks(a, \"fx\"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function() {\n            h.unqueued || i()\n        }), h.unqueued++, k.always(function() {\n            k.always(function() {\n                h.unqueued--, o.queue(a, \"fx\").length || h.empty.fire()\n            })\n        })), 1 === a.nodeType && (\"height\" in b || \"width\" in b) && (c.overflow = [m.overflow, m.overflowX, m.overflowY], j = o.css(a, \"display\"), \"none\" === j && (j = tb(a.nodeName)), \"inline\" === j && \"none\" === o.css(a, \"float\") && (m.display = \"inline-block\")), c.overflow && (m.overflow = \"hidden\", k.always(function() {\n            m.overflow = c.overflow[0], m.overflowX = c.overflow[1], m.overflowY = c.overflow[2]\n        }));\n        for (d in b)\n            if (e = b[d], Nb.exec(e)) {\n                if (delete b[d], f = f || \"toggle\" === e, e === (n ? \"hide\" : \"show\")) {\n                    if (\"show\" !== e || !p || void 0 === p[d]) continue;\n                    n = !0\n                }\n                l[d] = p && p[d] || o.style(a, d)\n            }\n        if (!o.isEmptyObject(l)) {\n            p ? \"hidden\" in p && (n = p.hidden) : p = L.access(a, \"fxshow\", {}), f && (p.hidden = !n), n ? o(a).show() : k.done(function() {\n                o(a).hide()\n            }), k.done(function() {\n                var b;\n                L.remove(a, \"fxshow\");\n                for (b in l) o.style(a, b, l[b])\n            });\n            for (d in l) g = Ub(n ? p[d] : 0, d, k), d in p || (p[d] = g.start, n && (g.end = g.start, g.start = \"width\" === d || \"height\" === d ? 1 : 0))\n        }\n    }\n\n    function Wb(a, b) {\n        var c, d, e, f, g;\n        for (c in a)\n            if (d = o.camelCase(c), e = b[d], f = a[c], o.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = o.cssHooks[d], g && \"expand\" in g) {\n                f = g.expand(f), delete a[d];\n                for (c in f) c in a || (a[c] = f[c], b[c] = e)\n            } else b[d] = e\n    }\n\n    function Xb(a, b, c) {\n        var d, e, f = 0,\n            g = Qb.length,\n            h = o.Deferred().always(function() {\n                delete i.elem\n            }),\n            i = function() {\n                if (e) return !1;\n                for (var b = Lb || Sb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);\n                return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1)\n            },\n            j = h.promise({\n                elem: a,\n                props: o.extend({}, b),\n                opts: o.extend(!0, {\n                    specialEasing: {}\n                }, c),\n                originalProperties: b,\n                originalOptions: c,\n                startTime: Lb || Sb(),\n                duration: c.duration,\n                tweens: [],\n                createTween: function(b, c) {\n                    var d = o.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);\n                    return j.tweens.push(d), d\n                },\n                stop: function(b) {\n                    var c = 0,\n                        d = b ? j.tweens.length : 0;\n                    if (e) return this;\n                    for (e = !0; d > c; c++) j.tweens[c].run(1);\n                    return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this\n                }\n            }),\n            k = j.props;\n        for (Wb(k, j.opts.specialEasing); g > f; f++)\n            if (d = Qb[f].call(j, a, k, j.opts)) return d;\n        return o.map(k, Ub, j), o.isFunction(j.opts.start) && j.opts.start.call(a, j), o.fx.timer(o.extend(i, {\n            elem: a,\n            anim: j,\n            queue: j.opts.queue\n        })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)\n    }\n    o.Animation = o.extend(Xb, {\n            tweener: function(a, b) {\n                o.isFunction(a) ? (b = a, a = [\"*\"]) : a = a.split(\" \");\n                for (var c, d = 0, e = a.length; e > d; d++) c = a[d], Rb[c] = Rb[c] || [], Rb[c].unshift(b)\n            },\n            prefilter: function(a, b) {\n                b ? Qb.unshift(a) : Qb.push(a)\n            }\n        }), o.speed = function(a, b, c) {\n            var d = a && \"object\" == typeof a ? o.extend({}, a) : {\n                complete: c || !c && b || o.isFunction(a) && a,\n                duration: a,\n                easing: c && b || b && !o.isFunction(b) && b\n            };\n            return d.duration = o.fx.off ? 0 : \"number\" == typeof d.duration ? d.duration : d.duration in o.fx.speeds ? o.fx.speeds[d.duration] : o.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = \"fx\"), d.old = d.complete, d.complete = function() {\n                o.isFunction(d.old) && d.old.call(this), d.queue && o.dequeue(this, d.queue)\n            }, d\n        }, o.fn.extend({\n            fadeTo: function(a, b, c, d) {\n                return this.filter(S).css(\"opacity\", 0).show().end().animate({\n                    opacity: b\n                }, a, c, d)\n            },\n            animate: function(a, b, c, d) {\n                var e = o.isEmptyObject(a),\n                    f = o.speed(b, c, d),\n                    g = function() {\n                        var b = Xb(this, o.extend({}, a), f);\n                        (e || L.get(this, \"finish\")) && b.stop(!0)\n                    };\n                return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)\n            },\n            stop: function(a, b, c) {\n                var d = function(a) {\n                    var b = a.stop;\n                    delete a.stop, b(c)\n                };\n                return \"string\" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || \"fx\", []), this.each(function() {\n                    var b = !0,\n                        e = null != a && a + \"queueHooks\",\n                        f = o.timers,\n                        g = L.get(this);\n                    if (e) g[e] && g[e].stop && d(g[e]);\n                    else\n                        for (e in g) g[e] && g[e].stop && Pb.test(e) && d(g[e]);\n                    for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));\n                    (b || !c) && o.dequeue(this, a)\n                })\n            },\n            finish: function(a) {\n                return a !== !1 && (a = a || \"fx\"), this.each(function() {\n                    var b, c = L.get(this),\n                        d = c[a + \"queue\"],\n                        e = c[a + \"queueHooks\"],\n                        f = o.timers,\n                        g = d ? d.length : 0;\n                    for (c.finish = !0, o.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));\n                    for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);\n                    delete c.finish\n                })\n            }\n        }), o.each([\"toggle\", \"show\", \"hide\"], function(a, b) {\n            var c = o.fn[b];\n            o.fn[b] = function(a, d, e) {\n                return null == a || \"boolean\" == typeof a ? c.apply(this, arguments) : this.animate(Tb(b, !0), a, d, e)\n            }\n        }), o.each({\n            slideDown: Tb(\"show\"),\n            slideUp: Tb(\"hide\"),\n            slideToggle: Tb(\"toggle\"),\n            fadeIn: {\n                opacity: \"show\"\n            },\n            fadeOut: {\n                opacity: \"hide\"\n            },\n            fadeToggle: {\n                opacity: \"toggle\"\n            }\n        }, function(a, b) {\n            o.fn[a] = function(a, c, d) {\n                return this.animate(b, a, c, d)\n            }\n        }), o.timers = [], o.fx.tick = function() {\n            var a, b = 0,\n                c = o.timers;\n            for (Lb = o.now(); b < c.length; b++) a = c[b], a() || c[b] !== a || c.splice(b--, 1);\n            c.length || o.fx.stop(), Lb = void 0\n        }, o.fx.timer = function(a) {\n            o.timers.push(a), a() ? o.fx.start() : o.timers.pop()\n        }, o.fx.interval = 13, o.fx.start = function() {\n            Mb || (Mb = setInterval(o.fx.tick, o.fx.interval))\n        }, o.fx.stop = function() {\n            clearInterval(Mb), Mb = null\n        }, o.fx.speeds = {\n            slow: 600,\n            fast: 200,\n            _default: 400\n        }, o.fn.delay = function(a, b) {\n            return a = o.fx ? o.fx.speeds[a] || a : a, b = b || \"fx\", this.queue(b, function(b, c) {\n                var d = setTimeout(b, a);\n                c.stop = function() {\n                    clearTimeout(d)\n                }\n            })\n        },\n        function() {\n            var a = m.createElement(\"input\"),\n                b = m.createElement(\"select\"),\n                c = b.appendChild(m.createElement(\"option\"));\n            a.type = \"checkbox\", l.checkOn = \"\" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = m.createElement(\"input\"), a.value = \"t\", a.type = \"radio\", l.radioValue = \"t\" === a.value\n        }();\n    var Yb, Zb, $b = o.expr.attrHandle;\n    o.fn.extend({\n        attr: function(a, b) {\n            return J(this, o.attr, a, b, arguments.length > 1)\n        },\n        removeAttr: function(a) {\n            return this.each(function() {\n                o.removeAttr(this, a)\n            })\n        }\n    }), o.extend({\n        attr: function(a, b, c) {\n            var d, e, f = a.nodeType;\n            if (a && 3 !== f && 8 !== f && 2 !== f) return typeof a.getAttribute === U ? o.prop(a, b, c) : (1 === f && o.isXMLDoc(a) || (b = b.toLowerCase(), d = o.attrHooks[b] || (o.expr.match.bool.test(b) ? Zb : Yb)), void 0 === c ? d && \"get\" in d && null !== (e = d.get(a, b)) ? e : (e = o.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d && \"set\" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + \"\"), c) : void o.removeAttr(a, b))\n        },\n        removeAttr: function(a, b) {\n            var c, d, e = 0,\n                f = b && b.match(E);\n            if (f && 1 === a.nodeType)\n                while (c = f[e++]) d = o.propFix[c] || c, o.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c)\n        },\n        attrHooks: {\n            type: {\n                set: function(a, b) {\n                    if (!l.radioValue && \"radio\" === b && o.nodeName(a, \"input\")) {\n                        var c = a.value;\n                        return a.setAttribute(\"type\", b), c && (a.value = c), b\n                    }\n                }\n            }\n        }\n    }), Zb = {\n        set: function(a, b, c) {\n            return b === !1 ? o.removeAttr(a, c) : a.setAttribute(c, c), c\n        }\n    }, o.each(o.expr.match.bool.source.match(/\\w+/g), function(a, b) {\n        var c = $b[b] || o.find.attr;\n        $b[b] = function(a, b, d) {\n            var e, f;\n            return d || (f = $b[b], $b[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, $b[b] = f), e\n        }\n    });\n    var _b = /^(?:input|select|textarea|button)$/i;\n    o.fn.extend({\n        prop: function(a, b) {\n            return J(this, o.prop, a, b, arguments.length > 1)\n        },\n        removeProp: function(a) {\n            return this.each(function() {\n                delete this[o.propFix[a] || a]\n            })\n        }\n    }), o.extend({\n        propFix: {\n            \"for\": \"htmlFor\",\n            \"class\": \"className\"\n        },\n        prop: function(a, b, c) {\n            var d, e, f, g = a.nodeType;\n            if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !o.isXMLDoc(a), f && (b = o.propFix[b] || b, e = o.propHooks[b]), void 0 !== c ? e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : a[b]\n        },\n        propHooks: {\n            tabIndex: {\n                get: function(a) {\n                    return a.hasAttribute(\"tabindex\") || _b.test(a.nodeName) || a.href ? a.tabIndex : -1\n                }\n            }\n        }\n    }), l.optSelected || (o.propHooks.selected = {\n        get: function(a) {\n            var b = a.parentNode;\n            return b && b.parentNode && b.parentNode.selectedIndex, null\n        }\n    }), o.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function() {\n        o.propFix[this.toLowerCase()] = this\n    });\n    var ac = /[\\t\\r\\n\\f]/g;\n    o.fn.extend({\n        addClass: function(a) {\n            var b, c, d, e, f, g, h = \"string\" == typeof a && a,\n                i = 0,\n                j = this.length;\n            if (o.isFunction(a)) return this.each(function(b) {\n                o(this).addClass(a.call(this, b, this.className))\n            });\n            if (h)\n                for (b = (a || \"\").match(E) || []; j > i; i++)\n                    if (c = this[i], d = 1 === c.nodeType && (c.className ? (\" \" + c.className + \" \").replace(ac, \" \") : \" \")) {\n                        f = 0;\n                        while (e = b[f++]) d.indexOf(\" \" + e + \" \") < 0 && (d += e + \" \");\n                        g = o.trim(d), c.className !== g && (c.className = g)\n                    }\n            return this\n        },\n        removeClass: function(a) {\n            var b, c, d, e, f, g, h = 0 === arguments.length || \"string\" == typeof a && a,\n                i = 0,\n                j = this.length;\n            if (o.isFunction(a)) return this.each(function(b) {\n                o(this).removeClass(a.call(this, b, this.className))\n            });\n            if (h)\n                for (b = (a || \"\").match(E) || []; j > i; i++)\n                    if (c = this[i], d = 1 === c.nodeType && (c.className ? (\" \" + c.className + \" \").replace(ac, \" \") : \"\")) {\n                        f = 0;\n                        while (e = b[f++])\n                            while (d.indexOf(\" \" + e + \" \") >= 0) d = d.replace(\" \" + e + \" \", \" \");\n                        g = a ? o.trim(d) : \"\", c.className !== g && (c.className = g)\n                    }\n            return this\n        },\n        toggleClass: function(a, b) {\n            var c = typeof a;\n            return \"boolean\" == typeof b && \"string\" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(o.isFunction(a) ? function(c) {\n                o(this).toggleClass(a.call(this, c, this.className, b), b)\n            } : function() {\n                if (\"string\" === c) {\n                    var b, d = 0,\n                        e = o(this),\n                        f = a.match(E) || [];\n                    while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b)\n                } else(c === U || \"boolean\" === c) && (this.className && L.set(this, \"__className__\", this.className), this.className = this.className || a === !1 ? \"\" : L.get(this, \"__className__\") || \"\")\n            })\n        },\n        hasClass: function(a) {\n            for (var b = \" \" + a + \" \", c = 0, d = this.length; d > c; c++)\n                if (1 === this[c].nodeType && (\" \" + this[c].className + \" \").replace(ac, \" \").indexOf(b) >= 0) return !0;\n            return !1\n        }\n    });\n    var bc = /\\r/g;\n    o.fn.extend({\n        val: function(a) {\n            var b, c, d, e = this[0]; {\n                if (arguments.length) return d = o.isFunction(a), this.each(function(c) {\n                    var e;\n                    1 === this.nodeType && (e = d ? a.call(this, c, o(this).val()) : a, null == e ? e = \"\" : \"number\" == typeof e ? e += \"\" : o.isArray(e) && (e = o.map(e, function(a) {\n                        return null == a ? \"\" : a + \"\"\n                    })), b = o.valHooks[this.type] || o.valHooks[this.nodeName.toLowerCase()], b && \"set\" in b && void 0 !== b.set(this, e, \"value\") || (this.value = e))\n                });\n                if (e) return b = o.valHooks[e.type] || o.valHooks[e.nodeName.toLowerCase()], b && \"get\" in b && void 0 !== (c = b.get(e, \"value\")) ? c : (c = e.value, \"string\" == typeof c ? c.replace(bc, \"\") : null == c ? \"\" : c)\n            }\n        }\n    }), o.extend({\n        valHooks: {\n            select: {\n                get: function(a) {\n                    for (var b, c, d = a.options, e = a.selectedIndex, f = \"select-one\" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)\n                        if (c = d[i], !(!c.selected && i !== e || (l.optDisabled ? c.disabled : null !== c.getAttribute(\"disabled\")) || c.parentNode.disabled && o.nodeName(c.parentNode, \"optgroup\"))) {\n                            if (b = o(c).val(), f) return b;\n                            g.push(b)\n                        }\n                    return g\n                },\n                set: function(a, b) {\n                    var c, d, e = a.options,\n                        f = o.makeArray(b),\n                        g = e.length;\n                    while (g--) d = e[g], (d.selected = o.inArray(o(d).val(), f) >= 0) && (c = !0);\n                    return c || (a.selectedIndex = -1), f\n                }\n            }\n        }\n    }), o.each([\"radio\", \"checkbox\"], function() {\n        o.valHooks[this] = {\n            set: function(a, b) {\n                return o.isArray(b) ? a.checked = o.inArray(o(a).val(), b) >= 0 : void 0\n            }\n        }, l.checkOn || (o.valHooks[this].get = function(a) {\n            return null === a.getAttribute(\"value\") ? \"on\" : a.value\n        })\n    }), o.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function(a, b) {\n        o.fn[b] = function(a, c) {\n            return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)\n        }\n    }), o.fn.extend({\n        hover: function(a, b) {\n            return this.mouseenter(a).mouseleave(b || a)\n        },\n        bind: function(a, b, c) {\n            return this.on(a, null, b, c)\n        },\n        unbind: function(a, b) {\n            return this.off(a, null, b)\n        },\n        delegate: function(a, b, c, d) {\n            return this.on(b, a, c, d)\n        },\n        undelegate: function(a, b, c) {\n            return 1 === arguments.length ? this.off(a, \"**\") : this.off(b, a || \"**\", c)\n        }\n    });\n    var cc = o.now(),\n        dc = /\\?/;\n    o.parseJSON = function(a) {\n        return JSON.parse(a + \"\")\n    }, o.parseXML = function(a) {\n        var b, c;\n        if (!a || \"string\" != typeof a) return null;\n        try {\n            c = new DOMParser, b = c.parseFromString(a, \"text/xml\")\n        } catch (d) {\n            b = void 0\n        }\n        return (!b || b.getElementsByTagName(\"parsererror\").length) && o.error(\"Invalid XML: \" + a), b\n    };\n    var ec, fc, gc = /#.*$/,\n        hc = /([?&])_=[^&]*/,\n        ic = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n        jc = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n        kc = /^(?:GET|HEAD)$/,\n        lc = /^\\/\\//,\n        mc = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n        nc = {},\n        oc = {},\n        pc = \"*/\".concat(\"*\");\n    try {\n        fc = location.href\n    } catch (qc) {\n        fc = m.createElement(\"a\"), fc.href = \"\", fc = fc.href\n    }\n    ec = mc.exec(fc.toLowerCase()) || [];\n\n    function rc(a) {\n        return function(b, c) {\n            \"string\" != typeof b && (c = b, b = \"*\");\n            var d, e = 0,\n                f = b.toLowerCase().match(E) || [];\n            if (o.isFunction(c))\n                while (d = f[e++]) \"+\" === d[0] ? (d = d.slice(1) || \"*\", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)\n        }\n    }\n\n    function sc(a, b, c, d) {\n        var e = {},\n            f = a === oc;\n\n        function g(h) {\n            var i;\n            return e[h] = !0, o.each(a[h] || [], function(a, h) {\n                var j = h(b, c, d);\n                return \"string\" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)\n            }), i\n        }\n        return g(b.dataTypes[0]) || !e[\"*\"] && g(\"*\")\n    }\n\n    function tc(a, b) {\n        var c, d, e = o.ajaxSettings.flatOptions || {};\n        for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);\n        return d && o.extend(!0, a, d), a\n    }\n\n    function uc(a, b, c) {\n        var d, e, f, g, h = a.contents,\n            i = a.dataTypes;\n        while (\"*\" === i[0]) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader(\"Content-Type\"));\n        if (d)\n            for (e in h)\n                if (h[e] && h[e].test(d)) {\n                    i.unshift(e);\n                    break\n                }\n        if (i[0] in c) f = i[0];\n        else {\n            for (e in c) {\n                if (!i[0] || a.converters[e + \" \" + i[0]]) {\n                    f = e;\n                    break\n                }\n                g || (g = e)\n            }\n            f = f || g\n        }\n        return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0\n    }\n\n    function vc(a, b, c, d) {\n        var e, f, g, h, i, j = {},\n            k = a.dataTypes.slice();\n        if (k[1])\n            for (g in a.converters) j[g.toLowerCase()] = a.converters[g];\n        f = k.shift();\n        while (f)\n            if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())\n                if (\"*\" === f) f = i;\n                else if (\"*\" !== i && i !== f) {\n            if (g = j[i + \" \" + f] || j[\"* \" + f], !g)\n                for (e in j)\n                    if (h = e.split(\" \"), h[1] === f && (g = j[i + \" \" + h[0]] || j[\"* \" + h[0]])) {\n                        g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));\n                        break\n                    }\n            if (g !== !0)\n                if (g && a[\"throws\"]) b = g(b);\n                else try {\n                    b = g(b)\n                } catch (l) {\n                    return {\n                        state: \"parsererror\",\n                        error: g ? l : \"No conversion from \" + i + \" to \" + f\n                    }\n                }\n        }\n        return {\n            state: \"success\",\n            data: b\n        }\n    }\n    o.extend({\n        active: 0,\n        lastModified: {},\n        etag: {},\n        ajaxSettings: {\n            url: fc,\n            type: \"GET\",\n            isLocal: jc.test(ec[1]),\n            global: !0,\n            processData: !0,\n            async: !0,\n            contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n            accepts: {\n                \"*\": pc,\n                text: \"text/plain\",\n                html: \"text/html\",\n                xml: \"application/xml, text/xml\",\n                json: \"application/json, text/javascript\"\n            },\n            contents: {\n                xml: /xml/,\n                html: /html/,\n                json: /json/\n            },\n            responseFields: {\n                xml: \"responseXML\",\n                text: \"responseText\",\n                json: \"responseJSON\"\n            },\n            converters: {\n                \"* text\": String,\n                \"text html\": !0,\n                \"text json\": o.parseJSON,\n                \"text xml\": o.parseXML\n            },\n            flatOptions: {\n                url: !0,\n                context: !0\n            }\n        },\n        ajaxSetup: function(a, b) {\n            return b ? tc(tc(a, o.ajaxSettings), b) : tc(o.ajaxSettings, a)\n        },\n        ajaxPrefilter: rc(nc),\n        ajaxTransport: rc(oc),\n        ajax: function(a, b) {\n            \"object\" == typeof a && (b = a, a = void 0), b = b || {};\n            var c, d, e, f, g, h, i, j, k = o.ajaxSetup({}, b),\n                l = k.context || k,\n                m = k.context && (l.nodeType || l.jquery) ? o(l) : o.event,\n                n = o.Deferred(),\n                p = o.Callbacks(\"once memory\"),\n                q = k.statusCode || {},\n                r = {},\n                s = {},\n                t = 0,\n                u = \"canceled\",\n                v = {\n                    readyState: 0,\n                    getResponseHeader: function(a) {\n                        var b;\n                        if (2 === t) {\n                            if (!f) {\n                                f = {};\n                                while (b = ic.exec(e)) f[b[1].toLowerCase()] = b[2]\n                            }\n                            b = f[a.toLowerCase()]\n                        }\n                        return null == b ? null : b\n                    },\n                    getAllResponseHeaders: function() {\n                        return 2 === t ? e : null\n                    },\n                    setRequestHeader: function(a, b) {\n                        var c = a.toLowerCase();\n                        return t || (a = s[c] = s[c] || a, r[a] = b), this\n                    },\n                    overrideMimeType: function(a) {\n                        return t || (k.mimeType = a), this\n                    },\n                    statusCode: function(a) {\n                        var b;\n                        if (a)\n                            if (2 > t)\n                                for (b in a) q[b] = [q[b], a[b]];\n                            else v.always(a[v.status]);\n                        return this\n                    },\n                    abort: function(a) {\n                        var b = a || u;\n                        return c && c.abort(b), x(0, b), this\n                    }\n                };\n            if (n.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || fc) + \"\").replace(gc, \"\").replace(lc, ec[1] + \"//\"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = o.trim(k.dataType || \"*\").toLowerCase().match(E) || [\"\"], null == k.crossDomain && (h = mc.exec(k.url.toLowerCase()), k.crossDomain = !(!h || h[1] === ec[1] && h[2] === ec[2] && (h[3] || (\"http:\" === h[1] ? \"80\" : \"443\")) === (ec[3] || (\"http:\" === ec[1] ? \"80\" : \"443\")))), k.data && k.processData && \"string\" != typeof k.data && (k.data = o.param(k.data, k.traditional)), sc(nc, k, b, v), 2 === t) return v;\n            i = k.global, i && 0 === o.active++ && o.event.trigger(\"ajaxStart\"), k.type = k.type.toUpperCase(), k.hasContent = !kc.test(k.type), d = k.url, k.hasContent || (k.data && (d = k.url += (dc.test(d) ? \"&\" : \"?\") + k.data, delete k.data), k.cache === !1 && (k.url = hc.test(d) ? d.replace(hc, \"$1_=\" + cc++) : d + (dc.test(d) ? \"&\" : \"?\") + \"_=\" + cc++)), k.ifModified && (o.lastModified[d] && v.setRequestHeader(\"If-Modified-Since\", o.lastModified[d]), o.etag[d] && v.setRequestHeader(\"If-None-Match\", o.etag[d])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader(\"Content-Type\", k.contentType), v.setRequestHeader(\"Accept\", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + (\"*\" !== k.dataTypes[0] ? \", \" + pc + \"; q=0.01\" : \"\") : k.accepts[\"*\"]);\n            for (j in k.headers) v.setRequestHeader(j, k.headers[j]);\n            if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();\n            u = \"abort\";\n            for (j in {\n                    success: 1,\n                    error: 1,\n                    complete: 1\n                }) v[j](k[j]);\n            if (c = sc(oc, k, b, v)) {\n                v.readyState = 1, i && m.trigger(\"ajaxSend\", [v, k]), k.async && k.timeout > 0 && (g = setTimeout(function() {\n                    v.abort(\"timeout\")\n                }, k.timeout));\n                try {\n                    t = 1, c.send(r, x)\n                } catch (w) {\n                    if (!(2 > t)) throw w;\n                    x(-1, w)\n                }\n            } else x(-1, \"No Transport\");\n\n            function x(a, b, f, h) {\n                var j, r, s, u, w, x = b;\n                2 !== t && (t = 2, g && clearTimeout(g), c = void 0, e = h || \"\", v.readyState = a > 0 ? 4 : 0, j = a >= 200 && 300 > a || 304 === a, f && (u = uc(k, v, f)), u = vc(k, u, v, j), j ? (k.ifModified && (w = v.getResponseHeader(\"Last-Modified\"), w && (o.lastModified[d] = w), w = v.getResponseHeader(\"etag\"), w && (o.etag[d] = w)), 204 === a || \"HEAD\" === k.type ? x = \"nocontent\" : 304 === a ? x = \"notmodified\" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = \"error\", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + \"\", j ? n.resolveWith(l, [r, x, v]) : n.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, i && m.trigger(j ? \"ajaxSuccess\" : \"ajaxError\", [v, k, j ? r : s]), p.fireWith(l, [v, x]), i && (m.trigger(\"ajaxComplete\", [v, k]), --o.active || o.event.trigger(\"ajaxStop\")))\n            }\n            return v\n        },\n        getJSON: function(a, b, c) {\n            return o.get(a, b, c, \"json\")\n        },\n        getScript: function(a, b) {\n            return o.get(a, void 0, b, \"script\")\n        }\n    }), o.each([\"get\", \"post\"], function(a, b) {\n        o[b] = function(a, c, d, e) {\n            return o.isFunction(c) && (e = e || d, d = c, c = void 0), o.ajax({\n                url: a,\n                type: b,\n                dataType: e,\n                data: c,\n                success: d\n            })\n        }\n    }), o.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function(a, b) {\n        o.fn[b] = function(a) {\n            return this.on(b, a)\n        }\n    }), o._evalUrl = function(a) {\n        return o.ajax({\n            url: a,\n            type: \"GET\",\n            dataType: \"script\",\n            async: !1,\n            global: !1,\n            \"throws\": !0\n        })\n    }, o.fn.extend({\n        wrapAll: function(a) {\n            var b;\n            return o.isFunction(a) ? this.each(function(b) {\n                o(this).wrapAll(a.call(this, b))\n            }) : (this[0] && (b = o(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function() {\n                var a = this;\n                while (a.firstElementChild) a = a.firstElementChild;\n                return a\n            }).append(this)), this)\n        },\n        wrapInner: function(a) {\n            return this.each(o.isFunction(a) ? function(b) {\n                o(this).wrapInner(a.call(this, b))\n            } : function() {\n                var b = o(this),\n                    c = b.contents();\n                c.length ? c.wrapAll(a) : b.append(a)\n            })\n        },\n        wrap: function(a) {\n            var b = o.isFunction(a);\n            return this.each(function(c) {\n                o(this).wrapAll(b ? a.call(this, c) : a)\n            })\n        },\n        unwrap: function() {\n            return this.parent().each(function() {\n                o.nodeName(this, \"body\") || o(this).replaceWith(this.childNodes)\n            }).end()\n        }\n    }), o.expr.filters.hidden = function(a) {\n        return a.offsetWidth <= 0 && a.offsetHeight <= 0\n    }, o.expr.filters.visible = function(a) {\n        return !o.expr.filters.hidden(a)\n    };\n    var wc = /%20/g,\n        xc = /\\[\\]$/,\n        yc = /\\r?\\n/g,\n        zc = /^(?:submit|button|image|reset|file)$/i,\n        Ac = /^(?:input|select|textarea|keygen)/i;\n\n    function Bc(a, b, c, d) {\n        var e;\n        if (o.isArray(b)) o.each(b, function(b, e) {\n            c || xc.test(a) ? d(a, e) : Bc(a + \"[\" + (\"object\" == typeof e ? b : \"\") + \"]\", e, c, d)\n        });\n        else if (c || \"object\" !== o.type(b)) d(a, b);\n        else\n            for (e in b) Bc(a + \"[\" + e + \"]\", b[e], c, d)\n    }\n    o.param = function(a, b) {\n        var c, d = [],\n            e = function(a, b) {\n                b = o.isFunction(b) ? b() : null == b ? \"\" : b, d[d.length] = encodeURIComponent(a) + \"=\" + encodeURIComponent(b)\n            };\n        if (void 0 === b && (b = o.ajaxSettings && o.ajaxSettings.traditional), o.isArray(a) || a.jquery && !o.isPlainObject(a)) o.each(a, function() {\n            e(this.name, this.value)\n        });\n        else\n            for (c in a) Bc(c, a[c], b, e);\n        return d.join(\"&\").replace(wc, \"+\")\n    }, o.fn.extend({\n        serialize: function() {\n            return o.param(this.serializeArray())\n        },\n        serializeArray: function() {\n            return this.map(function() {\n                var a = o.prop(this, \"elements\");\n                return a ? o.makeArray(a) : this\n            }).filter(function() {\n                var a = this.type;\n                return this.name && !o(this).is(\":disabled\") && Ac.test(this.nodeName) && !zc.test(a) && (this.checked || !T.test(a))\n            }).map(function(a, b) {\n                var c = o(this).val();\n                return null == c ? null : o.isArray(c) ? o.map(c, function(a) {\n                    return {\n                        name: b.name,\n                        value: a.replace(yc, \"\\r\\n\")\n                    }\n                }) : {\n                    name: b.name,\n                    value: c.replace(yc, \"\\r\\n\")\n                }\n            }).get()\n        }\n    }), o.ajaxSettings.xhr = function() {\n        try {\n            return new XMLHttpRequest\n        } catch (a) {}\n    };\n    var Cc = 0,\n        Dc = {},\n        Ec = {\n            0: 200,\n            1223: 204\n        },\n        Fc = o.ajaxSettings.xhr();\n    a.ActiveXObject && o(a).on(\"unload\", function() {\n        for (var a in Dc) Dc[a]()\n    }), l.cors = !!Fc && \"withCredentials\" in Fc, l.ajax = Fc = !!Fc, o.ajaxTransport(function(a) {\n        var b;\n        return l.cors || Fc && !a.crossDomain ? {\n            send: function(c, d) {\n                var e, f = a.xhr(),\n                    g = ++Cc;\n                if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields)\n                    for (e in a.xhrFields) f[e] = a.xhrFields[e];\n                a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c[\"X-Requested-With\"] || (c[\"X-Requested-With\"] = \"XMLHttpRequest\");\n                for (e in c) f.setRequestHeader(e, c[e]);\n                b = function(a) {\n                    return function() {\n                        b && (delete Dc[g], b = f.onload = f.onerror = null, \"abort\" === a ? f.abort() : \"error\" === a ? d(f.status, f.statusText) : d(Ec[f.status] || f.status, f.statusText, \"string\" == typeof f.responseText ? {\n                            text: f.responseText\n                        } : void 0, f.getAllResponseHeaders()))\n                    }\n                }, f.onload = b(), f.onerror = b(\"error\"), b = Dc[g] = b(\"abort\"), f.send(a.hasContent && a.data || null)\n            },\n            abort: function() {\n                b && b()\n            }\n        } : void 0\n    }), o.ajaxSetup({\n        accepts: {\n            script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n        },\n        contents: {\n            script: /(?:java|ecma)script/\n        },\n        converters: {\n            \"text script\": function(a) {\n                return o.globalEval(a), a\n            }\n        }\n    }), o.ajaxPrefilter(\"script\", function(a) {\n        void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = \"GET\")\n    }), o.ajaxTransport(\"script\", function(a) {\n        if (a.crossDomain) {\n            var b, c;\n            return {\n                send: function(d, e) {\n                    b = o(\"<script>\").prop({\n                        async: !0,\n                        charset: a.scriptCharset,\n                        src: a.url\n                    }).on(\"load error\", c = function(a) {\n                        b.remove(), c = null, a && e(\"error\" === a.type ? 404 : 200, a.type)\n                    }), m.head.appendChild(b[0])\n                },\n                abort: function() {\n                    c && c()\n                }\n            }\n        }\n    });\n    var Gc = [],\n        Hc = /(=)\\?(?=&|$)|\\?\\?/;\n    o.ajaxSetup({\n        jsonp: \"callback\",\n        jsonpCallback: function() {\n            var a = Gc.pop() || o.expando + \"_\" + cc++;\n            return this[a] = !0, a\n        }\n    }), o.ajaxPrefilter(\"json jsonp\", function(b, c, d) {\n        var e, f, g, h = b.jsonp !== !1 && (Hc.test(b.url) ? \"url\" : \"string\" == typeof b.data && !(b.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && Hc.test(b.data) && \"data\");\n        return h || \"jsonp\" === b.dataTypes[0] ? (e = b.jsonpCallback = o.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Hc, \"$1\" + e) : b.jsonp !== !1 && (b.url += (dc.test(b.url) ? \"&\" : \"?\") + b.jsonp + \"=\" + e), b.converters[\"script json\"] = function() {\n            return g || o.error(e + \" was not called\"), g[0]\n        }, b.dataTypes[0] = \"json\", f = a[e], a[e] = function() {\n            g = arguments\n        }, d.always(function() {\n            a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Gc.push(e)), g && o.isFunction(f) && f(g[0]), g = f = void 0\n        }), \"script\") : void 0\n    }), o.parseHTML = function(a, b, c) {\n        if (!a || \"string\" != typeof a) return null;\n        \"boolean\" == typeof b && (c = b, b = !1), b = b || m;\n        var d = v.exec(a),\n            e = !c && [];\n        return d ? [b.createElement(d[1])] : (d = o.buildFragment([a], b, e), e && e.length && o(e).remove(), o.merge([], d.childNodes))\n    };\n    var Ic = o.fn.load;\n    o.fn.load = function(a, b, c) {\n        if (\"string\" != typeof a && Ic) return Ic.apply(this, arguments);\n        var d, e, f, g = this,\n            h = a.indexOf(\" \");\n        return h >= 0 && (d = a.slice(h), a = a.slice(0, h)), o.isFunction(b) ? (c = b, b = void 0) : b && \"object\" == typeof b && (e = \"POST\"), g.length > 0 && o.ajax({\n            url: a,\n            type: e,\n            dataType: \"html\",\n            data: b\n        }).done(function(a) {\n            f = arguments, g.html(d ? o(\"<div>\").append(o.parseHTML(a)).find(d) : a)\n        }).complete(c && function(a, b) {\n            g.each(c, f || [a.responseText, b, a])\n        }), this\n    }, o.expr.filters.animated = function(a) {\n        return o.grep(o.timers, function(b) {\n            return a === b.elem\n        }).length\n    };\n    var Jc = a.document.documentElement;\n\n    function Kc(a) {\n        return o.isWindow(a) ? a : 9 === a.nodeType && a.defaultView\n    }\n    o.offset = {\n        setOffset: function(a, b, c) {\n            var d, e, f, g, h, i, j, k = o.css(a, \"position\"),\n                l = o(a),\n                m = {};\n            \"static\" === k && (a.style.position = \"relative\"), h = l.offset(), f = o.css(a, \"top\"), i = o.css(a, \"left\"), j = (\"absolute\" === k || \"fixed\" === k) && (f + i).indexOf(\"auto\") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), o.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), \"using\" in b ? b.using.call(a, m) : l.css(m)\n        }\n    }, o.fn.extend({\n        offset: function(a) {\n            if (arguments.length) return void 0 === a ? this : this.each(function(b) {\n                o.offset.setOffset(this, a, b)\n            });\n            var b, c, d = this[0],\n                e = {\n                    top: 0,\n                    left: 0\n                },\n                f = d && d.ownerDocument;\n            if (f) return b = f.documentElement, o.contains(b, d) ? (typeof d.getBoundingClientRect !== U && (e = d.getBoundingClientRect()), c = Kc(f), {\n                top: e.top + c.pageYOffset - b.clientTop,\n                left: e.left + c.pageXOffset - b.clientLeft\n            }) : e\n        },\n        position: function() {\n            if (this[0]) {\n                var a, b, c = this[0],\n                    d = {\n                        top: 0,\n                        left: 0\n                    };\n                return \"fixed\" === o.css(c, \"position\") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), o.nodeName(a[0], \"html\") || (d = a.offset()), d.top += o.css(a[0], \"borderTopWidth\", !0), d.left += o.css(a[0], \"borderLeftWidth\", !0)), {\n                    top: b.top - d.top - o.css(c, \"marginTop\", !0),\n                    left: b.left - d.left - o.css(c, \"marginLeft\", !0)\n                }\n            }\n        },\n        offsetParent: function() {\n            return this.map(function() {\n                var a = this.offsetParent || Jc;\n                while (a && !o.nodeName(a, \"html\") && \"static\" === o.css(a, \"position\")) a = a.offsetParent;\n                return a || Jc\n            })\n        }\n    }), o.each({\n        scrollLeft: \"pageXOffset\",\n        scrollTop: \"pageYOffset\"\n    }, function(b, c) {\n        var d = \"pageYOffset\" === c;\n        o.fn[b] = function(e) {\n            return J(this, function(b, e, f) {\n                var g = Kc(b);\n                return void 0 === f ? g ? g[c] : b[e] : void(g ? g.scrollTo(d ? a.pageXOffset : f, d ? f : a.pageYOffset) : b[e] = f)\n            }, b, e, arguments.length, null)\n        }\n    }), o.each([\"top\", \"left\"], function(a, b) {\n        o.cssHooks[b] = yb(l.pixelPosition, function(a, c) {\n            return c ? (c = xb(a, b), vb.test(c) ? o(a).position()[b] + \"px\" : c) : void 0\n        })\n    }), o.each({\n        Height: \"height\",\n        Width: \"width\"\n    }, function(a, b) {\n        o.each({\n            padding: \"inner\" + a,\n            content: b,\n            \"\": \"outer\" + a\n        }, function(c, d) {\n            o.fn[d] = function(d, e) {\n                var f = arguments.length && (c || \"boolean\" != typeof d),\n                    g = c || (d === !0 || e === !0 ? \"margin\" : \"border\");\n                return J(this, function(b, c, d) {\n                    var e;\n                    return o.isWindow(b) ? b.document.documentElement[\"client\" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body[\"scroll\" + a], e[\"scroll\" + a], b.body[\"offset\" + a], e[\"offset\" + a], e[\"client\" + a])) : void 0 === d ? o.css(b, c, g) : o.style(b, c, d, g)\n                }, b, f ? d : void 0, f, null)\n            }\n        })\n    }), o.fn.size = function() {\n        return this.length\n    }, o.fn.andSelf = o.fn.addBack, \"function\" == typeof define && define.amd && define(\"jquery\", [], function() {\n        return o\n    });\n    var Lc = a.jQuery,\n        Mc = a.$;\n    return o.noConflict = function(b) {\n        return a.$ === o && (a.$ = Mc), b && a.jQuery === o && (a.jQuery = Lc), o\n    }, typeof b === U && (a.jQuery = a.$ = o), o\n});"
        }
    ]
}